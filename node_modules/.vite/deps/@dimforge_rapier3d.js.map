{
  "version": 3,
  "sources": ["../../@dimforge/rapier3d/src/exports.ts", "../../@dimforge/rapier3d/rapier_wasm3d.js", "../../@dimforge/rapier3d/rapier_wasm3d_bg.js", "../../@dimforge/rapier3d/src/math.ts", "../../@dimforge/rapier3d/src/dynamics/rigid_body.ts", "../../@dimforge/rapier3d/src/coarena.ts", "../../@dimforge/rapier3d/src/dynamics/rigid_body_set.ts", "../../@dimforge/rapier3d/src/dynamics/integration_parameters.ts", "../../@dimforge/rapier3d/src/dynamics/impulse_joint.ts", "../../@dimforge/rapier3d/src/dynamics/impulse_joint_set.ts", "../../@dimforge/rapier3d/src/dynamics/multibody_joint.ts", "../../@dimforge/rapier3d/src/dynamics/multibody_joint_set.ts", "../../@dimforge/rapier3d/src/dynamics/coefficient_combine_rule.ts", "../../@dimforge/rapier3d/src/dynamics/ccd_solver.ts", "../../@dimforge/rapier3d/src/dynamics/island_manager.ts", "../../@dimforge/rapier3d/src/geometry/broad_phase.ts", "../../@dimforge/rapier3d/src/geometry/narrow_phase.ts", "../../@dimforge/rapier3d/src/geometry/contact.ts", "../../@dimforge/rapier3d/src/geometry/feature.ts", "../../@dimforge/rapier3d/src/geometry/point.ts", "../../@dimforge/rapier3d/src/geometry/ray.ts", "../../@dimforge/rapier3d/src/geometry/toi.ts", "../../@dimforge/rapier3d/src/geometry/shape.ts", "../../@dimforge/rapier3d/src/pipeline/physics_pipeline.ts", "../../@dimforge/rapier3d/src/pipeline/query_pipeline.ts", "../../@dimforge/rapier3d/src/pipeline/serialization_pipeline.ts", "../../@dimforge/rapier3d/src/pipeline/debug_render_pipeline.ts", "../../@dimforge/rapier3d/src/control/character_controller.ts", "../../@dimforge/rapier3d/src/control/pid_controller.ts", "../../@dimforge/rapier3d/src/control/ray_cast_vehicle_controller.ts", "../../@dimforge/rapier3d/src/pipeline/world.ts", "../../@dimforge/rapier3d/src/pipeline/event_queue.ts", "../../@dimforge/rapier3d/src/pipeline/physics_hooks.ts", "../../@dimforge/rapier3d/src/geometry/collider.ts", "../../@dimforge/rapier3d/src/geometry/collider_set.ts", "../../@dimforge/rapier3d/src/rapier.ts"],
  "sourcesContent": ["import {version as vers} from \"./raw\";\n\nexport function version(): string {\n    return vers();\n}\n\nexport * from \"./math\";\nexport * from \"./dynamics\";\nexport * from \"./geometry\";\nexport * from \"./pipeline\";\nexport * from \"./init\";\nexport * from \"./control\";\n", "import * as wasm from \"./rapier_wasm3d_bg.wasm\";\nexport * from \"./rapier_wasm3d_bg.js\";\nimport { __wbg_set_wasm } from \"./rapier_wasm3d_bg.js\";\n__wbg_set_wasm(wasm);", "let wasm;\nexport function __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_export_0(addHeapObject(e));\n    }\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n/**\n * @returns {string}\n */\nexport function version() {\n    let deferred1_0;\n    let deferred1_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.version(retptr);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        deferred1_0 = r0;\n        deferred1_1 = r1;\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_export_1(deferred1_0, deferred1_1, 1);\n    }\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n}\n\nlet stack_pointer = 128;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nlet cachedFloat32ArrayMemory0 = null;\n\nfunction getFloat32ArrayMemory0() {\n    if (cachedFloat32ArrayMemory0 === null || cachedFloat32ArrayMemory0.byteLength === 0) {\n        cachedFloat32ArrayMemory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32ArrayMemory0;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet cachedUint32ArrayMemory0 = null;\n\nfunction getUint32ArrayMemory0() {\n    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {\n        cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32ArrayMemory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32ArrayMemory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getUint32ArrayMemory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n * @enum {0 | 1 | 2 | 3}\n */\nexport const RawFeatureType = Object.freeze({\n    Vertex: 0, \"0\": \"Vertex\",\n    Edge: 1, \"1\": \"Edge\",\n    Face: 2, \"2\": \"Face\",\n    Unknown: 3, \"3\": \"Unknown\",\n});\n/**\n * @enum {0 | 1 | 2 | 3 | 4 | 5}\n */\nexport const RawJointAxis = Object.freeze({\n    LinX: 0, \"0\": \"LinX\",\n    LinY: 1, \"1\": \"LinY\",\n    LinZ: 2, \"2\": \"LinZ\",\n    AngX: 3, \"3\": \"AngX\",\n    AngY: 4, \"4\": \"AngY\",\n    AngZ: 5, \"5\": \"AngZ\",\n});\n/**\n * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6}\n */\nexport const RawJointType = Object.freeze({\n    Revolute: 0, \"0\": \"Revolute\",\n    Fixed: 1, \"1\": \"Fixed\",\n    Prismatic: 2, \"2\": \"Prismatic\",\n    Rope: 3, \"3\": \"Rope\",\n    Spring: 4, \"4\": \"Spring\",\n    Spherical: 5, \"5\": \"Spherical\",\n    Generic: 6, \"6\": \"Generic\",\n});\n/**\n * @enum {0 | 1}\n */\nexport const RawMotorModel = Object.freeze({\n    AccelerationBased: 0, \"0\": \"AccelerationBased\",\n    ForceBased: 1, \"1\": \"ForceBased\",\n});\n/**\n * @enum {0 | 1 | 2 | 3}\n */\nexport const RawRigidBodyType = Object.freeze({\n    Dynamic: 0, \"0\": \"Dynamic\",\n    Fixed: 1, \"1\": \"Fixed\",\n    KinematicPositionBased: 2, \"2\": \"KinematicPositionBased\",\n    KinematicVelocityBased: 3, \"3\": \"KinematicVelocityBased\",\n});\n/**\n * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17}\n */\nexport const RawShapeType = Object.freeze({\n    Ball: 0, \"0\": \"Ball\",\n    Cuboid: 1, \"1\": \"Cuboid\",\n    Capsule: 2, \"2\": \"Capsule\",\n    Segment: 3, \"3\": \"Segment\",\n    Polyline: 4, \"4\": \"Polyline\",\n    Triangle: 5, \"5\": \"Triangle\",\n    TriMesh: 6, \"6\": \"TriMesh\",\n    HeightField: 7, \"7\": \"HeightField\",\n    Compound: 8, \"8\": \"Compound\",\n    ConvexPolyhedron: 9, \"9\": \"ConvexPolyhedron\",\n    Cylinder: 10, \"10\": \"Cylinder\",\n    Cone: 11, \"11\": \"Cone\",\n    RoundCuboid: 12, \"12\": \"RoundCuboid\",\n    RoundTriangle: 13, \"13\": \"RoundTriangle\",\n    RoundCylinder: 14, \"14\": \"RoundCylinder\",\n    RoundCone: 15, \"15\": \"RoundCone\",\n    RoundConvexPolyhedron: 16, \"16\": \"RoundConvexPolyhedron\",\n    HalfSpace: 17, \"17\": \"HalfSpace\",\n});\n\nconst RawBroadPhaseFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawbroadphase_free(ptr >>> 0, 1));\n\nexport class RawBroadPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawBroadPhase.prototype);\n        obj.__wbg_ptr = ptr;\n        RawBroadPhaseFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawBroadPhaseFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawbroadphase_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawbroadphase_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawBroadPhaseFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\n\nconst RawCCDSolverFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawccdsolver_free(ptr >>> 0, 1));\n\nexport class RawCCDSolver {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawCCDSolverFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawccdsolver_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawccdsolver_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawCCDSolverFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\n\nconst RawCharacterCollisionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcharactercollision_free(ptr >>> 0, 1));\n\nexport class RawCharacterCollision {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawCharacterCollisionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcharactercollision_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawcharactercollision_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawCharacterCollisionFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {number}\n     */\n    handle() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    translationDeltaApplied() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    translationDeltaRemaining() {\n        const ret = wasm.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    worldWitness1() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    worldWitness2() {\n        const ret = wasm.rawcharactercollision_worldWitness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    worldNormal1() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    worldNormal2() {\n        const ret = wasm.rawcharactercollision_worldNormal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawColliderSetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcolliderset_free(ptr >>> 0, 1));\n\nexport class RawColliderSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawColliderSet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawColliderSetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawColliderSetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcolliderset_free(ptr, 0);\n    }\n    /**\n     * The world-space translation of this collider.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    coTranslation(handle) {\n        const ret = wasm.rawcolliderset_coTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The world-space orientation of this collider.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    coRotation(handle) {\n        const ret = wasm.rawcolliderset_coRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * Sets the translation of this collider.\n     *\n     * # Parameters\n     * - `x`: the world-space position of the collider along the `x` axis.\n     * - `y`: the world-space position of the collider along the `y` axis.\n     * - `z`: the world-space position of the collider along the `z` axis.\n     * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     * @param {number} handle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} z\n     */\n    coSetTranslation(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslation(this.__wbg_ptr, handle, x, y, z);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} z\n     */\n    coSetTranslationWrtParent(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslationWrtParent(this.__wbg_ptr, handle, x, y, z);\n    }\n    /**\n     * Sets the rotation quaternion of this collider.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * # Parameters\n     * - `x`: the first vector component of the quaternion.\n     * - `y`: the second vector component of the quaternion.\n     * - `z`: the third vector component of the quaternion.\n     * - `w`: the scalar component of the quaternion.\n     * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     * @param {number} handle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} z\n     * @param {number} w\n     */\n    coSetRotation(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotation(this.__wbg_ptr, handle, x, y, z, w);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} z\n     * @param {number} w\n     */\n    coSetRotationWrtParent(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotationWrtParent(this.__wbg_ptr, handle, x, y, z, w);\n    }\n    /**\n     * Is this collider a sensor?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    coIsSensor(handle) {\n        const ret = wasm.rawcolliderset_coIsSensor(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * The type of the shape of this collider.\n     * @param {number} handle\n     * @returns {RawShapeType}\n     */\n    coShapeType(handle) {\n        const ret = wasm.rawcolliderset_coShapeType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @returns {RawVector | undefined}\n     */\n    coHalfspaceNormal(handle) {\n        const ret = wasm.rawcolliderset_coHalfspaceNormal(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * The half-extents of this collider if it is has a cuboid shape.\n     * @param {number} handle\n     * @returns {RawVector | undefined}\n     */\n    coHalfExtents(handle) {\n        const ret = wasm.rawcolliderset_coHalfExtents(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * Set the half-extents of this collider if it has a cuboid shape.\n     * @param {number} handle\n     * @param {RawVector} newHalfExtents\n     */\n    coSetHalfExtents(handle, newHalfExtents) {\n        _assertClass(newHalfExtents, RawVector);\n        wasm.rawcolliderset_coSetHalfExtents(this.__wbg_ptr, handle, newHalfExtents.__wbg_ptr);\n    }\n    /**\n     * The radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coRadius(handle) {\n        const ret = wasm.rawcolliderset_coRadius(this.__wbg_ptr, handle);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * Set the radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n     * @param {number} handle\n     * @param {number} newRadius\n     */\n    coSetRadius(handle, newRadius) {\n        wasm.rawcolliderset_coSetRadius(this.__wbg_ptr, handle, newRadius);\n    }\n    /**\n     * The half height of this collider if it is a capsule, cylinder, or cone shape.\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coHalfHeight(handle) {\n        const ret = wasm.rawcolliderset_coHalfHeight(this.__wbg_ptr, handle);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * Set the half height of this collider if it is a capsule, cylinder, or cone shape.\n     * @param {number} handle\n     * @param {number} newHalfheight\n     */\n    coSetHalfHeight(handle, newHalfheight) {\n        wasm.rawcolliderset_coSetHalfHeight(this.__wbg_ptr, handle, newHalfheight);\n    }\n    /**\n     * The radius of the round edges of this collider.\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coRoundRadius(handle) {\n        const ret = wasm.rawcolliderset_coRoundRadius(this.__wbg_ptr, handle);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * Set the radius of the round edges of this collider.\n     * @param {number} handle\n     * @param {number} newBorderRadius\n     */\n    coSetRoundRadius(handle, newBorderRadius) {\n        wasm.rawcolliderset_coSetRoundRadius(this.__wbg_ptr, handle, newBorderRadius);\n    }\n    /**\n     * The vertices of this triangle mesh, polyline, convex polyhedron, segment, triangle or convex polyhedron, if it is one.\n     * @param {number} handle\n     * @returns {Float32Array | undefined}\n     */\n    coVertices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coVertices(retptr, this.__wbg_ptr, handle);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * The indices of this triangle mesh, polyline, or convex polyhedron, if it is one.\n     * @param {number} handle\n     * @returns {Uint32Array | undefined}\n     */\n    coIndices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coIndices(retptr, this.__wbg_ptr, handle);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coTriMeshFlags(handle) {\n        const ret = wasm.rawcolliderset_coTriMeshFlags(this.__wbg_ptr, handle);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coHeightFieldFlags(handle) {\n        const ret = wasm.rawcolliderset_coHeightFieldFlags(this.__wbg_ptr, handle);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * The height of this heightfield if it is one.\n     * @param {number} handle\n     * @returns {Float32Array | undefined}\n     */\n    coHeightfieldHeights(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldHeights(retptr, this.__wbg_ptr, handle);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * The scaling factor applied of this heightfield if it is one.\n     * @param {number} handle\n     * @returns {RawVector | undefined}\n     */\n    coHeightfieldScale(handle) {\n        const ret = wasm.rawcolliderset_coHeightfieldScale(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * The number of rows on this heightfield's height matrix, if it is one.\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coHeightfieldNRows(handle) {\n        const ret = wasm.rawcolliderset_coHeightfieldNRows(this.__wbg_ptr, handle);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * The number of columns on this heightfield's height matrix, if it is one.\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coHeightfieldNCols(handle) {\n        const ret = wasm.rawcolliderset_coHeightfieldNCols(this.__wbg_ptr, handle);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * The unique integer identifier of the collider this collider is attached to.\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coParent(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coParent(retptr, this.__wbg_ptr, handle);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r2 = getDataViewMemory0().getFloat64(retptr + 8 * 1, true);\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} enabled\n     */\n    coSetEnabled(handle, enabled) {\n        wasm.rawcolliderset_coSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    coIsEnabled(handle) {\n        const ret = wasm.rawcolliderset_coIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} contact_skin\n     */\n    coSetContactSkin(handle, contact_skin) {\n        wasm.rawcolliderset_coSetContactSkin(this.__wbg_ptr, handle, contact_skin);\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    coContactSkin(handle) {\n        const ret = wasm.rawcolliderset_coContactSkin(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The friction coefficient of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coFriction(handle) {\n        const ret = wasm.rawcolliderset_coFriction(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The restitution coefficient of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coRestitution(handle) {\n        const ret = wasm.rawcolliderset_coRestitution(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The density of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coDensity(handle) {\n        const ret = wasm.rawcolliderset_coDensity(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The mass of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coMass(handle) {\n        const ret = wasm.rawcolliderset_coMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The volume of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coVolume(handle) {\n        const ret = wasm.rawcolliderset_coVolume(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The collision groups of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coCollisionGroups(handle) {\n        const ret = wasm.rawcolliderset_coCollisionGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * The solver groups of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coSolverGroups(handle) {\n        const ret = wasm.rawcolliderset_coSolverGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * The physics hooks enabled for this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coActiveHooks(handle) {\n        const ret = wasm.rawcolliderset_coActiveHooks(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * The collision types enabled for this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coActiveCollisionTypes(handle) {\n        const ret = wasm.rawcolliderset_coActiveCollisionTypes(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The events enabled for this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coActiveEvents(handle) {\n        const ret = wasm.rawcolliderset_coActiveEvents(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * The total force magnitude beyond which a contact force event can be emitted.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coContactForceEventThreshold(handle) {\n        const ret = wasm.rawcolliderset_coContactForceEventThreshold(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} point\n     * @returns {boolean}\n     */\n    coContainsPoint(handle, point) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coContainsPoint(this.__wbg_ptr, handle, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} colliderVel\n     * @param {RawShape} shape2\n     * @param {RawVector} shape2Pos\n     * @param {RawRotation} shape2Rot\n     * @param {RawVector} shape2Vel\n     * @param {number} target_distance\n     * @param {number} maxToi\n     * @param {boolean} stop_at_penetration\n     * @returns {RawShapeCastHit | undefined}\n     */\n    coCastShape(handle, colliderVel, shape2, shape2Pos, shape2Rot, shape2Vel, target_distance, maxToi, stop_at_penetration) {\n        _assertClass(colliderVel, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shape2Pos, RawVector);\n        _assertClass(shape2Rot, RawRotation);\n        _assertClass(shape2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastShape(this.__wbg_ptr, handle, colliderVel.__wbg_ptr, shape2.__wbg_ptr, shape2Pos.__wbg_ptr, shape2Rot.__wbg_ptr, shape2Vel.__wbg_ptr, target_distance, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeCastHit.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} collider1Vel\n     * @param {number} collider2handle\n     * @param {RawVector} collider2Vel\n     * @param {number} target_distance\n     * @param {number} max_toi\n     * @param {boolean} stop_at_penetration\n     * @returns {RawColliderShapeCastHit | undefined}\n     */\n    coCastCollider(handle, collider1Vel, collider2handle, collider2Vel, target_distance, max_toi, stop_at_penetration) {\n        _assertClass(collider1Vel, RawVector);\n        _assertClass(collider2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastCollider(this.__wbg_ptr, handle, collider1Vel.__wbg_ptr, collider2handle, collider2Vel.__wbg_ptr, target_distance, max_toi, stop_at_penetration);\n        return ret === 0 ? undefined : RawColliderShapeCastHit.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawShape} shape2\n     * @param {RawVector} shapePos2\n     * @param {RawRotation} shapeRot2\n     * @returns {boolean}\n     */\n    coIntersectsShape(handle, shape2, shapePos2, shapeRot2) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coIntersectsShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawShape} shape2\n     * @param {RawVector} shapePos2\n     * @param {RawRotation} shapeRot2\n     * @param {number} prediction\n     * @returns {RawShapeContact | undefined}\n     */\n    coContactShape(handle, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coContactShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} collider2handle\n     * @param {number} prediction\n     * @returns {RawShapeContact | undefined}\n     */\n    coContactCollider(handle, collider2handle, prediction) {\n        const ret = wasm.rawcolliderset_coContactCollider(this.__wbg_ptr, handle, collider2handle, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} point\n     * @param {boolean} solid\n     * @returns {RawPointProjection}\n     */\n    coProjectPoint(handle, point, solid) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coProjectPoint(this.__wbg_ptr, handle, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @returns {boolean}\n     */\n    coIntersectsRay(handle, rayOrig, rayDir, maxToi) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coIntersectsRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @returns {number}\n     */\n    coCastRay(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @returns {RawRayIntersection | undefined}\n     */\n    coCastRayAndGetNormal(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRayAndGetNormal(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} is_sensor\n     */\n    coSetSensor(handle, is_sensor) {\n        wasm.rawcolliderset_coSetSensor(this.__wbg_ptr, handle, is_sensor);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} restitution\n     */\n    coSetRestitution(handle, restitution) {\n        wasm.rawcolliderset_coSetRestitution(this.__wbg_ptr, handle, restitution);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} friction\n     */\n    coSetFriction(handle, friction) {\n        wasm.rawcolliderset_coSetFriction(this.__wbg_ptr, handle, friction);\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    coFrictionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coFrictionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} rule\n     */\n    coSetFrictionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetFrictionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    coRestitutionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coRestitutionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} rule\n     */\n    coSetRestitutionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetRestitutionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} groups\n     */\n    coSetCollisionGroups(handle, groups) {\n        wasm.rawcolliderset_coSetCollisionGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} groups\n     */\n    coSetSolverGroups(handle, groups) {\n        wasm.rawcolliderset_coSetSolverGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} hooks\n     */\n    coSetActiveHooks(handle, hooks) {\n        wasm.rawcolliderset_coSetActiveHooks(this.__wbg_ptr, handle, hooks);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} events\n     */\n    coSetActiveEvents(handle, events) {\n        wasm.rawcolliderset_coSetActiveEvents(this.__wbg_ptr, handle, events);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} types\n     */\n    coSetActiveCollisionTypes(handle, types) {\n        wasm.rawcolliderset_coSetActiveCollisionTypes(this.__wbg_ptr, handle, types);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawShape} shape\n     */\n    coSetShape(handle, shape) {\n        _assertClass(shape, RawShape);\n        wasm.rawcolliderset_coSetShape(this.__wbg_ptr, handle, shape.__wbg_ptr);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} threshold\n     */\n    coSetContactForceEventThreshold(handle, threshold) {\n        wasm.rawcolliderset_coSetContactForceEventThreshold(this.__wbg_ptr, handle, threshold);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} density\n     */\n    coSetDensity(handle, density) {\n        wasm.rawcolliderset_coSetDensity(this.__wbg_ptr, handle, density);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} mass\n     */\n    coSetMass(handle, mass) {\n        wasm.rawcolliderset_coSetMass(this.__wbg_ptr, handle, mass);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} mass\n     * @param {RawVector} centerOfMass\n     * @param {RawVector} principalAngularInertia\n     * @param {RawRotation} angularInertiaFrame\n     */\n    coSetMassProperties(handle, mass, centerOfMass, principalAngularInertia, angularInertiaFrame) {\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        wasm.rawcolliderset_coSetMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia.__wbg_ptr, angularInertiaFrame.__wbg_ptr);\n    }\n    constructor() {\n        const ret = wasm.rawcolliderset_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawColliderSetFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    contains(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * @param {boolean} enabled\n     * @param {RawShape} shape\n     * @param {RawVector} translation\n     * @param {RawRotation} rotation\n     * @param {number} massPropsMode\n     * @param {number} mass\n     * @param {RawVector} centerOfMass\n     * @param {RawVector} principalAngularInertia\n     * @param {RawRotation} angularInertiaFrame\n     * @param {number} density\n     * @param {number} friction\n     * @param {number} restitution\n     * @param {number} frictionCombineRule\n     * @param {number} restitutionCombineRule\n     * @param {boolean} isSensor\n     * @param {number} collisionGroups\n     * @param {number} solverGroups\n     * @param {number} activeCollisionTypes\n     * @param {number} activeHooks\n     * @param {number} activeEvents\n     * @param {number} contactForceEventThreshold\n     * @param {number} contactSkin\n     * @param {boolean} hasParent\n     * @param {number} parent\n     * @param {RawRigidBodySet} bodies\n     * @returns {number | undefined}\n     */\n    createCollider(enabled, shape, translation, rotation, massPropsMode, mass, centerOfMass, principalAngularInertia, angularInertiaFrame, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, contactSkin, hasParent, parent, bodies) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(shape, RawShape);\n            _assertClass(translation, RawVector);\n            _assertClass(rotation, RawRotation);\n            _assertClass(centerOfMass, RawVector);\n            _assertClass(principalAngularInertia, RawVector);\n            _assertClass(angularInertiaFrame, RawRotation);\n            _assertClass(bodies, RawRigidBodySet);\n            wasm.rawcolliderset_createCollider(retptr, this.__wbg_ptr, enabled, shape.__wbg_ptr, translation.__wbg_ptr, rotation.__wbg_ptr, massPropsMode, mass, centerOfMass.__wbg_ptr, principalAngularInertia.__wbg_ptr, angularInertiaFrame.__wbg_ptr, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, contactSkin, hasParent, parent, bodies.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r2 = getDataViewMemory0().getFloat64(retptr + 8 * 1, true);\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Removes a collider from this set and wake-up the rigid-body it is attached to.\n     * @param {number} handle\n     * @param {RawIslandManager} islands\n     * @param {RawRigidBodySet} bodies\n     * @param {boolean} wakeUp\n     */\n    remove(handle, islands, bodies, wakeUp) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawcolliderset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, bodies.__wbg_ptr, wakeUp);\n    }\n    /**\n     * Checks if a collider with the given integer handle exists.\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    isHandleValid(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each collider managed by this collider set.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each collider managed by this collider set. Called as `f(handle)`.\n     * @param {Function} f\n     */\n    forEachColliderHandle(f) {\n        try {\n            wasm.rawcolliderset_forEachColliderHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawColliderShapeCastHitFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcollidershapecasthit_free(ptr >>> 0, 1));\n\nexport class RawColliderShapeCastHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawColliderShapeCastHit.prototype);\n        obj.__wbg_ptr = ptr;\n        RawColliderShapeCastHitFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawColliderShapeCastHitFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcollidershapecasthit_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    colliderHandle() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    witness1() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    witness2() {\n        const ret = wasm.rawcollidershapecasthit_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal1() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal2() {\n        const ret = wasm.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawContactForceEventFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcontactforceevent_free(ptr >>> 0, 1));\n\nexport class RawContactForceEvent {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactForceEvent.prototype);\n        obj.__wbg_ptr = ptr;\n        RawContactForceEventFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawContactForceEventFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactforceevent_free(ptr, 0);\n    }\n    /**\n     * The first collider involved in the contact.\n     * @returns {number}\n     */\n    collider1() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The second collider involved in the contact.\n     * @returns {number}\n     */\n    collider2() {\n        const ret = wasm.rawcontactforceevent_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The sum of all the forces between the two colliders.\n     * @returns {RawVector}\n     */\n    total_force() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The sum of the magnitudes of each force between the two colliders.\n     *\n     * Note that this is **not** the same as the magnitude of `self.total_force`.\n     * Here we are summing the magnitude of all the forces, instead of taking\n     * the magnitude of their sum.\n     * @returns {number}\n     */\n    total_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The world-space (unit) direction of the force with strongest magnitude.\n     * @returns {RawVector}\n     */\n    max_force_direction() {\n        const ret = wasm.rawcontactforceevent_max_force_direction(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The magnitude of the largest force at a contact point of this contact pair.\n     * @returns {number}\n     */\n    max_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RawContactManifoldFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcontactmanifold_free(ptr >>> 0, 1));\n\nexport class RawContactManifold {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactManifold.prototype);\n        obj.__wbg_ptr = ptr;\n        RawContactManifoldFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawContactManifoldFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactmanifold_free(ptr, 0);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal() {\n        const ret = wasm.rawcontactmanifold_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    local_n1() {\n        const ret = wasm.rawcontactmanifold_local_n1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    local_n2() {\n        const ret = wasm.rawcontactmanifold_local_n2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    subshape1() {\n        const ret = wasm.rawcontactmanifold_subshape1(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    subshape2() {\n        const ret = wasm.rawcontactmanifold_subshape2(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    num_contacts() {\n        const ret = wasm.rawcontactmanifold_num_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector | undefined}\n     */\n    contact_local_p1(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p1(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector | undefined}\n     */\n    contact_local_p2(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p2(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    contact_fid1(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid1(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    contact_fid2(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid2(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    contact_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_impulse(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    contact_tangent_impulse_x(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse_x(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    contact_tangent_impulse_y(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse_y(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    num_solver_contacts() {\n        const ret = wasm.rawcontactmanifold_num_solver_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector | undefined}\n     */\n    solver_contact_point(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_point(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    solver_contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    solver_contact_friction(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_friction(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    solver_contact_restitution(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_restitution(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector}\n     */\n    solver_contact_tangent_velocity(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_tangent_velocity(this.__wbg_ptr, i);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawContactPairFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcontactpair_free(ptr >>> 0, 1));\n\nexport class RawContactPair {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactPair.prototype);\n        obj.__wbg_ptr = ptr;\n        RawContactPairFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawContactPairFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactpair_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    collider1() {\n        const ret = wasm.rawcontactpair_collider1(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    collider2() {\n        const ret = wasm.rawcontactpair_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    numContactManifolds() {\n        const ret = wasm.rawcontactpair_numContactManifolds(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @returns {RawContactManifold | undefined}\n     */\n    contactManifold(i) {\n        const ret = wasm.rawcontactpair_contactManifold(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawContactManifold.__wrap(ret);\n    }\n}\n\nconst RawDebugRenderPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawdebugrenderpipeline_free(ptr >>> 0, 1));\n\nexport class RawDebugRenderPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawDebugRenderPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdebugrenderpipeline_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawdebugrenderpipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawDebugRenderPipelineFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {Float32Array}\n     */\n    vertices() {\n        const ret = wasm.rawdebugrenderpipeline_vertices(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @returns {Float32Array}\n     */\n    colors() {\n        const ret = wasm.rawdebugrenderpipeline_colors(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawImpulseJointSet} impulse_joints\n     * @param {RawMultibodyJointSet} multibody_joints\n     * @param {RawNarrowPhase} narrow_phase\n     */\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        _assertClass(narrow_phase, RawNarrowPhase);\n        wasm.rawdebugrenderpipeline_render(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr, narrow_phase.__wbg_ptr);\n    }\n}\n\nconst RawDeserializedWorldFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawdeserializedworld_free(ptr >>> 0, 1));\n\nexport class RawDeserializedWorld {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawDeserializedWorld.prototype);\n        obj.__wbg_ptr = ptr;\n        RawDeserializedWorldFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawDeserializedWorldFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdeserializedworld_free(ptr, 0);\n    }\n    /**\n     * @returns {RawVector | undefined}\n     */\n    takeGravity() {\n        const ret = wasm.rawdeserializedworld_takeGravity(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawIntegrationParameters | undefined}\n     */\n    takeIntegrationParameters() {\n        const ret = wasm.rawdeserializedworld_takeIntegrationParameters(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n     * @returns {RawIslandManager | undefined}\n     */\n    takeIslandManager() {\n        const ret = wasm.rawdeserializedworld_takeIslandManager(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIslandManager.__wrap(ret);\n    }\n    /**\n     * @returns {RawBroadPhase | undefined}\n     */\n    takeBroadPhase() {\n        const ret = wasm.rawdeserializedworld_takeBroadPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawBroadPhase.__wrap(ret);\n    }\n    /**\n     * @returns {RawNarrowPhase | undefined}\n     */\n    takeNarrowPhase() {\n        const ret = wasm.rawdeserializedworld_takeNarrowPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawNarrowPhase.__wrap(ret);\n    }\n    /**\n     * @returns {RawRigidBodySet | undefined}\n     */\n    takeBodies() {\n        const ret = wasm.rawdeserializedworld_takeBodies(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawRigidBodySet.__wrap(ret);\n    }\n    /**\n     * @returns {RawColliderSet | undefined}\n     */\n    takeColliders() {\n        const ret = wasm.rawdeserializedworld_takeColliders(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawColliderSet.__wrap(ret);\n    }\n    /**\n     * @returns {RawImpulseJointSet | undefined}\n     */\n    takeImpulseJoints() {\n        const ret = wasm.rawdeserializedworld_takeImpulseJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n     * @returns {RawMultibodyJointSet | undefined}\n     */\n    takeMultibodyJoints() {\n        const ret = wasm.rawdeserializedworld_takeMultibodyJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawMultibodyJointSet.__wrap(ret);\n    }\n}\n\nconst RawDynamicRayCastVehicleControllerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawdynamicraycastvehiclecontroller_free(ptr >>> 0, 1));\n\nexport class RawDynamicRayCastVehicleController {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawDynamicRayCastVehicleControllerFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdynamicraycastvehiclecontroller_free(ptr, 0);\n    }\n    /**\n     * @param {number} chassis\n     */\n    constructor(chassis) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_new(chassis);\n        this.__wbg_ptr = ret >>> 0;\n        RawDynamicRayCastVehicleControllerFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {number}\n     */\n    current_vehicle_speed() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_current_vehicle_speed(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    chassis() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_chassis(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    index_up_axis() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_index_up_axis(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} axis\n     */\n    set_index_up_axis(axis) {\n        wasm.rawdynamicraycastvehiclecontroller_set_index_up_axis(this.__wbg_ptr, axis);\n    }\n    /**\n     * @returns {number}\n     */\n    index_forward_axis() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_index_forward_axis(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} axis\n     */\n    set_index_forward_axis(axis) {\n        wasm.rawdynamicraycastvehiclecontroller_set_index_forward_axis(this.__wbg_ptr, axis);\n    }\n    /**\n     * @param {RawVector} chassis_connection_cs\n     * @param {RawVector} direction_cs\n     * @param {RawVector} axle_cs\n     * @param {number} suspension_rest_length\n     * @param {number} radius\n     */\n    add_wheel(chassis_connection_cs, direction_cs, axle_cs, suspension_rest_length, radius) {\n        _assertClass(chassis_connection_cs, RawVector);\n        _assertClass(direction_cs, RawVector);\n        _assertClass(axle_cs, RawVector);\n        wasm.rawdynamicraycastvehiclecontroller_add_wheel(this.__wbg_ptr, chassis_connection_cs.__wbg_ptr, direction_cs.__wbg_ptr, axle_cs.__wbg_ptr, suspension_rest_length, radius);\n    }\n    /**\n     * @returns {number}\n     */\n    num_wheels() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_num_wheels(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} dt\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawQueryPipeline} queries\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {Function} filter_predicate\n     */\n    update_vehicle(dt, bodies, colliders, queries, filter_flags, filter_groups, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(queries, RawQueryPipeline);\n            wasm.rawdynamicraycastvehiclecontroller_update_vehicle(this.__wbg_ptr, dt, bodies.__wbg_ptr, colliders.__wbg_ptr, queries.__wbg_ptr, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector | undefined}\n     */\n    wheel_chassis_connection_point_cs(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_chassis_connection_point_cs(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} i\n     * @param {RawVector} value\n     */\n    set_wheel_chassis_connection_point_cs(i, value) {\n        _assertClass(value, RawVector);\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_chassis_connection_point_cs(this.__wbg_ptr, i, value.__wbg_ptr);\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_suspension_rest_length(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_rest_length(this.__wbg_ptr, i);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} i\n     * @param {number} value\n     */\n    set_wheel_suspension_rest_length(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_suspension_rest_length(this.__wbg_ptr, i, value);\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_max_suspension_travel(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_max_suspension_travel(this.__wbg_ptr, i);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} i\n     * @param {number} value\n     */\n    set_wheel_max_suspension_travel(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_travel(this.__wbg_ptr, i, value);\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_radius(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_radius(this.__wbg_ptr, i);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} i\n     * @param {number} value\n     */\n    set_wheel_radius(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_radius(this.__wbg_ptr, i, value);\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_suspension_stiffness(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_stiffness(this.__wbg_ptr, i);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} i\n     * @param {number} value\n     */\n    set_wheel_suspension_stiffness(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_suspension_stiffness(this.__wbg_ptr, i, value);\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_suspension_compression(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_compression(this.__wbg_ptr, i);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} i\n     * @param {number} value\n     */\n    set_wheel_suspension_compression(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_suspension_compression(this.__wbg_ptr, i, value);\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_suspension_relaxation(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_relaxation(this.__wbg_ptr, i);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} i\n     * @param {number} value\n     */\n    set_wheel_suspension_relaxation(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_suspension_relaxation(this.__wbg_ptr, i, value);\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_max_suspension_force(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_max_suspension_force(this.__wbg_ptr, i);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} i\n     * @param {number} value\n     */\n    set_wheel_max_suspension_force(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_force(this.__wbg_ptr, i, value);\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_brake(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_brake(this.__wbg_ptr, i);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} i\n     * @param {number} value\n     */\n    set_wheel_brake(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_brake(this.__wbg_ptr, i, value);\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_steering(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_steering(this.__wbg_ptr, i);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} i\n     * @param {number} value\n     */\n    set_wheel_steering(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_steering(this.__wbg_ptr, i, value);\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_engine_force(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_engine_force(this.__wbg_ptr, i);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} i\n     * @param {number} value\n     */\n    set_wheel_engine_force(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_engine_force(this.__wbg_ptr, i, value);\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector | undefined}\n     */\n    wheel_direction_cs(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_direction_cs(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} i\n     * @param {RawVector} value\n     */\n    set_wheel_direction_cs(i, value) {\n        _assertClass(value, RawVector);\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_direction_cs(this.__wbg_ptr, i, value.__wbg_ptr);\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector | undefined}\n     */\n    wheel_axle_cs(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_axle_cs(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} i\n     * @param {RawVector} value\n     */\n    set_wheel_axle_cs(i, value) {\n        _assertClass(value, RawVector);\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_axle_cs(this.__wbg_ptr, i, value.__wbg_ptr);\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_friction_slip(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_friction_slip(this.__wbg_ptr, i);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} i\n     * @param {number} value\n     */\n    set_wheel_friction_slip(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_friction_slip(this.__wbg_ptr, i, value);\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_side_friction_stiffness(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_side_friction_stiffness(this.__wbg_ptr, i);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} i\n     * @param {number} stiffness\n     */\n    set_wheel_side_friction_stiffness(i, stiffness) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_side_friction_stiffness(this.__wbg_ptr, i, stiffness);\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_rotation(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_rotation(this.__wbg_ptr, i);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_forward_impulse(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_forward_impulse(this.__wbg_ptr, i);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_side_impulse(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_side_impulse(this.__wbg_ptr, i);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_suspension_force(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_force(this.__wbg_ptr, i);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector | undefined}\n     */\n    wheel_contact_normal_ws(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_contact_normal_ws(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector | undefined}\n     */\n    wheel_contact_point_ws(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_contact_point_ws(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_suspension_length(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_length(this.__wbg_ptr, i);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector | undefined}\n     */\n    wheel_hard_point_ws(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_hard_point_ws(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} i\n     * @returns {boolean}\n     */\n    wheel_is_in_contact(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_is_in_contact(this.__wbg_ptr, i);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} i\n     * @returns {number | undefined}\n     */\n    wheel_ground_object(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_ground_object(retptr, this.__wbg_ptr, i);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r2 = getDataViewMemory0().getFloat64(retptr + 8 * 1, true);\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst RawEventQueueFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_raweventqueue_free(ptr >>> 0, 1));\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n */\nexport class RawEventQueue {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawEventQueueFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_raweventqueue_free(ptr, 0);\n    }\n    /**\n     * Creates a new event collector.\n     *\n     * # Parameters\n     * - `autoDrain`: setting this to `true` is strongly recommended. If true, the collector will\n     * be automatically drained before each `world.step(collector)`. If false, the collector will\n     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n     * RAM if no drain is performed.\n     * @param {boolean} autoDrain\n     */\n    constructor(autoDrain) {\n        const ret = wasm.raweventqueue_new(autoDrain);\n        this.__wbg_ptr = ret >>> 0;\n        RawEventQueueFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Applies the given javascript closure on each collision event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * # Parameters\n     * - `f(handle1, handle2, started)`:  JavaScript closure applied to each collision event. The\n     * closure should take three arguments: two integers representing the handles of the colliders\n     * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n     * (false).\n     * @param {Function} f\n     */\n    drainCollisionEvents(f) {\n        try {\n            wasm.raweventqueue_drainCollisionEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {Function} f\n     */\n    drainContactForceEvents(f) {\n        try {\n            wasm.raweventqueue_drainContactForceEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Removes all events contained by this collector.\n     */\n    clear() {\n        wasm.raweventqueue_clear(this.__wbg_ptr);\n    }\n}\n\nconst RawGenericJointFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawgenericjoint_free(ptr >>> 0, 1));\n\nexport class RawGenericJoint {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawGenericJoint.prototype);\n        obj.__wbg_ptr = ptr;\n        RawGenericJointFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawGenericJointFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawgenericjoint_free(ptr, 0);\n    }\n    /**\n     * Creates a new joint descriptor that builds generic joints.\n     *\n     * Generic joints allow arbitrary axes of freedom to be selected\n     * for the joint from the available 6 degrees of freedom.\n     * @param {RawVector} anchor1\n     * @param {RawVector} anchor2\n     * @param {RawVector} axis\n     * @param {number} lockedAxes\n     * @returns {RawGenericJoint | undefined}\n     */\n    static generic(anchor1, anchor2, axis, lockedAxes) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_generic(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr, lockedAxes);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n     * @param {number} rest_length\n     * @param {number} stiffness\n     * @param {number} damping\n     * @param {RawVector} anchor1\n     * @param {RawVector} anchor2\n     * @returns {RawGenericJoint}\n     */\n    static spring(rest_length, stiffness, damping, anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_spring(rest_length, stiffness, damping, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n     * @param {number} length\n     * @param {RawVector} anchor1\n     * @param {RawVector} anchor2\n     * @returns {RawGenericJoint}\n     */\n    static rope(length, anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_rope(length, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n     * Create a new joint descriptor that builds spherical joints.\n     *\n     * A spherical joints allows three relative rotational degrees of freedom\n     * by preventing any relative translation between the anchors of the\n     * two attached rigid-bodies.\n     * @param {RawVector} anchor1\n     * @param {RawVector} anchor2\n     * @returns {RawGenericJoint}\n     */\n    static spherical(anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_spherical(anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * Returns `None` if any of the provided axes cannot be normalized.\n     * @param {RawVector} anchor1\n     * @param {RawVector} anchor2\n     * @param {RawVector} axis\n     * @param {boolean} limitsEnabled\n     * @param {number} limitsMin\n     * @param {number} limitsMax\n     * @returns {RawGenericJoint | undefined}\n     */\n    static prismatic(anchor1, anchor2, axis, limitsEnabled, limitsMin, limitsMax) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_prismatic(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr, limitsEnabled, limitsMin, limitsMax);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n     * Creates a new joint descriptor that builds a Fixed joint.\n     *\n     * A fixed joint removes all the degrees of freedom between the affected bodies.\n     * @param {RawVector} anchor1\n     * @param {RawRotation} axes1\n     * @param {RawVector} anchor2\n     * @param {RawRotation} axes2\n     * @returns {RawGenericJoint}\n     */\n    static fixed(anchor1, axes1, anchor2, axes2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(axes1, RawRotation);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axes2, RawRotation);\n        const ret = wasm.rawgenericjoint_fixed(anchor1.__wbg_ptr, axes1.__wbg_ptr, anchor2.__wbg_ptr, axes2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n     * Create a new joint descriptor that builds Revolute joints.\n     *\n     * A revolute joint removes all degrees of freedom between the affected\n     * bodies except for the rotation along one axis.\n     * @param {RawVector} anchor1\n     * @param {RawVector} anchor2\n     * @param {RawVector} axis\n     * @returns {RawGenericJoint | undefined}\n     */\n    static revolute(anchor1, anchor2, axis) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_revolute(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n}\n\nconst RawImpulseJointSetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawimpulsejointset_free(ptr >>> 0, 1));\n\nexport class RawImpulseJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawImpulseJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawImpulseJointSetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawImpulseJointSetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawimpulsejointset_free(ptr, 0);\n    }\n    /**\n     * The type of this joint.\n     * @param {number} handle\n     * @returns {RawJointType}\n     */\n    jointType(handle) {\n        const ret = wasm.rawimpulsejointset_jointType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The unique integer identifier of the first rigid-body this joint it attached to.\n     * @param {number} handle\n     * @returns {number}\n     */\n    jointBodyHandle1(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle1(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The unique integer identifier of the second rigid-body this joint is attached to.\n     * @param {number} handle\n     * @returns {number}\n     */\n    jointBodyHandle2(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle2(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The angular part of the joints local frame relative to the first rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    jointFrameX1(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The angular part of the joints local frame relative to the second rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    jointFrameX2(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the points application point on the\n     * local frame of the first rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    jointAnchor1(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the points application point on the\n     * local frame of the second rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    jointAnchor2(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Sets the position of the first local anchor\n     * @param {number} handle\n     * @param {RawVector} newPos\n     */\n    jointSetAnchor1(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor1(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n     * Sets the position of the second local anchor\n     * @param {number} handle\n     * @param {RawVector} newPos\n     */\n    jointSetAnchor2(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor2(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n     * Are contacts between the rigid-bodies attached by this joint enabled?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawimpulsejointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n     * @param {number} handle\n     * @param {boolean} enabled\n     */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawimpulsejointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n     * Are the limits for this joint enabled?\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {boolean}\n     */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n     * Return the lower limit along the given joint axis.\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {number}\n     */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n     * If this is a prismatic joint, returns its upper limit.\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {number}\n     */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n     * Enables and sets the joint limits\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @param {number} min\n     * @param {number} max\n     */\n    jointSetLimits(handle, axis, min, max) {\n        wasm.rawimpulsejointset_jointSetLimits(this.__wbg_ptr, handle, axis, min, max);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @param {RawMotorModel} model\n     */\n    jointConfigureMotorModel(handle, axis, model) {\n        wasm.rawimpulsejointset_jointConfigureMotorModel(this.__wbg_ptr, handle, axis, model);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @param {number} targetVel\n     * @param {number} factor\n     */\n    jointConfigureMotorVelocity(handle, axis, targetVel, factor) {\n        wasm.rawimpulsejointset_jointConfigureMotorVelocity(this.__wbg_ptr, handle, axis, targetVel, factor);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @param {number} targetPos\n     * @param {number} stiffness\n     * @param {number} damping\n     */\n    jointConfigureMotorPosition(handle, axis, targetPos, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotorPosition(this.__wbg_ptr, handle, axis, targetPos, stiffness, damping);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @param {number} targetPos\n     * @param {number} targetVel\n     * @param {number} stiffness\n     * @param {number} damping\n     */\n    jointConfigureMotor(handle, axis, targetPos, targetVel, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotor(this.__wbg_ptr, handle, axis, targetPos, targetVel, stiffness, damping);\n    }\n    constructor() {\n        const ret = wasm.rawimpulsejointset_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawImpulseJointSetFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {RawGenericJoint} params\n     * @param {number} parent1\n     * @param {number} parent2\n     * @param {boolean} wake_up\n     * @returns {number}\n     */\n    createJoint(params, parent1, parent2, wake_up) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawimpulsejointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wake_up);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} wakeUp\n     */\n    remove(handle, wakeUp) {\n        wasm.rawimpulsejointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n        const ret = wasm.rawimpulsejointset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    contains(handle) {\n        const ret = wasm.rawimpulsejointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n     * @param {Function} f\n     */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n     * @param {number} body\n     * @param {Function} f\n     */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawIntegrationParametersFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawintegrationparameters_free(ptr >>> 0, 1));\n\nexport class RawIntegrationParameters {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIntegrationParameters.prototype);\n        obj.__wbg_ptr = ptr;\n        RawIntegrationParametersFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawIntegrationParametersFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawintegrationparameters_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawintegrationparameters_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawIntegrationParametersFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {number}\n     */\n    get dt() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get contact_erp() {\n        const ret = wasm.rawintegrationparameters_contact_erp(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get normalizedAllowedLinearError() {\n        const ret = wasm.rawintegrationparameters_normalizedAllowedLinearError(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get normalizedPredictionDistance() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get numSolverIterations() {\n        const ret = wasm.rawintegrationparameters_numSolverIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get numAdditionalFrictionIterations() {\n        const ret = wasm.rawintegrationparameters_numAdditionalFrictionIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get numInternalPgsIterations() {\n        const ret = wasm.rawintegrationparameters_numInternalPgsIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get minIslandSize() {\n        const ret = wasm.rawimpulsejointset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get maxCcdSubsteps() {\n        const ret = wasm.rawintegrationparameters_maxCcdSubsteps(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get lengthUnit() {\n        const ret = wasm.rawintegrationparameters_lengthUnit(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} value\n     */\n    set dt(value) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set contact_natural_frequency(value) {\n        wasm.rawintegrationparameters_set_contact_natural_frequency(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set normalizedAllowedLinearError(value) {\n        wasm.rawintegrationparameters_set_normalizedAllowedLinearError(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set normalizedPredictionDistance(value) {\n        wasm.rawintegrationparameters_set_normalizedPredictionDistance(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set numSolverIterations(value) {\n        wasm.rawintegrationparameters_set_numSolverIterations(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set numAdditionalFrictionIterations(value) {\n        wasm.rawintegrationparameters_set_numAdditionalFrictionIterations(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set numInternalPgsIterations(value) {\n        wasm.rawintegrationparameters_set_numInternalPgsIterations(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set minIslandSize(value) {\n        wasm.rawintegrationparameters_set_minIslandSize(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set maxCcdSubsteps(value) {\n        wasm.rawintegrationparameters_set_maxCcdSubsteps(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set lengthUnit(value) {\n        wasm.rawintegrationparameters_set_lengthUnit(this.__wbg_ptr, value);\n    }\n    switchToStandardPgsSolver() {\n        wasm.rawintegrationparameters_switchToStandardPgsSolver(this.__wbg_ptr);\n    }\n    switchToSmallStepsPgsSolver() {\n        wasm.rawintegrationparameters_switchToSmallStepsPgsSolver(this.__wbg_ptr);\n    }\n    switchToSmallStepsPgsSolverWithoutWarmstart() {\n        wasm.rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart(this.__wbg_ptr);\n    }\n}\n\nconst RawIslandManagerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawislandmanager_free(ptr >>> 0, 1));\n\nexport class RawIslandManager {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIslandManager.prototype);\n        obj.__wbg_ptr = ptr;\n        RawIslandManagerFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawIslandManagerFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawislandmanager_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawislandmanager_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawIslandManagerFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each active rigid-body\n     * managed by this island manager.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each active rigid-body managed by this\n     *   set. Called as `f(collider)`.\n     * @param {Function} f\n     */\n    forEachActiveRigidBodyHandle(f) {\n        try {\n            wasm.rawislandmanager_forEachActiveRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawKinematicCharacterControllerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawkinematiccharactercontroller_free(ptr >>> 0, 1));\n\nexport class RawKinematicCharacterController {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawKinematicCharacterControllerFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawkinematiccharactercontroller_free(ptr, 0);\n    }\n    /**\n     * @param {number} offset\n     */\n    constructor(offset) {\n        const ret = wasm.rawkinematiccharactercontroller_new(offset);\n        this.__wbg_ptr = ret >>> 0;\n        RawKinematicCharacterControllerFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    up() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} vector\n     */\n    setUp(vector) {\n        _assertClass(vector, RawVector);\n        wasm.rawkinematiccharactercontroller_setUp(this.__wbg_ptr, vector.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    normalNudgeFactor() {\n        const ret = wasm.rawkinematiccharactercontroller_normalNudgeFactor(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} value\n     */\n    setNormalNudgeFactor(value) {\n        wasm.rawkinematiccharactercontroller_setNormalNudgeFactor(this.__wbg_ptr, value);\n    }\n    /**\n     * @returns {number}\n     */\n    offset() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} value\n     */\n    setOffset(value) {\n        wasm.rawkinematiccharactercontroller_setOffset(this.__wbg_ptr, value);\n    }\n    /**\n     * @returns {boolean}\n     */\n    slideEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_slideEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {boolean} enabled\n     */\n    setSlideEnabled(enabled) {\n        wasm.rawkinematiccharactercontroller_setSlideEnabled(this.__wbg_ptr, enabled);\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    autostepMaxHeight() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepMaxHeight(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    autostepMinWidth() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepMinWidth(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @returns {boolean | undefined}\n     */\n    autostepIncludesDynamicBodies() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.__wbg_ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    autostepEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} maxHeight\n     * @param {number} minWidth\n     * @param {boolean} includeDynamicBodies\n     */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        wasm.rawkinematiccharactercontroller_enableAutostep(this.__wbg_ptr, maxHeight, minWidth, includeDynamicBodies);\n    }\n    disableAutostep() {\n        wasm.rawkinematiccharactercontroller_disableAutostep(this.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    maxSlopeClimbAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} angle\n     */\n    setMaxSlopeClimbAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMaxSlopeClimbAngle(this.__wbg_ptr, angle);\n    }\n    /**\n     * @returns {number}\n     */\n    minSlopeSlideAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_minSlopeSlideAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} angle\n     */\n    setMinSlopeSlideAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.__wbg_ptr, angle);\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    snapToGroundDistance() {\n        const ret = wasm.rawkinematiccharactercontroller_snapToGroundDistance(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} distance\n     */\n    enableSnapToGround(distance) {\n        wasm.rawkinematiccharactercontroller_enableSnapToGround(this.__wbg_ptr, distance);\n    }\n    disableSnapToGround() {\n        wasm.rawkinematiccharactercontroller_disableSnapToGround(this.__wbg_ptr);\n    }\n    /**\n     * @returns {boolean}\n     */\n    snapToGroundEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_snapToGroundEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} dt\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawQueryPipeline} queries\n     * @param {number} collider_handle\n     * @param {RawVector} desired_translation_delta\n     * @param {boolean} apply_impulses_to_dynamic_bodies\n     * @param {number | null | undefined} character_mass\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {Function} filter_predicate\n     */\n    computeColliderMovement(dt, bodies, colliders, queries, collider_handle, desired_translation_delta, apply_impulses_to_dynamic_bodies, character_mass, filter_flags, filter_groups, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(queries, RawQueryPipeline);\n            _assertClass(desired_translation_delta, RawVector);\n            wasm.rawkinematiccharactercontroller_computeColliderMovement(this.__wbg_ptr, dt, bodies.__wbg_ptr, colliders.__wbg_ptr, queries.__wbg_ptr, collider_handle, desired_translation_delta.__wbg_ptr, apply_impulses_to_dynamic_bodies, isLikeNone(character_mass) ? 0x100000001 : Math.fround(character_mass), filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {RawVector}\n     */\n    computedMovement() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    computedGrounded() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {number}\n     */\n    numComputedCollisions() {\n        const ret = wasm.rawkinematiccharactercontroller_numComputedCollisions(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @param {RawCharacterCollision} collision\n     * @returns {boolean}\n     */\n    computedCollision(i, collision) {\n        _assertClass(collision, RawCharacterCollision);\n        const ret = wasm.rawkinematiccharactercontroller_computedCollision(this.__wbg_ptr, i, collision.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst RawMultibodyJointSetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawmultibodyjointset_free(ptr >>> 0, 1));\n\nexport class RawMultibodyJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawMultibodyJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawMultibodyJointSetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawMultibodyJointSetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawmultibodyjointset_free(ptr, 0);\n    }\n    /**\n     * The type of this joint.\n     * @param {number} handle\n     * @returns {RawJointType}\n     */\n    jointType(handle) {\n        const ret = wasm.rawmultibodyjointset_jointType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The angular part of the joints local frame relative to the first rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    jointFrameX1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The angular part of the joints local frame relative to the second rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    jointFrameX2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the points application point on the\n     * local frame of the first rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    jointAnchor1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the points application point on the\n     * local frame of the second rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    jointAnchor2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Are contacts between the rigid-bodies attached by this joint enabled?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawmultibodyjointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n     * @param {number} handle\n     * @param {boolean} enabled\n     */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawmultibodyjointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n     * Are the limits for this joint enabled?\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {boolean}\n     */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n     * Return the lower limit along the given joint axis.\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {number}\n     */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n     * If this is a prismatic joint, returns its upper limit.\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {number}\n     */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    constructor() {\n        const ret = wasm.rawmultibodyjointset_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawMultibodyJointSetFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {RawGenericJoint} params\n     * @param {number} parent1\n     * @param {number} parent2\n     * @param {boolean} wakeUp\n     * @returns {number}\n     */\n    createJoint(params, parent1, parent2, wakeUp) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawmultibodyjointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wakeUp);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} wakeUp\n     */\n    remove(handle, wakeUp) {\n        wasm.rawmultibodyjointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    contains(handle) {\n        const ret = wasm.rawmultibodyjointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n     * @param {Function} f\n     */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n     * @param {number} body\n     * @param {Function} f\n     */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawNarrowPhaseFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawnarrowphase_free(ptr >>> 0, 1));\n\nexport class RawNarrowPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawNarrowPhase.prototype);\n        obj.__wbg_ptr = ptr;\n        RawNarrowPhaseFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawNarrowPhaseFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawnarrowphase_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawnarrowphase_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawNarrowPhaseFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {number} handle1\n     * @param {Function} f\n     */\n    contact_pairs_with(handle1, f) {\n        wasm.rawnarrowphase_contact_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n     * @param {number} handle1\n     * @param {number} handle2\n     * @returns {RawContactPair | undefined}\n     */\n    contact_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_contact_pair(this.__wbg_ptr, handle1, handle2);\n        return ret === 0 ? undefined : RawContactPair.__wrap(ret);\n    }\n    /**\n     * @param {number} handle1\n     * @param {Function} f\n     */\n    intersection_pairs_with(handle1, f) {\n        wasm.rawnarrowphase_intersection_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n     * @param {number} handle1\n     * @param {number} handle2\n     * @returns {boolean}\n     */\n    intersection_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_intersection_pair(this.__wbg_ptr, handle1, handle2);\n        return ret !== 0;\n    }\n}\n\nconst RawPhysicsPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawphysicspipeline_free(ptr >>> 0, 1));\n\nexport class RawPhysicsPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPhysicsPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawphysicspipeline_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawphysicspipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawPhysicsPipelineFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {RawVector} gravity\n     * @param {RawIntegrationParameters} integrationParameters\n     * @param {RawIslandManager} islands\n     * @param {RawBroadPhase} broadPhase\n     * @param {RawNarrowPhase} narrowPhase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawImpulseJointSet} joints\n     * @param {RawMultibodyJointSet} articulations\n     * @param {RawCCDSolver} ccd_solver\n     */\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        wasm.rawphysicspipeline_step(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr);\n    }\n    /**\n     * @param {RawVector} gravity\n     * @param {RawIntegrationParameters} integrationParameters\n     * @param {RawIslandManager} islands\n     * @param {RawBroadPhase} broadPhase\n     * @param {RawNarrowPhase} narrowPhase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawImpulseJointSet} joints\n     * @param {RawMultibodyJointSet} articulations\n     * @param {RawCCDSolver} ccd_solver\n     * @param {RawEventQueue} eventQueue\n     * @param {object} hookObject\n     * @param {Function} hookFilterContactPair\n     * @param {Function} hookFilterIntersectionPair\n     */\n    stepWithEvents(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver, eventQueue, hookObject, hookFilterContactPair, hookFilterIntersectionPair) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        _assertClass(eventQueue, RawEventQueue);\n        wasm.rawphysicspipeline_stepWithEvents(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr, eventQueue.__wbg_ptr, addHeapObject(hookObject), addHeapObject(hookFilterContactPair), addHeapObject(hookFilterIntersectionPair));\n    }\n}\n\nconst RawPidControllerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawpidcontroller_free(ptr >>> 0, 1));\n\nexport class RawPidController {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPidControllerFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpidcontroller_free(ptr, 0);\n    }\n    /**\n     * @param {number} kp\n     * @param {number} ki\n     * @param {number} kd\n     * @param {number} axes_mask\n     */\n    constructor(kp, ki, kd, axes_mask) {\n        const ret = wasm.rawpidcontroller_new(kp, ki, kd, axes_mask);\n        this.__wbg_ptr = ret >>> 0;\n        RawPidControllerFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {number} kp\n     * @param {number} axes\n     */\n    set_kp(kp, axes) {\n        wasm.rawpidcontroller_set_kp(this.__wbg_ptr, kp, axes);\n    }\n    /**\n     * @param {number} ki\n     * @param {number} axes\n     */\n    set_ki(ki, axes) {\n        wasm.rawpidcontroller_set_ki(this.__wbg_ptr, ki, axes);\n    }\n    /**\n     * @param {number} kd\n     * @param {number} axes\n     */\n    set_kd(kd, axes) {\n        wasm.rawpidcontroller_set_kd(this.__wbg_ptr, kd, axes);\n    }\n    /**\n     * @param {number} axes_mask\n     */\n    set_axes_mask(axes_mask) {\n        wasm.rawpidcontroller_set_axes_mask(this.__wbg_ptr, axes_mask);\n    }\n    reset_integrals() {\n        wasm.rawpidcontroller_reset_integrals(this.__wbg_ptr);\n    }\n    /**\n     * @param {number} dt\n     * @param {RawRigidBodySet} bodies\n     * @param {number} rb_handle\n     * @param {RawVector} target_translation\n     * @param {RawVector} target_linvel\n     */\n    apply_linear_correction(dt, bodies, rb_handle, target_translation, target_linvel) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(target_translation, RawVector);\n        _assertClass(target_linvel, RawVector);\n        wasm.rawpidcontroller_apply_linear_correction(this.__wbg_ptr, dt, bodies.__wbg_ptr, rb_handle, target_translation.__wbg_ptr, target_linvel.__wbg_ptr);\n    }\n    /**\n     * @param {number} dt\n     * @param {RawRigidBodySet} bodies\n     * @param {number} rb_handle\n     * @param {RawRotation} target_rotation\n     * @param {RawVector} target_angvel\n     */\n    apply_angular_correction(dt, bodies, rb_handle, target_rotation, target_angvel) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(target_rotation, RawRotation);\n        _assertClass(target_angvel, RawVector);\n        wasm.rawpidcontroller_apply_angular_correction(this.__wbg_ptr, dt, bodies.__wbg_ptr, rb_handle, target_rotation.__wbg_ptr, target_angvel.__wbg_ptr);\n    }\n    /**\n     * @param {number} dt\n     * @param {RawRigidBodySet} bodies\n     * @param {number} rb_handle\n     * @param {RawVector} target_translation\n     * @param {RawVector} target_linvel\n     * @returns {RawVector}\n     */\n    linear_correction(dt, bodies, rb_handle, target_translation, target_linvel) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(target_translation, RawVector);\n        _assertClass(target_linvel, RawVector);\n        const ret = wasm.rawpidcontroller_linear_correction(this.__wbg_ptr, dt, bodies.__wbg_ptr, rb_handle, target_translation.__wbg_ptr, target_linvel.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} dt\n     * @param {RawRigidBodySet} bodies\n     * @param {number} rb_handle\n     * @param {RawRotation} target_rotation\n     * @param {RawVector} target_angvel\n     * @returns {RawVector}\n     */\n    angular_correction(dt, bodies, rb_handle, target_rotation, target_angvel) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(target_rotation, RawRotation);\n        _assertClass(target_angvel, RawVector);\n        const ret = wasm.rawpidcontroller_angular_correction(this.__wbg_ptr, dt, bodies.__wbg_ptr, rb_handle, target_rotation.__wbg_ptr, target_angvel.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawPointColliderProjectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawpointcolliderprojection_free(ptr >>> 0, 1));\n\nexport class RawPointColliderProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointColliderProjection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawPointColliderProjectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPointColliderProjectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointcolliderprojection_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    point() {\n        const ret = wasm.rawpointcolliderprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isInside() {\n        const ret = wasm.rawpointcolliderprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {RawFeatureType}\n     */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    featureId() {\n        const ret = wasm.rawpointcolliderprojection_featureId(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n}\n\nconst RawPointProjectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawpointprojection_free(ptr >>> 0, 1));\n\nexport class RawPointProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointProjection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawPointProjectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPointProjectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointprojection_free(ptr, 0);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    point() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isInside() {\n        const ret = wasm.rawpointprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst RawQueryPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawquerypipeline_free(ptr >>> 0, 1));\n\nexport class RawQueryPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawQueryPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawquerypipeline_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawquerypipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawQueryPipelineFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {RawColliderSet} colliders\n     */\n    update(colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawquerypipeline_update(this.__wbg_ptr, colliders.__wbg_ptr);\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {RawRayColliderHit | undefined}\n     */\n    castRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderHit.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {RawRayColliderIntersection | undefined}\n     */\n    castRayAndGetNormal(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRayAndGetNormal(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderIntersection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @param {Function} callback\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     */\n    intersectionsWithRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            wasm.rawquerypipeline_intersectionsWithRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, addBorrowedObject(callback), filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawShape} shape\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {number | undefined}\n     */\n    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionWithShape(retptr, this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r2 = getDataViewMemory0().getFloat64(retptr + 8 * 1, true);\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} point\n     * @param {boolean} solid\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {RawPointColliderProjection | undefined}\n     */\n    projectPoint(bodies, colliders, point, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, solid, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} point\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {RawPointColliderProjection | undefined}\n     */\n    projectPointAndGetFeature(bodies, colliders, point, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPointAndGetFeature(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} point\n     * @param {Function} callback\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     */\n    intersectionsWithPoint(bodies, colliders, point, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            wasm.rawquerypipeline_intersectionsWithPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, addBorrowedObject(callback), filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} shapeVel\n     * @param {RawShape} shape\n     * @param {number} target_distance\n     * @param {number} maxToi\n     * @param {boolean} stop_at_penetration\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {RawColliderShapeCastHit | undefined}\n     */\n    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, target_distance, maxToi, stop_at_penetration, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shapeVel, RawVector);\n            _assertClass(shape, RawShape);\n            const ret = wasm.rawquerypipeline_castShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shapeVel.__wbg_ptr, shape.__wbg_ptr, target_distance, maxToi, stop_at_penetration, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawColliderShapeCastHit.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawShape} shape\n     * @param {Function} callback\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     */\n    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionsWithShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, addBorrowedObject(callback), filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawVector} aabbCenter\n     * @param {RawVector} aabbHalfExtents\n     * @param {Function} callback\n     */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        try {\n            _assertClass(aabbCenter, RawVector);\n            _assertClass(aabbHalfExtents, RawVector);\n            wasm.rawquerypipeline_collidersWithAabbIntersectingAabb(this.__wbg_ptr, aabbCenter.__wbg_ptr, aabbHalfExtents.__wbg_ptr, addBorrowedObject(callback));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawRayColliderHitFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawraycolliderhit_free(ptr >>> 0, 1));\n\nexport class RawRayColliderHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderHit.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRayColliderHitFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRayColliderHitFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderhit_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    colliderHandle() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timeOfImpact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RawRayColliderIntersectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawraycolliderintersection_free(ptr >>> 0, 1));\n\nexport class RawRayColliderIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRayColliderIntersectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRayColliderIntersectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderintersection_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawFeatureType}\n     */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    featureId() {\n        const ret = wasm.rawpointcolliderprojection_featureId(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n}\n\nconst RawRayIntersectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawrayintersection_free(ptr >>> 0, 1));\n\nexport class RawRayIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRayIntersectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRayIntersectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrayintersection_free(ptr, 0);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawFeatureType}\n     */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    featureId() {\n        const ret = wasm.rawpointcolliderprojection_featureId(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n}\n\nconst RawRigidBodySetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawrigidbodyset_free(ptr >>> 0, 1));\n\nexport class RawRigidBodySet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRigidBodySet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRigidBodySetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRigidBodySetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrigidbodyset_free(ptr, 0);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    rbRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * Put the given rigid-body to sleep.\n     * @param {number} handle\n     */\n    rbSleep(handle) {\n        wasm.rawrigidbodyset_rbSleep(this.__wbg_ptr, handle);\n    }\n    /**\n     * Is this rigid-body sleeping?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsSleeping(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsSleeping(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Is the velocity of this rigid-body not zero?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsMoving(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsMoving(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * The world-space predicted translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbNextTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The world-space predicted orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    rbNextRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * # Parameters\n     * - `x`: the world-space position of the rigid-body along the `x` axis.\n     * - `y`: the world-space position of the rigid-body along the `y` axis.\n     * - `z`: the world-space position of the rigid-body along the `z` axis.\n     * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     * @param {number} handle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} z\n     * @param {boolean} wakeUp\n     */\n    rbSetTranslation(handle, x, y, z, wakeUp) {\n        wasm.rawrigidbodyset_rbSetTranslation(this.__wbg_ptr, handle, x, y, z, wakeUp);\n    }\n    /**\n     * Sets the rotation quaternion of this rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * # Parameters\n     * - `x`: the first vector component of the quaternion.\n     * - `y`: the second vector component of the quaternion.\n     * - `z`: the third vector component of the quaternion.\n     * - `w`: the scalar component of the quaternion.\n     * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     * @param {number} handle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} z\n     * @param {number} w\n     * @param {boolean} wakeUp\n     */\n    rbSetRotation(handle, x, y, z, w, wakeUp) {\n        wasm.rawrigidbodyset_rbSetRotation(this.__wbg_ptr, handle, x, y, z, w, wakeUp);\n    }\n    /**\n     * Sets the linear velocity of this rigid-body.\n     * @param {number} handle\n     * @param {RawVector} linvel\n     * @param {boolean} wakeUp\n     */\n    rbSetLinvel(handle, linvel, wakeUp) {\n        _assertClass(linvel, RawVector);\n        wasm.rawrigidbodyset_rbSetLinvel(this.__wbg_ptr, handle, linvel.__wbg_ptr, wakeUp);\n    }\n    /**\n     * Sets the angular velocity of this rigid-body.\n     * @param {number} handle\n     * @param {RawVector} angvel\n     * @param {boolean} wakeUp\n     */\n    rbSetAngvel(handle, angvel, wakeUp) {\n        _assertClass(angvel, RawVector);\n        wasm.rawrigidbodyset_rbSetAngvel(this.__wbg_ptr, handle, angvel.__wbg_ptr, wakeUp);\n    }\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * # Parameters\n     * - `x`: the world-space position of the rigid-body along the `x` axis.\n     * - `y`: the world-space position of the rigid-body along the `y` axis.\n     * - `z`: the world-space position of the rigid-body along the `z` axis.\n     * @param {number} handle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} z\n     */\n    rbSetNextKinematicTranslation(handle, x, y, z) {\n        wasm.rawrigidbodyset_rbSetNextKinematicTranslation(this.__wbg_ptr, handle, x, y, z);\n    }\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * # Parameters\n     * - `x`: the first vector component of the quaternion.\n     * - `y`: the second vector component of the quaternion.\n     * - `z`: the third vector component of the quaternion.\n     * - `w`: the scalar component of the quaternion.\n     * @param {number} handle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} z\n     * @param {number} w\n     */\n    rbSetNextKinematicRotation(handle, x, y, z, w) {\n        wasm.rawrigidbodyset_rbSetNextKinematicRotation(this.__wbg_ptr, handle, x, y, z, w);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawColliderSet} colliders\n     */\n    rbRecomputeMassPropertiesFromColliders(handle, colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.__wbg_ptr, handle, colliders.__wbg_ptr);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} mass\n     * @param {boolean} wake_up\n     */\n    rbSetAdditionalMass(handle, mass, wake_up) {\n        wasm.rawrigidbodyset_rbSetAdditionalMass(this.__wbg_ptr, handle, mass, wake_up);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} mass\n     * @param {RawVector} centerOfMass\n     * @param {RawVector} principalAngularInertia\n     * @param {RawRotation} angularInertiaFrame\n     * @param {boolean} wake_up\n     */\n    rbSetAdditionalMassProperties(handle, mass, centerOfMass, principalAngularInertia, angularInertiaFrame, wake_up) {\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        wasm.rawrigidbodyset_rbSetAdditionalMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia.__wbg_ptr, angularInertiaFrame.__wbg_ptr, wake_up);\n    }\n    /**\n     * The linear velocity of this rigid-body.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbLinvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinvel(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The angular velocity of this rigid-body.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbAngvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngvel(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} locked\n     * @param {boolean} wake_up\n     */\n    rbLockTranslations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockTranslations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} allow_x\n     * @param {boolean} allow_y\n     * @param {boolean} allow_z\n     * @param {boolean} wake_up\n     */\n    rbSetEnabledTranslations(handle, allow_x, allow_y, allow_z, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledTranslations(this.__wbg_ptr, handle, allow_x, allow_y, allow_z, wake_up);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} locked\n     * @param {boolean} wake_up\n     */\n    rbLockRotations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockRotations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} allow_x\n     * @param {boolean} allow_y\n     * @param {boolean} allow_z\n     * @param {boolean} wake_up\n     */\n    rbSetEnabledRotations(handle, allow_x, allow_y, allow_z, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledRotations(this.__wbg_ptr, handle, allow_x, allow_y, allow_z, wake_up);\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbDominanceGroup(handle) {\n        const ret = wasm.rawrigidbodyset_rbDominanceGroup(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} group\n     */\n    rbSetDominanceGroup(handle, group) {\n        wasm.rawrigidbodyset_rbSetDominanceGroup(this.__wbg_ptr, handle, group);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} enabled\n     */\n    rbEnableCcd(handle, enabled) {\n        wasm.rawrigidbodyset_rbEnableCcd(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} prediction\n     */\n    rbSetSoftCcdPrediction(handle, prediction) {\n        wasm.rawrigidbodyset_rbSetSoftCcdPrediction(this.__wbg_ptr, handle, prediction);\n    }\n    /**\n     * The mass of this rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The inverse of the mass of a rigid-body.\n     *\n     * If this is zero, the rigid-body is assumed to have infinite mass.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The inverse mass taking into account translation locking.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbEffectiveInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveInvMass(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The center of mass of a rigid-body expressed in its local-space.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbLocalCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbLocalCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The world-space center of mass of the rigid-body.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbWorldCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbWorldCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The inverse of the principal angular inertia of the rigid-body.\n     *\n     * Components set to zero are assumed to be infinite along the corresponding principal axis.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbInvPrincipalInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvPrincipalInertiaSqrt(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The principal vectors of the local angular inertia tensor of the rigid-body.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    rbPrincipalInertiaLocalFrame(handle) {\n        const ret = wasm.rawrigidbodyset_rbPrincipalInertiaLocalFrame(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The angular inertia along the principal inertia axes of the rigid-body.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbPrincipalInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbPrincipalInertia(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n     * taking into account rotation locking.\n     * @param {number} handle\n     * @returns {RawSdpMatrix3}\n     */\n    rbEffectiveWorldInvInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt(this.__wbg_ptr, handle);\n        return RawSdpMatrix3.__wrap(ret);\n    }\n    /**\n     * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n     * this rigid-body.\n     * @param {number} handle\n     * @returns {RawSdpMatrix3}\n     */\n    rbEffectiveAngularInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveAngularInertia(this.__wbg_ptr, handle);\n        return RawSdpMatrix3.__wrap(ret);\n    }\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This method forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     * @param {number} handle\n     */\n    rbWakeUp(handle) {\n        wasm.rawrigidbodyset_rbWakeUp(this.__wbg_ptr, handle);\n    }\n    /**\n     * Is Continuous Collision Detection enabled for this rigid-body?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsCcdEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsCcdEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbSoftCcdPrediction(handle) {\n        const ret = wasm.rawrigidbodyset_rbSoftCcdPrediction(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The number of colliders attached to this rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbNumColliders(handle) {\n        const ret = wasm.rawrigidbodyset_rbNumColliders(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * Retrieves the `i-th` collider attached to this rigid-body.\n     *\n     * # Parameters\n     * - `at`: The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     * @param {number} handle\n     * @param {number} at\n     * @returns {number}\n     */\n    rbCollider(handle, at) {\n        const ret = wasm.rawrigidbodyset_rbCollider(this.__wbg_ptr, handle, at);\n        return ret;\n    }\n    /**\n     * The status of this rigid-body: fixed, dynamic, or kinematic.\n     * @param {number} handle\n     * @returns {RawRigidBodyType}\n     */\n    rbBodyType(handle) {\n        const ret = wasm.rawrigidbodyset_rbBodyType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * Set a new status for this rigid-body: fixed, dynamic, or kinematic.\n     * @param {number} handle\n     * @param {RawRigidBodyType} status\n     * @param {boolean} wake_up\n     */\n    rbSetBodyType(handle, status, wake_up) {\n        wasm.rawrigidbodyset_rbSetBodyType(this.__wbg_ptr, handle, status, wake_up);\n    }\n    /**\n     * Is this rigid-body fixed?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsFixed(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsFixed(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Is this rigid-body kinematic?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsKinematic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsKinematic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Is this rigid-body dynamic?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsDynamic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsDynamic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * The linear damping coefficient of this rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbLinearDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinearDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The angular damping coefficient of this rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbAngularDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngularDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} factor\n     */\n    rbSetLinearDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetLinearDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} factor\n     */\n    rbSetAngularDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetAngularDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} enabled\n     */\n    rbSetEnabled(handle, enabled) {\n        wasm.rawrigidbodyset_rbSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbGravityScale(handle) {\n        const ret = wasm.rawrigidbodyset_rbGravityScale(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} factor\n     * @param {boolean} wakeUp\n     */\n    rbSetGravityScale(handle, factor, wakeUp) {\n        wasm.rawrigidbodyset_rbSetGravityScale(this.__wbg_ptr, handle, factor, wakeUp);\n    }\n    /**\n     * Resets to zero all user-added forces added to this rigid-body.\n     * @param {number} handle\n     * @param {boolean} wakeUp\n     */\n    rbResetForces(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetForces(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n     * Resets to zero all user-added torques added to this rigid-body.\n     * @param {number} handle\n     * @param {boolean} wakeUp\n     */\n    rbResetTorques(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetTorques(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n     * Adds a force at the center-of-mass of this rigid-body.\n     *\n     * # Parameters\n     * - `force`: the world-space force to apply on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {RawVector} force\n     * @param {boolean} wakeUp\n     */\n    rbAddForce(handle, force, wakeUp) {\n        _assertClass(force, RawVector);\n        wasm.rawrigidbodyset_rbAddForce(this.__wbg_ptr, handle, force.__wbg_ptr, wakeUp);\n    }\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * # Parameters\n     * - `impulse`: the world-space impulse to apply on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {RawVector} impulse\n     * @param {boolean} wakeUp\n     */\n    rbApplyImpulse(handle, impulse, wakeUp) {\n        _assertClass(impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulse(this.__wbg_ptr, handle, impulse.__wbg_ptr, wakeUp);\n    }\n    /**\n     * Adds a torque at the center-of-mass of this rigid-body.\n     *\n     * # Parameters\n     * - `torque`: the world-space torque to apply on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {RawVector} torque\n     * @param {boolean} wakeUp\n     */\n    rbAddTorque(handle, torque, wakeUp) {\n        _assertClass(torque, RawVector);\n        wasm.rawrigidbodyset_rbAddTorque(this.__wbg_ptr, handle, torque.__wbg_ptr, wakeUp);\n    }\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * # Parameters\n     * - `torque impulse`: the world-space torque impulse to apply on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {RawVector} torque_impulse\n     * @param {boolean} wakeUp\n     */\n    rbApplyTorqueImpulse(handle, torque_impulse, wakeUp) {\n        _assertClass(torque_impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyTorqueImpulse(this.__wbg_ptr, handle, torque_impulse.__wbg_ptr, wakeUp);\n    }\n    /**\n     * Adds a force at the given world-space point of this rigid-body.\n     *\n     * # Parameters\n     * - `force`: the world-space force to apply on the rigid-body.\n     * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {RawVector} force\n     * @param {RawVector} point\n     * @param {boolean} wakeUp\n     */\n    rbAddForceAtPoint(handle, force, point, wakeUp) {\n        _assertClass(force, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbAddForceAtPoint(this.__wbg_ptr, handle, force.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * # Parameters\n     * - `impulse`: the world-space impulse to apply on the rigid-body.\n     * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {RawVector} impulse\n     * @param {RawVector} point\n     * @param {boolean} wakeUp\n     */\n    rbApplyImpulseAtPoint(handle, impulse, point, wakeUp) {\n        _assertClass(impulse, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulseAtPoint(this.__wbg_ptr, handle, impulse.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbAdditionalSolverIterations(handle) {\n        const ret = wasm.rawrigidbodyset_rbAdditionalSolverIterations(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} iters\n     */\n    rbSetAdditionalSolverIterations(handle, iters) {\n        wasm.rawrigidbodyset_rbSetAdditionalSolverIterations(this.__wbg_ptr, handle, iters);\n    }\n    /**\n     * An arbitrary user-defined 32-bit integer\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbUserData(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserData(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * Sets the user-defined 32-bit integer of this rigid-body.\n     *\n     * # Parameters\n     * - `data`: an arbitrary user-defined 32-bit integer.\n     * @param {number} handle\n     * @param {number} data\n     */\n    rbSetUserData(handle, data) {\n        wasm.rawrigidbodyset_rbSetUserData(this.__wbg_ptr, handle, data);\n    }\n    /**\n     * Retrieves the constant force(s) the user added to this rigid-body.\n     * Returns zero if the rigid-body is not dynamic.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbUserForce(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserForce(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Retrieves the constant torque(s) the user added to this rigid-body.\n     * Returns zero if the rigid-body is not dynamic.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbUserTorque(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserTorque(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    constructor() {\n        const ret = wasm.rawrigidbodyset_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawRigidBodySetFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {boolean} enabled\n     * @param {RawVector} translation\n     * @param {RawRotation} rotation\n     * @param {number} gravityScale\n     * @param {number} mass\n     * @param {boolean} massOnly\n     * @param {RawVector} centerOfMass\n     * @param {RawVector} linvel\n     * @param {RawVector} angvel\n     * @param {RawVector} principalAngularInertia\n     * @param {RawRotation} angularInertiaFrame\n     * @param {boolean} translationEnabledX\n     * @param {boolean} translationEnabledY\n     * @param {boolean} translationEnabledZ\n     * @param {boolean} rotationEnabledX\n     * @param {boolean} rotationEnabledY\n     * @param {boolean} rotationEnabledZ\n     * @param {number} linearDamping\n     * @param {number} angularDamping\n     * @param {RawRigidBodyType} rb_type\n     * @param {boolean} canSleep\n     * @param {boolean} sleeping\n     * @param {number} softCcdPrediction\n     * @param {boolean} ccdEnabled\n     * @param {number} dominanceGroup\n     * @param {number} additional_solver_iterations\n     * @returns {number}\n     */\n    createRigidBody(enabled, translation, rotation, gravityScale, mass, massOnly, centerOfMass, linvel, angvel, principalAngularInertia, angularInertiaFrame, translationEnabledX, translationEnabledY, translationEnabledZ, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, sleeping, softCcdPrediction, ccdEnabled, dominanceGroup, additional_solver_iterations) {\n        _assertClass(translation, RawVector);\n        _assertClass(rotation, RawRotation);\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(linvel, RawVector);\n        _assertClass(angvel, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        const ret = wasm.rawrigidbodyset_createRigidBody(this.__wbg_ptr, enabled, translation.__wbg_ptr, rotation.__wbg_ptr, gravityScale, mass, massOnly, centerOfMass.__wbg_ptr, linvel.__wbg_ptr, angvel.__wbg_ptr, principalAngularInertia.__wbg_ptr, angularInertiaFrame.__wbg_ptr, translationEnabledX, translationEnabledY, translationEnabledZ, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, sleeping, softCcdPrediction, ccdEnabled, dominanceGroup, additional_solver_iterations);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawIslandManager} islands\n     * @param {RawColliderSet} colliders\n     * @param {RawImpulseJointSet} joints\n     * @param {RawMultibodyJointSet} articulations\n     */\n    remove(handle, islands, colliders, joints, articulations) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        wasm.rawrigidbodyset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr);\n    }\n    /**\n     * The number of rigid-bodies on this set.\n     * @returns {number}\n     */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Checks if a rigid-body with the given integer handle exists.\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    contains(handle) {\n        const ret = wasm.rawrigidbodyset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each rigid-body managed by this set.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each rigid-body managed by this set. Called as `f(collider)`.\n     * @param {Function} f\n     */\n    forEachRigidBodyHandle(f) {\n        try {\n            wasm.rawrigidbodyset_forEachRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawColliderSet} colliders\n     */\n    propagateModifiedBodyPositionsToColliders(colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.__wbg_ptr, colliders.__wbg_ptr);\n    }\n}\n\nconst RawRotationFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawrotation_free(ptr >>> 0, 1));\n/**\n * A rotation quaternion.\n */\nexport class RawRotation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRotation.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRotationFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRotationFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrotation_free(ptr, 0);\n    }\n    /**\n     * @param {number} x\n     * @param {number} y\n     * @param {number} z\n     * @param {number} w\n     */\n    constructor(x, y, z, w) {\n        const ret = wasm.rawrotation_new(x, y, z, w);\n        this.__wbg_ptr = ret >>> 0;\n        RawRotationFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * The identity quaternion.\n     * @returns {RawRotation}\n     */\n    static identity() {\n        const ret = wasm.rawrotation_identity();\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The `x` component of this quaternion.\n     * @returns {number}\n     */\n    get x() {\n        const ret = wasm.rawrotation_x(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The `y` component of this quaternion.\n     * @returns {number}\n     */\n    get y() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The `z` component of this quaternion.\n     * @returns {number}\n     */\n    get z() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The `w` component of this quaternion.\n     * @returns {number}\n     */\n    get w() {\n        const ret = wasm.rawrotation_w(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RawSdpMatrix3Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawsdpmatrix3_free(ptr >>> 0, 1));\n\nexport class RawSdpMatrix3 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawSdpMatrix3.prototype);\n        obj.__wbg_ptr = ptr;\n        RawSdpMatrix3Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawSdpMatrix3Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawsdpmatrix3_free(ptr, 0);\n    }\n    /**\n     * Row major list of the upper-triangular part of the symmetric matrix.\n     * @returns {Float32Array}\n     */\n    elements() {\n        const ret = wasm.rawsdpmatrix3_elements(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\n\nconst RawSerializationPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawserializationpipeline_free(ptr >>> 0, 1));\n\nexport class RawSerializationPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawSerializationPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawserializationpipeline_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawserializationpipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawSerializationPipelineFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {RawVector} gravity\n     * @param {RawIntegrationParameters} integrationParameters\n     * @param {RawIslandManager} islands\n     * @param {RawBroadPhase} broadPhase\n     * @param {RawNarrowPhase} narrowPhase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawImpulseJointSet} impulse_joints\n     * @param {RawMultibodyJointSet} multibody_joints\n     * @returns {Uint8Array | undefined}\n     */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulse_joints, multibody_joints) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        const ret = wasm.rawserializationpipeline_serializeAll(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} data\n     * @returns {RawDeserializedWorld | undefined}\n     */\n    deserializeAll(data) {\n        const ret = wasm.rawserializationpipeline_deserializeAll(this.__wbg_ptr, addHeapObject(data));\n        return ret === 0 ? undefined : RawDeserializedWorld.__wrap(ret);\n    }\n}\n\nconst RawShapeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawshape_free(ptr >>> 0, 1));\n\nexport class RawShape {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShape.prototype);\n        obj.__wbg_ptr = ptr;\n        RawShapeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawShapeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshape_free(ptr, 0);\n    }\n    /**\n     * @param {number} hx\n     * @param {number} hy\n     * @param {number} hz\n     * @returns {RawShape}\n     */\n    static cuboid(hx, hy, hz) {\n        const ret = wasm.rawshape_cuboid(hx, hy, hz);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {number} hx\n     * @param {number} hy\n     * @param {number} hz\n     * @param {number} borderRadius\n     * @returns {RawShape}\n     */\n    static roundCuboid(hx, hy, hz, borderRadius) {\n        const ret = wasm.rawshape_roundCuboid(hx, hy, hz, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {number} radius\n     * @returns {RawShape}\n     */\n    static ball(radius) {\n        const ret = wasm.rawshape_ball(radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} normal\n     * @returns {RawShape}\n     */\n    static halfspace(normal) {\n        _assertClass(normal, RawVector);\n        const ret = wasm.rawshape_halfspace(normal.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {number} halfHeight\n     * @param {number} radius\n     * @returns {RawShape}\n     */\n    static capsule(halfHeight, radius) {\n        const ret = wasm.rawshape_capsule(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {number} halfHeight\n     * @param {number} radius\n     * @returns {RawShape}\n     */\n    static cylinder(halfHeight, radius) {\n        const ret = wasm.rawshape_cylinder(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {number} halfHeight\n     * @param {number} radius\n     * @param {number} borderRadius\n     * @returns {RawShape}\n     */\n    static roundCylinder(halfHeight, radius, borderRadius) {\n        const ret = wasm.rawshape_roundCylinder(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {number} halfHeight\n     * @param {number} radius\n     * @returns {RawShape}\n     */\n    static cone(halfHeight, radius) {\n        const ret = wasm.rawshape_cone(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {number} halfHeight\n     * @param {number} radius\n     * @param {number} borderRadius\n     * @returns {RawShape}\n     */\n    static roundCone(halfHeight, radius, borderRadius) {\n        const ret = wasm.rawshape_roundCone(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} vertices\n     * @param {Uint32Array} indices\n     * @returns {RawShape}\n     */\n    static polyline(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_export_2);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_polyline(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} vertices\n     * @param {Uint32Array} indices\n     * @param {number} flags\n     * @returns {RawShape | undefined}\n     */\n    static trimesh(vertices, indices, flags) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_export_2);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_trimesh(ptr0, len0, ptr1, len1, flags);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n     * @param {number} nrows\n     * @param {number} ncols\n     * @param {Float32Array} heights\n     * @param {RawVector} scale\n     * @param {number} flags\n     * @returns {RawShape}\n     */\n    static heightfield(nrows, ncols, heights, scale, flags) {\n        const ptr0 = passArrayF32ToWasm0(heights, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(scale, RawVector);\n        const ret = wasm.rawshape_heightfield(nrows, ncols, ptr0, len0, scale.__wbg_ptr, flags);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} p1\n     * @param {RawVector} p2\n     * @returns {RawShape}\n     */\n    static segment(p1, p2) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        const ret = wasm.rawshape_segment(p1.__wbg_ptr, p2.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} p1\n     * @param {RawVector} p2\n     * @param {RawVector} p3\n     * @returns {RawShape}\n     */\n    static triangle(p1, p2, p3) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_triangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} p1\n     * @param {RawVector} p2\n     * @param {RawVector} p3\n     * @param {number} borderRadius\n     * @returns {RawShape}\n     */\n    static roundTriangle(p1, p2, p3, borderRadius) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_roundTriangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} points\n     * @returns {RawShape | undefined}\n     */\n    static convexHull(points) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexHull(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} points\n     * @param {number} borderRadius\n     * @returns {RawShape | undefined}\n     */\n    static roundConvexHull(points, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexHull(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} vertices\n     * @param {Uint32Array} indices\n     * @returns {RawShape | undefined}\n     */\n    static convexMesh(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_export_2);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexMesh(ptr0, len0, ptr1, len1);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} vertices\n     * @param {Uint32Array} indices\n     * @param {number} borderRadius\n     * @returns {RawShape | undefined}\n     */\n    static roundConvexMesh(vertices, indices, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_export_2);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexMesh(ptr0, len0, ptr1, len1, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} shapePos1\n     * @param {RawRotation} shapeRot1\n     * @param {RawVector} shapeVel1\n     * @param {RawShape} shape2\n     * @param {RawVector} shapePos2\n     * @param {RawRotation} shapeRot2\n     * @param {RawVector} shapeVel2\n     * @param {number} target_distance\n     * @param {number} maxToi\n     * @param {boolean} stop_at_penetration\n     * @returns {RawShapeCastHit | undefined}\n     */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, target_distance, maxToi, stop_at_penetration) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shapeVel1, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        _assertClass(shapeVel2, RawVector);\n        const ret = wasm.rawshape_castShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shapeVel1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, shapeVel2.__wbg_ptr, target_distance, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeCastHit.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} shapePos1\n     * @param {RawRotation} shapeRot1\n     * @param {RawShape} shape2\n     * @param {RawVector} shapePos2\n     * @param {RawRotation} shapeRot2\n     * @returns {boolean}\n     */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_intersectsShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {RawVector} shapePos1\n     * @param {RawRotation} shapeRot1\n     * @param {RawShape} shape2\n     * @param {RawVector} shapePos2\n     * @param {RawRotation} shapeRot2\n     * @param {number} prediction\n     * @returns {RawShapeContact | undefined}\n     */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_contactShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} point\n     * @returns {boolean}\n     */\n    containsPoint(shapePos, shapeRot, point) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_containsPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} point\n     * @param {boolean} solid\n     * @returns {RawPointProjection}\n     */\n    projectPoint(shapePos, shapeRot, point, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_projectPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @returns {boolean}\n     */\n    intersectsRay(shapePos, shapeRot, rayOrig, rayDir, maxToi) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_intersectsRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @returns {number}\n     */\n    castRay(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @returns {RawRayIntersection | undefined}\n     */\n    castRayAndGetNormal(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRayAndGetNormal(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n}\n\nconst RawShapeCastHitFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawshapecasthit_free(ptr >>> 0, 1));\n\nexport class RawShapeCastHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeCastHit.prototype);\n        obj.__wbg_ptr = ptr;\n        RawShapeCastHitFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawShapeCastHitFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecasthit_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    time_of_impact() {\n        const ret = wasm.rawrotation_x(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    witness1() {\n        const ret = wasm.rawshapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    witness2() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal1() {\n        const ret = wasm.rawshapecasthit_normal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal2() {\n        const ret = wasm.rawshapecasthit_normal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawShapeContactFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawshapecontact_free(ptr >>> 0, 1));\n\nexport class RawShapeContact {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeContact.prototype);\n        obj.__wbg_ptr = ptr;\n        RawShapeContactFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawShapeContactFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecontact_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    distance() {\n        const ret = wasm.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    point1() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    point2() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal1() {\n        const ret = wasm.rawcollidershapecasthit_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal2() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawVectorFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawvector_free(ptr >>> 0, 1));\n/**\n * A vector.\n */\nexport class RawVector {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawVector.prototype);\n        obj.__wbg_ptr = ptr;\n        RawVectorFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawVectorFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawvector_free(ptr, 0);\n    }\n    /**\n     * Creates a new vector filled with zeros.\n     * @returns {RawVector}\n     */\n    static zero() {\n        const ret = wasm.rawvector_zero();\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Creates a new 3D vector from its two components.\n     *\n     * # Parameters\n     * - `x`: the `x` component of this 3D vector.\n     * - `y`: the `y` component of this 3D vector.\n     * - `z`: the `z` component of this 3D vector.\n     * @param {number} x\n     * @param {number} y\n     * @param {number} z\n     */\n    constructor(x, y, z) {\n        const ret = wasm.rawvector_new(x, y, z);\n        this.__wbg_ptr = ret >>> 0;\n        RawVectorFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * The `x` component of this vector.\n     * @returns {number}\n     */\n    get x() {\n        const ret = wasm.rawrotation_x(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Sets the `x` component of this vector.\n     * @param {number} x\n     */\n    set x(x) {\n        wasm.rawvector_set_x(this.__wbg_ptr, x);\n    }\n    /**\n     * The `y` component of this vector.\n     * @returns {number}\n     */\n    get y() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Sets the `y` component of this vector.\n     * @param {number} y\n     */\n    set y(y) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, y);\n    }\n    /**\n     * The `z` component of this vector.\n     * @returns {number}\n     */\n    get z() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Sets the `z` component of this vector.\n     * @param {number} z\n     */\n    set z(z) {\n        wasm.rawvector_set_z(this.__wbg_ptr, z);\n    }\n    /**\n     * Create a new 3D vector from this vector with its components rearranged as `{x, y, z}`.\n     *\n     * This will effectively return a copy of `this`. This method exist for completeness with the\n     * other swizzling functions.\n     * @returns {RawVector}\n     */\n    xyz() {\n        const ret = wasm.rawvector_xyz(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Create a new 3D vector from this vector with its components rearranged as `{y, x, z}`.\n     * @returns {RawVector}\n     */\n    yxz() {\n        const ret = wasm.rawvector_yxz(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Create a new 3D vector from this vector with its components rearranged as `{z, x, y}`.\n     * @returns {RawVector}\n     */\n    zxy() {\n        const ret = wasm.rawvector_zxy(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Create a new 3D vector from this vector with its components rearranged as `{x, z, y}`.\n     * @returns {RawVector}\n     */\n    xzy() {\n        const ret = wasm.rawvector_xzy(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Create a new 3D vector from this vector with its components rearranged as `{y, z, x}`.\n     * @returns {RawVector}\n     */\n    yzx() {\n        const ret = wasm.rawvector_yzx(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Create a new 3D vector from this vector with its components rearranged as `{z, y, x}`.\n     * @returns {RawVector}\n     */\n    zyx() {\n        const ret = wasm.rawvector_zyx(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nexport function __wbg_bind_c8359b1cba058168(arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).bind(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_buffer_609cc3eee51ed158(arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_7cccdd69e0791ae2() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_833bed5770ea2041() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_b8adc8b1d0a0d8eb() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3), getObject(arg4));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_length_3b4f022188ae8db6(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_length_a446193dc22c12f8(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_new_a12002a7f91c75be(arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newwithbyteoffsetandlength_d97e637ebe145a9a(arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354(arg0, arg1, arg2) {\n    const ret = new Float32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newwithlength_5a5efe313cfd59f1(arg0) {\n    const ret = new Float32Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_rawcontactforceevent_new(arg0) {\n    const ret = RawContactForceEvent.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_rawraycolliderintersection_new(arg0) {\n    const ret = RawRayColliderIntersection.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_10bad9bee0e9c58b(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_set_65595bdd868b3009(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbindgen_boolean_get(arg0) {\n    const v = getObject(arg0);\n    const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n    return ret;\n};\n\nexport function __wbindgen_is_function(arg0) {\n    const ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nexport function __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_number_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof(obj) === 'number' ? obj : undefined;\n    getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n};\n\nexport function __wbindgen_number_new(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n", "import {RawVector, RawRotation} from \"./raw\";\n// #if DIM3\nimport {RawSdpMatrix3} from \"./raw\";\n// #endif\n\n\n// #if DIM3\nexport interface Vector {\n    x: number;\n    y: number;\n    z: number;\n}\n\n/**\n * A 3D vector.\n */\nexport class Vector3 implements Vector {\n    x: number;\n    y: number;\n    z: number;\n\n    constructor(x: number, y: number, z: number) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n}\n\nexport class VectorOps {\n    public static new(x: number, y: number, z: number): Vector {\n        return new Vector3(x, y, z);\n    }\n\n    public static intoRaw(v: Vector): RawVector {\n        return new RawVector(v.x, v.y, v.z);\n    }\n\n    public static zeros(): Vector {\n        return VectorOps.new(0.0, 0.0, 0.0);\n    }\n\n    // FIXME: type ram: RawVector?\n    public static fromRaw(raw: RawVector): Vector {\n        if (!raw) return null;\n\n        let res = VectorOps.new(raw.x, raw.y, raw.z);\n        raw.free();\n        return res;\n    }\n\n    public static copy(out: Vector, input: Vector) {\n        out.x = input.x;\n        out.y = input.y;\n        out.z = input.z;\n    }\n}\n\nexport interface Rotation {\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n}\n\n/**\n * A quaternion.\n */\nexport class Quaternion implements Rotation {\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n\n    constructor(x: number, y: number, z: number, w: number) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n}\n\nexport class RotationOps {\n    public static identity(): Rotation {\n        return new Quaternion(0.0, 0.0, 0.0, 1.0);\n    }\n\n    public static fromRaw(raw: RawRotation): Rotation {\n        if (!raw) return null;\n\n        let res = new Quaternion(raw.x, raw.y, raw.z, raw.w);\n        raw.free();\n        return res;\n    }\n\n    public static intoRaw(rot: Rotation): RawRotation {\n        return new RawRotation(rot.x, rot.y, rot.z, rot.w);\n    }\n\n    public static copy(out: Rotation, input: Rotation) {\n        out.x = input.x;\n        out.y = input.y;\n        out.z = input.z;\n        out.w = input.w;\n    }\n}\n\n/**\n * A 3D symmetric-positive-definite matrix.\n */\nexport class SdpMatrix3 {\n    /**\n     * Row major list of the upper-triangular part of the symmetric matrix.\n     */\n    elements: Float32Array;\n\n    /**\n     * Matrix element at row 1, column 1.\n     */\n    public get m11(): number {\n        return this.elements[0];\n    }\n\n    /**\n     * Matrix element at row 1, column 2.\n     */\n    public get m12(): number {\n        return this.elements[1];\n    }\n\n    /**\n     * Matrix element at row 2, column 1.\n     */\n    public get m21(): number {\n        return this.m12;\n    }\n\n    /**\n     * Matrix element at row 1, column 3.\n     */\n    public get m13(): number {\n        return this.elements[2];\n    }\n\n    /**\n     * Matrix element at row 3, column 1.\n     */\n    public get m31(): number {\n        return this.m13;\n    }\n\n    /**\n     * Matrix element at row 2, column 2.\n     */\n    public get m22(): number {\n        return this.elements[3];\n    }\n\n    /**\n     * Matrix element at row 2, column 3.\n     */\n    public get m23(): number {\n        return this.elements[4];\n    }\n\n    /**\n     * Matrix element at row 3, column 2.\n     */\n    public get m32(): number {\n        return this.m23;\n    }\n\n    /**\n     * Matrix element at row 3, column 3.\n     */\n    public get m33(): number {\n        return this.elements[5];\n    }\n\n    constructor(elements: Float32Array) {\n        this.elements = elements;\n    }\n}\n\nexport class SdpMatrix3Ops {\n    public static fromRaw(raw: RawSdpMatrix3): SdpMatrix3 {\n        const sdpMatrix3 = new SdpMatrix3(raw.elements());\n        raw.free();\n        return sdpMatrix3;\n    }\n}\n\n// #endif\n", "import {RawRigidBodySet, RawRigidBodyType} from \"../raw\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\n// #if DIM3\nimport {SdpMatrix3, SdpMatrix3Ops} from \"../math\";\n// #endif\nimport {Collider, ColliderSet} from \"../geometry\";\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type RigidBodyHandle = number;\n\n/**\n * The simulation status of a rigid-body.\n */\n// TODO: rename this to RigidBodyType\nexport enum RigidBodyType {\n    /**\n     * A `RigidBodyType::Dynamic` body can be affected by all external forces.\n     */\n    Dynamic = 0,\n    /**\n     * A `RigidBodyType::Fixed` body cannot be affected by external forces.\n     */\n    Fixed,\n    /**\n     * A `RigidBodyType::KinematicPositionBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the position level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    KinematicPositionBased,\n    /**\n     * A `RigidBodyType::KinematicVelocityBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the velocity level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    KinematicVelocityBased,\n}\n\n/**\n * A rigid-body.\n */\nexport class RigidBody {\n    private rawSet: RawRigidBodySet; // The RigidBody won't need to free this.\n    private colliderSet: ColliderSet;\n    readonly handle: RigidBodyHandle;\n\n    /**\n     * An arbitrary user-defined object associated with this rigid-body.\n     */\n    public userData?: unknown;\n\n    constructor(\n        rawSet: RawRigidBodySet,\n        colliderSet: ColliderSet,\n        handle: RigidBodyHandle,\n    ) {\n        this.rawSet = rawSet;\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n    }\n\n    /** @internal */\n    public finalizeDeserialization(colliderSet: ColliderSet) {\n        this.colliderSet = colliderSet;\n    }\n\n    /**\n     * Checks if this rigid-body is still valid (i.e. that it has\n     * not been deleted from the rigid-body set yet.\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer translate due to forces and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public lockTranslations(locked: boolean, wakeUp: boolean) {\n        return this.rawSet.rbLockTranslations(this.handle, locked, wakeUp);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer rotate due to torques and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public lockRotations(locked: boolean, wakeUp: boolean) {\n        return this.rawSet.rbLockRotations(this.handle, locked, wakeUp);\n    }\n\n    // #if DIM3\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer translate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public setEnabledTranslations(\n        enableX: boolean,\n        enableY: boolean,\n        enableZ: boolean,\n        wakeUp: boolean,\n    ) {\n        return this.rawSet.rbSetEnabledTranslations(\n            this.handle,\n            enableX,\n            enableY,\n            enableZ,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer translate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledTranslations` with the same arguments instead.\n     */\n    public restrictTranslations(\n        enableX: boolean,\n        enableY: boolean,\n        enableZ: boolean,\n        wakeUp: boolean,\n    ) {\n        this.setEnabledTranslations(enableX, enableY, enableZ, wakeUp);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public setEnabledRotations(\n        enableX: boolean,\n        enableY: boolean,\n        enableZ: boolean,\n        wakeUp: boolean,\n    ) {\n        return this.rawSet.rbSetEnabledRotations(\n            this.handle,\n            enableX,\n            enableY,\n            enableZ,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledRotations` with the same arguments instead.\n     */\n    public restrictRotations(\n        enableX: boolean,\n        enableY: boolean,\n        enableZ: boolean,\n        wakeUp: boolean,\n    ) {\n        this.setEnabledRotations(enableX, enableY, enableZ, wakeUp);\n    }\n\n    // #endif\n\n    /**\n     * The dominance group, in [-127, +127] this rigid-body is part of.\n     */\n    public dominanceGroup(): number {\n        return this.rawSet.rbDominanceGroup(this.handle);\n    }\n\n    /**\n     * Sets the dominance group of this rigid-body.\n     *\n     * @param group - The dominance group of this rigid-body. Must be a signed integer in the range [-127, +127].\n     */\n    public setDominanceGroup(group: number) {\n        this.rawSet.rbSetDominanceGroup(this.handle, group);\n    }\n\n    /**\n     * The number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     */\n    public additionalSolverIterations(): number {\n        return this.rawSet.rbAdditionalSolverIterations(this.handle);\n    }\n\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n    public setAdditionalSolverIterations(iters: number) {\n        this.rawSet.rbSetAdditionalSolverIterations(this.handle, iters);\n    }\n\n    /**\n     * Enable or disable CCD (Continuous Collision Detection) for this rigid-body.\n     *\n     * @param enabled - If `true`, CCD will be enabled for this rigid-body.\n     */\n    public enableCcd(enabled: boolean) {\n        this.rawSet.rbEnableCcd(this.handle, enabled);\n    }\n\n    /**\n     * Sets the soft-CCD prediction distance for this rigid-body.\n     *\n     * See the documentation of `RigidBodyDesc.setSoftCcdPrediction` for\n     * additional details.\n     */\n    public setSoftCcdPrediction(distance: number) {\n        this.rawSet.rbSetSoftCcdPrediction(this.handle, distance);\n    }\n\n    /**\n     * Gets the soft-CCD prediction distance for this rigid-body.\n     *\n     * See the documentation of `RigidBodyDesc.setSoftCcdPrediction` for\n     * additional details.\n     */\n    public softCcdPrediction(): number {\n        return this.rawSet.rbSoftCcdPrediction(this.handle);\n    }\n\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    public translation(): Vector {\n        let res = this.rawSet.rbTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    public rotation(): Rotation {\n        let res = this.rawSet.rbRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space next translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    public nextTranslation(): Vector {\n        let res = this.rawSet.rbNextTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space next orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    public nextRotation(): Rotation {\n        let res = this.rawSet.rbNextRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * @param tra - The world-space position of the rigid-body.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     *                 wasn't moving before modifying its position.\n     */\n    public setTranslation(tra: Vector, wakeUp: boolean) {\n        // #if DIM3\n        this.rawSet.rbSetTranslation(this.handle, tra.x, tra.y, tra.z, wakeUp);\n        // #endif\n    }\n\n    /**\n     * Sets the linear velocity of this rigid-body.\n     *\n     * @param vel - The linear velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setLinvel(vel: Vector, wakeUp: boolean) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetLinvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n\n    /**\n     * The scale factor applied to the gravity affecting\n     * this rigid-body.\n     */\n    public gravityScale(): number {\n        return this.rawSet.rbGravityScale(this.handle);\n    }\n\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * this rigid-body.\n     *\n     * @param factor - The scale factor to set. A value of 0.0 means\n     *   that this rigid-body will on longer be affected by gravity.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setGravityScale(factor: number, wakeUp: boolean) {\n        this.rawSet.rbSetGravityScale(this.handle, factor, wakeUp);\n    }\n\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     */\n    public setRotation(rot: Rotation, wakeUp: boolean) {\n        this.rawSet.rbSetRotation(\n            this.handle,\n            rot.x,\n            rot.y,\n            rot.z,\n            rot.w,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Sets the angular velocity fo this rigid-body.\n     *\n     * @param vel - The angular velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setAngvel(vel: Vector, wakeUp: boolean) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetAngvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n\n    // #endif\n\n\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param t - The kinematic translation to set.\n     */\n    public setNextKinematicTranslation(t: Vector) {\n        // #if DIM3\n        this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y, t.z);\n        // #endif\n    }\n\n    // #if DIM3\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param rot - The kinematic rotation to set.\n     */\n    public setNextKinematicRotation(rot: Rotation) {\n        this.rawSet.rbSetNextKinematicRotation(\n            this.handle,\n            rot.x,\n            rot.y,\n            rot.z,\n            rot.w,\n        );\n    }\n\n    // #endif\n\n\n    /**\n     * The linear velocity of this rigid-body.\n     */\n    public linvel(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbLinvel(this.handle));\n    }\n\n    // #if DIM3\n    /**\n     * The angular velocity of this rigid-body.\n     */\n    public angvel(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbAngvel(this.handle));\n    }\n\n    // #endif\n\n\n    /**\n     * The mass of this rigid-body.\n     */\n    public mass(): number {\n        return this.rawSet.rbMass(this.handle);\n    }\n\n    /**\n     * The inverse mass taking into account translation locking.\n     */\n    public effectiveInvMass(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));\n    }\n\n    /**\n     * The inverse of the mass of a rigid-body.\n     *\n     * If this is zero, the rigid-body is assumed to have infinite mass.\n     */\n    public invMass(): number {\n        return this.rawSet.rbInvMass(this.handle);\n    }\n\n    /**\n     * The center of mass of a rigid-body expressed in its local-space.\n     */\n    public localCom(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbLocalCom(this.handle));\n    }\n\n    /**\n     * The world-space center of mass of the rigid-body.\n     */\n    public worldCom(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbWorldCom(this.handle));\n    }\n\n\n    // #if DIM3\n    /**\n     * The inverse of the principal angular inertia of the rigid-body.\n     *\n     * Components set to zero are assumed to be infinite along the corresponding principal axis.\n     */\n    public invPrincipalInertiaSqrt(): Vector {\n        return VectorOps.fromRaw(\n            this.rawSet.rbInvPrincipalInertiaSqrt(this.handle),\n        );\n    }\n\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * The angular inertia along the principal inertia axes of the rigid-body.\n     */\n    public principalInertia(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbPrincipalInertia(this.handle));\n    }\n\n    // #endif\n\n    // #if DIM3\n    /**\n     * The principal vectors of the local angular inertia tensor of the rigid-body.\n     */\n    public principalInertiaLocalFrame(): Rotation {\n        return RotationOps.fromRaw(\n            this.rawSet.rbPrincipalInertiaLocalFrame(this.handle),\n        );\n    }\n\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n     * taking into account rotation locking.\n     */\n    public effectiveWorldInvInertiaSqrt(): SdpMatrix3 {\n        return SdpMatrix3Ops.fromRaw(\n            this.rawSet.rbEffectiveWorldInvInertiaSqrt(this.handle),\n        );\n    }\n\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n     * this rigid-body.\n     */\n    public effectiveAngularInertia(): SdpMatrix3 {\n        return SdpMatrix3Ops.fromRaw(\n            this.rawSet.rbEffectiveAngularInertia(this.handle),\n        );\n    }\n\n    // #endif\n\n    /**\n     * Put this rigid body to sleep.\n     *\n     * A sleeping body no longer moves and is no longer simulated by the physics engine unless\n     * it is waken up. It can be woken manually with `this.wakeUp()` or automatically due to\n     * external forces like contacts.\n     */\n    public sleep() {\n        this.rawSet.rbSleep(this.handle);\n    }\n\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     */\n    public wakeUp() {\n        this.rawSet.rbWakeUp(this.handle);\n    }\n\n    /**\n     * Is CCD enabled for this rigid-body?\n     */\n    public isCcdEnabled(): boolean {\n        return this.rawSet.rbIsCcdEnabled(this.handle);\n    }\n\n    /**\n     * The number of colliders attached to this rigid-body.\n     */\n    public numColliders(): number {\n        return this.rawSet.rbNumColliders(this.handle);\n    }\n\n    /**\n     * Retrieves the `i-th` collider attached to this rigid-body.\n     *\n     * @param i - The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     */\n    public collider(i: number): Collider {\n        return this.colliderSet.get(this.rawSet.rbCollider(this.handle, i));\n    }\n\n    /**\n     * Sets whether this rigid-body is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this rigid-body and all its attached colliders.\n     */\n    public setEnabled(enabled: boolean) {\n        this.rawSet.rbSetEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Is this rigid-body enabled?\n     */\n    public isEnabled(): boolean {\n        return this.rawSet.rbIsEnabled(this.handle);\n    }\n\n    /**\n     * The status of this rigid-body: static, dynamic, or kinematic.\n     */\n    public bodyType(): RigidBodyType {\n        return this.rawSet.rbBodyType(this.handle) as number as RigidBodyType;\n    }\n\n    /**\n     * Set a new status for this rigid-body: static, dynamic, or kinematic.\n     */\n    public setBodyType(type: RigidBodyType, wakeUp: boolean) {\n        return this.rawSet.rbSetBodyType(\n            this.handle,\n            type as number as RawRigidBodyType,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Is this rigid-body sleeping?\n     */\n    public isSleeping(): boolean {\n        return this.rawSet.rbIsSleeping(this.handle);\n    }\n\n    /**\n     * Is the velocity of this rigid-body not zero?\n     */\n    public isMoving(): boolean {\n        return this.rawSet.rbIsMoving(this.handle);\n    }\n\n    /**\n     * Is this rigid-body static?\n     */\n    public isFixed(): boolean {\n        return this.rawSet.rbIsFixed(this.handle);\n    }\n\n    /**\n     * Is this rigid-body kinematic?\n     */\n    public isKinematic(): boolean {\n        return this.rawSet.rbIsKinematic(this.handle);\n    }\n\n    /**\n     * Is this rigid-body dynamic?\n     */\n    public isDynamic(): boolean {\n        return this.rawSet.rbIsDynamic(this.handle);\n    }\n\n    /**\n     * The linear damping coefficient of this rigid-body.\n     */\n    public linearDamping(): number {\n        return this.rawSet.rbLinearDamping(this.handle);\n    }\n\n    /**\n     * The angular damping coefficient of this rigid-body.\n     */\n    public angularDamping(): number {\n        return this.rawSet.rbAngularDamping(this.handle);\n    }\n\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    public setLinearDamping(factor: number) {\n        this.rawSet.rbSetLinearDamping(this.handle, factor);\n    }\n\n    /**\n     * Recompute the mass-properties of this rigid-bodies based on its currently attached colliders.\n     */\n    public recomputeMassPropertiesFromColliders() {\n        this.rawSet.rbRecomputeMassPropertiesFromColliders(\n            this.handle,\n            this.colliderSet.raw,\n        );\n    }\n\n    /**\n     * Sets the rigid-body's additional mass.\n     *\n     * The total angular inertia of the rigid-body will be scaled automatically based on this additional mass. If this\n     * scaling effect isnt desired, use Self::additional_mass_properties instead of this method.\n     *\n     * This is only the \"additional\" mass because the total mass of the rigid-body is equal to the sum of this\n     * additional mass and the mass computed from the colliders (with non-zero densities) attached to this rigid-body.\n     *\n     * That total mass (which includes the attached colliders contributions) will be updated at the name physics step,\n     * or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous additional mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc::setAdditionalMass`, or\n     * `RigidBodyDesc.setAdditionalMassfProperties` for this rigid-body.\n     *\n     * @param mass - The additional mass to set.\n     * @param wakeUp - If `true` then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    public setAdditionalMass(mass: number, wakeUp: boolean) {\n        this.rawSet.rbSetAdditionalMass(this.handle, mass, wakeUp);\n    }\n\n    // #if DIM3\n    /**\n     * Sets the rigid-body's additional mass-properties.\n     *\n     * This is only the \"additional\" mass-properties because the total mass-properties of the rigid-body is equal to the\n     * sum of this additional mass-properties and the mass computed from the colliders (with non-zero densities) attached\n     * to this rigid-body.\n     *\n     * That total mass-properties (which include the attached colliders contributions) will be updated at the name\n     * physics step, or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc.setAdditionalMass`, or `RigidBodyDesc.setAdditionalMassProperties`\n     * for this rigid-body.\n     *\n     * If `wake_up` is true then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    public setAdditionalMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: Vector,\n        angularInertiaLocalFrame: Rotation,\n        wakeUp: boolean,\n    ) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        let rawPrincipalInertia = VectorOps.intoRaw(principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(angularInertiaLocalFrame);\n\n        this.rawSet.rbSetAdditionalMassProperties(\n            this.handle,\n            mass,\n            rawCom,\n            rawPrincipalInertia,\n            rawInertiaFrame,\n            wakeUp,\n        );\n\n        rawCom.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n    }\n\n    // #endif\n\n\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    public setAngularDamping(factor: number) {\n        this.rawSet.rbSetAngularDamping(this.handle, factor);\n    }\n\n    /**\n     * Resets to zero the user forces (but not torques) applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public resetForces(wakeUp: boolean) {\n        this.rawSet.rbResetForces(this.handle, wakeUp);\n    }\n\n    /**\n     * Resets to zero the user torques applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public resetTorques(wakeUp: boolean) {\n        this.rawSet.rbResetTorques(this.handle, wakeUp);\n    }\n\n    /**\n     * Adds a force at the center-of-mass of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addForce(force: Vector, wakeUp: boolean) {\n        const rawForce = VectorOps.intoRaw(force);\n        this.rawSet.rbAddForce(this.handle, rawForce, wakeUp);\n        rawForce.free();\n    }\n\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyImpulse(impulse: Vector, wakeUp: boolean) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        this.rawSet.rbApplyImpulse(this.handle, rawImpulse, wakeUp);\n        rawImpulse.free();\n    }\n\n\n    // #if DIM3\n    /**\n     * Adds a torque at the center-of-mass of this rigid-body.\n     *\n     * @param torque - the world-space torque to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addTorque(torque: Vector, wakeUp: boolean) {\n        const rawTorque = VectorOps.intoRaw(torque);\n        this.rawSet.rbAddTorque(this.handle, rawTorque, wakeUp);\n        rawTorque.free();\n    }\n\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * @param torqueImpulse - the world-space torque impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyTorqueImpulse(torqueImpulse: Vector, wakeUp: boolean) {\n        const rawTorqueImpulse = VectorOps.intoRaw(torqueImpulse);\n        this.rawSet.rbApplyTorqueImpulse(this.handle, rawTorqueImpulse, wakeUp);\n        rawTorqueImpulse.free();\n    }\n\n    // #endif\n\n    /**\n     * Adds a force at the given world-space point of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addForceAtPoint(force: Vector, point: Vector, wakeUp: boolean) {\n        const rawForce = VectorOps.intoRaw(force);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbAddForceAtPoint(this.handle, rawForce, rawPoint, wakeUp);\n        rawForce.free();\n        rawPoint.free();\n    }\n\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyImpulseAtPoint(\n        impulse: Vector,\n        point: Vector,\n        wakeUp: boolean,\n    ) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbApplyImpulseAtPoint(\n            this.handle,\n            rawImpulse,\n            rawPoint,\n            wakeUp,\n        );\n        rawImpulse.free();\n        rawPoint.free();\n    }\n\n    /**\n     * Retrieves the constant force(s) the user added to this rigid-body\n     * Returns zero if the rigid-body is not dynamic.\n     */\n    public userForce(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbUserForce(this.handle));\n    }\n\n\n    // #if DIM3\n    /**\n     * Retrieves the constant torque(s) the user added to this rigid-body\n     * Returns zero if the rigid-body is not dynamic.\n     */\n    public userTorque(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbUserTorque(this.handle));\n    }\n    // #endif\n}\n\nexport class RigidBodyDesc {\n    enabled: boolean;\n    translation: Vector;\n    rotation: Rotation;\n    gravityScale: number;\n    mass: number;\n    massOnly: boolean;\n    centerOfMass: Vector;\n    translationsEnabledX: boolean;\n    translationsEnabledY: boolean;\n    linvel: Vector;\n    // #if DIM3\n    angvel: Vector;\n    principalAngularInertia: Vector;\n    angularInertiaLocalFrame: Rotation;\n    translationsEnabledZ: boolean;\n    rotationsEnabledX: boolean;\n    rotationsEnabledY: boolean;\n    rotationsEnabledZ: boolean;\n    // #endif\n    linearDamping: number;\n    angularDamping: number;\n    status: RigidBodyType;\n    canSleep: boolean;\n    sleeping: boolean;\n    ccdEnabled: boolean;\n    softCcdPrediction: number;\n    dominanceGroup: number;\n    additionalSolverIterations: number;\n    userData?: unknown;\n\n    constructor(status: RigidBodyType) {\n        this.enabled = true;\n        this.status = status;\n        this.translation = VectorOps.zeros();\n        this.rotation = RotationOps.identity();\n        this.gravityScale = 1.0;\n        this.linvel = VectorOps.zeros();\n        this.mass = 0.0;\n        this.massOnly = false;\n        this.centerOfMass = VectorOps.zeros();\n        this.translationsEnabledX = true;\n        this.translationsEnabledY = true;\n        // #if DIM3\n        this.angvel = VectorOps.zeros();\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        this.translationsEnabledZ = true;\n        this.rotationsEnabledX = true;\n        this.rotationsEnabledY = true;\n        this.rotationsEnabledZ = true;\n        // #endif\n        this.linearDamping = 0.0;\n        this.angularDamping = 0.0;\n        this.canSleep = true;\n        this.sleeping = false;\n        this.ccdEnabled = false;\n        this.softCcdPrediction = 0.0;\n        this.dominanceGroup = 0;\n        this.additionalSolverIterations = 0;\n    }\n\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     */\n    public static dynamic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     */\n    public static kinematicPositionBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     */\n    public static kinematicVelocityBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     */\n    public static fixed(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.dynamic()`.\n     */\n    public static newDynamic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicPositionBased()`.\n     */\n    public static newKinematicPositionBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicVelocityBased()`.\n     */\n    public static newKinematicVelocityBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     *\n     * @deprecated The method has been renamed to `.fixed()`.\n     */\n    public static newStatic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n\n    public setDominanceGroup(group: number): RigidBodyDesc {\n        this.dominanceGroup = group;\n        return this;\n    }\n\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n    public setAdditionalSolverIterations(iters: number): RigidBodyDesc {\n        this.additionalSolverIterations = iters;\n        return this;\n    }\n\n    /**\n     * Sets whether the created rigid-body will be enabled or disabled.\n     * @param enabled  If set to `false` the rigid-body will be disabled at creation.\n     */\n    public setEnabled(enabled: boolean): RigidBodyDesc {\n        this.enabled = enabled;\n        return this;\n    }\n\n\n    // #if DIM3\n    /**\n     * Sets the initial translation of the rigid-body to create.\n     *\n     * @param tra - The translation to set.\n     */\n    public setTranslation(x: number, y: number, z: number): RigidBodyDesc {\n        if (\n            typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\"\n        )\n            throw TypeError(\"The translation components must be numbers.\");\n\n        this.translation = {x: x, y: y, z: z};\n        return this;\n    }\n\n    // #endif\n\n    /**\n     * Sets the initial rotation of the rigid-body to create.\n     *\n     * @param rot - The rotation to set.\n     */\n    public setRotation(rot: Rotation): RigidBodyDesc {\n        // #if DIM3\n        RotationOps.copy(this.rotation, rot);\n        // #endif\n        return this;\n    }\n\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * the rigid-body being built.\n     *\n     * @param scale - The scale factor. Set this to `0.0` if the rigid-body\n     *   needs to ignore gravity.\n     */\n    public setGravityScale(scale: number): RigidBodyDesc {\n        this.gravityScale = scale;\n        return this;\n    }\n\n    /**\n     * Sets the initial mass of the rigid-body being built, before adding colliders' contributions.\n     *\n     * @param mass  The initial mass of the rigid-body to create.\n     */\n    public setAdditionalMass(mass: number): RigidBodyDesc {\n        this.mass = mass;\n        this.massOnly = true;\n        return this;\n    }\n\n\n    // #if DIM3\n    /**\n     * Sets the initial linear velocity of the rigid-body to create.\n     *\n     * @param x - The linear velocity to set along the `x` axis.\n     * @param y - The linear velocity to set along the `y` axis.\n     * @param z - The linear velocity to set along the `z` axis.\n     */\n    public setLinvel(x: number, y: number, z: number): RigidBodyDesc {\n        if (\n            typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\"\n        )\n            throw TypeError(\"The linvel components must be numbers.\");\n\n        this.linvel = {x: x, y: y, z: z};\n        return this;\n    }\n\n    /**\n     * Sets the initial angular velocity of the rigid-body to create.\n     *\n     * @param vel - The angular velocity to set.\n     */\n    public setAngvel(vel: Vector): RigidBodyDesc {\n        VectorOps.copy(this.angvel, vel);\n        return this;\n    }\n\n    /**\n     * Sets the mass properties of the rigid-body being built.\n     *\n     * Note that the final mass properties of the rigid-bodies depends\n     * on the initial mass-properties of the rigid-body (set by this method)\n     * to which is added the contributions of all the colliders with non-zero density\n     * attached to this rigid-body.\n     *\n     * Therefore, if you want your provided mass properties to be the final\n     * mass properties of your rigid-body, don't attach colliders to it, or\n     * only attach colliders with densities equal to zero.\n     *\n     * @param mass  The initial mass of the rigid-body to create.\n     * @param centerOfMass  The initial center-of-mass of the rigid-body to create.\n     * @param principalAngularInertia  The initial principal angular inertia of the rigid-body to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame  The initial local angular inertia frame of the rigid-body to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    public setAdditionalMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: Vector,\n        angularInertiaLocalFrame: Rotation,\n    ): RigidBodyDesc {\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        VectorOps.copy(this.principalAngularInertia, principalAngularInertia);\n        RotationOps.copy(\n            this.angularInertiaLocalFrame,\n            angularInertiaLocalFrame,\n        );\n        this.massOnly = false;\n        return this;\n    }\n\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @param translationsEnabledZ - Are translations along the Z axis enabled?\n     */\n    public enabledTranslations(\n        translationsEnabledX: boolean,\n        translationsEnabledY: boolean,\n        translationsEnabledZ: boolean,\n    ): RigidBodyDesc {\n        this.translationsEnabledX = translationsEnabledX;\n        this.translationsEnabledY = translationsEnabledY;\n        this.translationsEnabledZ = translationsEnabledZ;\n        return this;\n    }\n\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @param translationsEnabledZ - Are translations along the Z axis enabled?\n     * @deprecated use `this.enabledTranslations` with the same arguments instead.\n     */\n    public restrictTranslations(\n        translationsEnabledX: boolean,\n        translationsEnabledY: boolean,\n        translationsEnabledZ: boolean,\n    ): RigidBodyDesc {\n        return this.enabledTranslations(\n            translationsEnabledX,\n            translationsEnabledY,\n            translationsEnabledZ,\n        );\n    }\n\n    /**\n     * Locks all translations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    public lockTranslations(): RigidBodyDesc {\n        return this.enabledTranslations(false, false, false);\n    }\n\n    /**\n     * Allow rotation of this rigid-body only along specific axes.\n     * @param rotationsEnabledX - Are rotations along the X axis enabled?\n     * @param rotationsEnabledY - Are rotations along the y axis enabled?\n     * @param rotationsEnabledZ - Are rotations along the Z axis enabled?\n     */\n    public enabledRotations(\n        rotationsEnabledX: boolean,\n        rotationsEnabledY: boolean,\n        rotationsEnabledZ: boolean,\n    ): RigidBodyDesc {\n        this.rotationsEnabledX = rotationsEnabledX;\n        this.rotationsEnabledY = rotationsEnabledY;\n        this.rotationsEnabledZ = rotationsEnabledZ;\n        return this;\n    }\n\n    /**\n     * Allow rotation of this rigid-body only along specific axes.\n     * @param rotationsEnabledX - Are rotations along the X axis enabled?\n     * @param rotationsEnabledY - Are rotations along the y axis enabled?\n     * @param rotationsEnabledZ - Are rotations along the Z axis enabled?\n     * @deprecated use `this.enabledRotations` with the same arguments instead.\n     */\n    public restrictRotations(\n        rotationsEnabledX: boolean,\n        rotationsEnabledY: boolean,\n        rotationsEnabledZ: boolean,\n    ): RigidBodyDesc {\n        return this.enabledRotations(\n            rotationsEnabledX,\n            rotationsEnabledY,\n            rotationsEnabledZ,\n        );\n    }\n\n    /**\n     * Locks all rotations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    public lockRotations(): RigidBodyDesc {\n        return this.restrictRotations(false, false, false);\n    }\n\n    // #endif\n\n    /**\n     * Sets the linear damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the translational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the translational slowdown will be.\n     */\n    public setLinearDamping(damping: number): RigidBodyDesc {\n        this.linearDamping = damping;\n        return this;\n    }\n\n    /**\n     * Sets the angular damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the rotational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the rotational slowdown will be.\n     */\n    public setAngularDamping(damping: number): RigidBodyDesc {\n        this.angularDamping = damping;\n        return this;\n    }\n\n    /**\n     * Sets whether or not the rigid-body to create can sleep.\n     *\n     * @param can - true if the rigid-body can sleep, false if it can't.\n     */\n    public setCanSleep(can: boolean): RigidBodyDesc {\n        this.canSleep = can;\n        return this;\n    }\n\n    /**\n     * Sets whether or not the rigid-body is to be created asleep.\n     *\n     * @param can - true if the rigid-body should be in sleep, default false.\n     */\n    setSleeping(sleeping: boolean): RigidBodyDesc {\n        this.sleeping = sleeping;\n        return this;\n    }\n\n    /**\n     * Sets whether Continuous Collision Detection (CCD) is enabled for this rigid-body.\n     *\n     * @param enabled - true if the rigid-body has CCD enabled.\n     */\n    public setCcdEnabled(enabled: boolean): RigidBodyDesc {\n        this.ccdEnabled = enabled;\n        return this;\n    }\n\n    /**\n     * Sets the maximum prediction distance Soft Continuous Collision-Detection.\n     *\n     * When set to 0, soft-CCD is disabled. Soft-CCD helps prevent tunneling especially of\n     * slow-but-thin to moderately fast objects. The soft CCD prediction distance indicates how\n     * far in the objects path the CCD algorithm is allowed to inspect. Large values can impact\n     * performance badly by increasing the work needed from the broad-phase.\n     *\n     * It is a generally cheaper variant of regular CCD (that can be enabled with\n     * `RigidBodyDesc::setCcdEnabled` since it relies on predictive constraints instead of\n     * shape-cast and substeps.\n     */\n    public setSoftCcdPrediction(distance: number): RigidBodyDesc {\n        this.softCcdPrediction = distance;\n        return this;\n    }\n\n    /**\n     * Sets the user-defined object of this rigid-body.\n     *\n     * @param userData - The user-defined object to set.\n     */\n    public setUserData(data?: unknown): RigidBodyDesc {\n        this.userData = data;\n        return this;\n    }\n}\n", "export class Coarena<T> {\n    fconv: Float64Array;\n    uconv: Uint32Array;\n    data: Array<T>;\n    size: number;\n\n    public constructor() {\n        this.fconv = new Float64Array(1);\n        this.uconv = new Uint32Array(this.fconv.buffer);\n        this.data = new Array<T>();\n        this.size = 0;\n    }\n\n    public set(handle: number, data: T) {\n        let i = this.index(handle);\n        while (this.data.length <= i) {\n            this.data.push(null);\n        }\n\n        if (this.data[i] == null) this.size += 1;\n        this.data[i] = data;\n    }\n\n    public len(): number {\n        return this.size;\n    }\n\n    public delete(handle: number) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            if (this.data[i] != null) this.size -= 1;\n            this.data[i] = null;\n        }\n    }\n\n    public clear() {\n        this.data = new Array<T>();\n    }\n\n    public get(handle: number): T | null {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            return this.data[i];\n        } else {\n            return null;\n        }\n    }\n\n    public forEach(f: (elt: T) => void) {\n        for (const elt of this.data) {\n            if (elt != null) f(elt);\n        }\n    }\n\n    public getAll(): Array<T> {\n        return this.data.filter((elt) => elt != null);\n    }\n\n    private index(handle: number): number {\n        /// Extracts the index part of a handle (the lower 32 bits).\n        /// This is done by first injecting the handle into an Float64Array\n        /// which is itself injected into an Uint32Array (at construction time).\n        /// The 0-th value of the Uint32Array will become the `number` integer\n        /// representation of the lower 32 bits.\n        /// Also `this.uconv[1]` then contains the generation number as a `number`,\n        /// which we dont really need.\n        this.fconv[0] = handle;\n        return this.uconv[0];\n    }\n}\n", "import {RawRigidBodySet, RawRigidBodyType} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {VectorOps, RotationOps} from \"../math\";\nimport {\n    RigidBody,\n    RigidBodyDesc,\n    RigidBodyHandle,\n    RigidBodyType,\n} from \"./rigid_body\";\nimport {ColliderSet} from \"../geometry\";\nimport {ImpulseJointSet} from \"./impulse_joint_set\";\nimport {MultibodyJointSet} from \"./multibody_joint_set\";\nimport {IslandManager} from \"./island_manager\";\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `rigidBodySet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class RigidBodySet {\n    raw: RawRigidBodySet;\n    private map: Coarena<RigidBody>;\n\n    /**\n     * Release the WASM memory occupied by this rigid-body set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawRigidBodySet) {\n        this.raw = raw || new RawRigidBodySet();\n        this.map = new Coarena<RigidBody>();\n        // deserialize\n        if (raw) {\n            raw.forEachRigidBodyHandle((handle: RigidBodyHandle) => {\n                this.map.set(handle, new RigidBody(raw, null, handle));\n            });\n        }\n    }\n\n    /**\n     * Internal method, do not call this explicitly.\n     */\n    public finalizeDeserialization(colliderSet: ColliderSet) {\n        this.map.forEach((rb) => rb.finalizeDeserialization(colliderSet));\n    }\n\n    /**\n     * Creates a new rigid-body and return its integer handle.\n     *\n     * @param desc - The description of the rigid-body to create.\n     */\n    public createRigidBody(\n        colliderSet: ColliderSet,\n        desc: RigidBodyDesc,\n    ): RigidBody {\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawLv = VectorOps.intoRaw(desc.linvel);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n\n        // #if DIM3\n        let rawAv = VectorOps.intoRaw(desc.angvel);\n        let rawPrincipalInertia = VectorOps.intoRaw(\n            desc.principalAngularInertia,\n        );\n        let rawInertiaFrame = RotationOps.intoRaw(\n            desc.angularInertiaLocalFrame,\n        );\n        // #endif\n\n        let handle = this.raw.createRigidBody(\n            desc.enabled,\n            rawTra,\n            rawRot,\n            desc.gravityScale,\n            desc.mass,\n            desc.massOnly,\n            rawCom,\n            rawLv,\n            // #if DIM3\n            rawAv,\n            rawPrincipalInertia,\n            rawInertiaFrame,\n            desc.translationsEnabledX,\n            desc.translationsEnabledY,\n            desc.translationsEnabledZ,\n            desc.rotationsEnabledX,\n            desc.rotationsEnabledY,\n            desc.rotationsEnabledZ,\n            // #endif\n            desc.linearDamping,\n            desc.angularDamping,\n            desc.status as number as RawRigidBodyType,\n            desc.canSleep,\n            desc.sleeping,\n            desc.softCcdPrediction,\n            desc.ccdEnabled,\n            desc.dominanceGroup,\n            desc.additionalSolverIterations,\n        );\n\n        rawTra.free();\n        rawRot.free();\n        rawLv.free();\n        rawCom.free();\n\n        // #if DIM3\n        rawAv.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n\n        const body = new RigidBody(this.raw, colliderSet, handle);\n        body.userData = desc.userData;\n\n        this.map.set(handle, body);\n\n        return body;\n    }\n\n    /**\n     * Removes a rigid-body from this set.\n     *\n     * This will also remove all the colliders and joints attached to the rigid-body.\n     *\n     * @param handle - The integer handle of the rigid-body to remove.\n     * @param colliders - The set of colliders that may contain colliders attached to the removed rigid-body.\n     * @param impulseJoints - The set of impulse joints that may contain joints attached to the removed rigid-body.\n     * @param multibodyJoints - The set of multibody joints that may contain joints attached to the removed rigid-body.\n     */\n    public remove(\n        handle: RigidBodyHandle,\n        islands: IslandManager,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n    ) {\n        // Unmap the entities that will be removed automatically because of the rigid-body removals.\n        for (let i = 0; i < this.raw.rbNumColliders(handle); i += 1) {\n            colliders.unmap(this.raw.rbCollider(handle, i));\n        }\n\n        impulseJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) =>\n            impulseJoints.unmap(handle),\n        );\n        multibodyJoints.forEachJointHandleAttachedToRigidBody(\n            handle,\n            (handle) => multibodyJoints.unmap(handle),\n        );\n\n        // Remove the rigid-body.\n        this.raw.remove(\n            handle,\n            islands.raw,\n            colliders.raw,\n            impulseJoints.raw,\n            multibodyJoints.raw,\n        );\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of rigid-bodies on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a rigid-body with the given handle?\n     *\n     * @param handle - The rigid-body handle to check.\n     */\n    public contains(handle: RigidBodyHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    public get(handle: RigidBodyHandle): RigidBody | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each rigid-body contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (body: RigidBody) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachActiveRigidBody(\n        islands: IslandManager,\n        f: (body: RigidBody) => void,\n    ) {\n        islands.forEachActiveRigidBodyHandle((handle) => {\n            f(this.get(handle));\n        });\n    }\n\n    /**\n     * Gets all rigid-bodies in the list.\n     *\n     * @returns rigid-bodies list.\n     */\n    public getAll(): RigidBody[] {\n        return this.map.getAll();\n    }\n}\n", "import {RawIntegrationParameters} from \"../raw\";\n\nexport class IntegrationParameters {\n    raw: RawIntegrationParameters;\n\n    constructor(raw?: RawIntegrationParameters) {\n        this.raw = raw || new RawIntegrationParameters();\n    }\n\n    /**\n     * Free the WASM memory used by these integration parameters.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * The timestep length (default: `1.0 / 60.0`)\n     */\n    get dt(): number {\n        return this.raw.dt;\n    }\n\n    /**\n     * The Error Reduction Parameter in `[0, 1]` is the proportion of\n     * the positional error to be corrected at each time step (default: `0.2`).\n     */\n    get contact_erp(): number {\n        return this.raw.contact_erp;\n    }\n\n    get lengthUnit(): number {\n        return this.raw.lengthUnit;\n    }\n\n    /**\n     * Normalized amount of penetration the engine wont attempt to correct (default: `0.001m`).\n     *\n     * This threshold considered by the physics engine is this value multiplied by the `lengthUnit`.\n     */\n    get normalizedAllowedLinearError(): number {\n        return this.raw.normalizedAllowedLinearError;\n    }\n\n    /**\n     * The maximal normalized distance separating two objects that will generate predictive contacts (default: `0.002`).\n     *\n     * This threshold considered by the physics engine is this value multiplied by the `lengthUnit`.\n     */\n    get normalizedPredictionDistance(): number {\n        return this.raw.normalizedPredictionDistance;\n    }\n\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    get numSolverIterations(): number {\n        return this.raw.numSolverIterations;\n    }\n\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    get numAdditionalFrictionIterations(): number {\n        return this.raw.numAdditionalFrictionIterations;\n    }\n\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    get numInternalPgsIterations(): number {\n        return this.raw.numInternalPgsIterations;\n    }\n\n    /**\n     * Minimum number of dynamic bodies in each active island (default: `128`).\n     */\n    get minIslandSize(): number {\n        return this.raw.minIslandSize;\n    }\n\n    /**\n     * Maximum number of substeps performed by the  solver (default: `1`).\n     */\n    get maxCcdSubsteps(): number {\n        return this.raw.maxCcdSubsteps;\n    }\n\n    set dt(value: number) {\n        this.raw.dt = value;\n    }\n\n    set contact_natural_frequency(value: number) {\n        this.raw.contact_natural_frequency = value;\n    }\n\n    set lengthUnit(value: number) {\n        this.raw.lengthUnit = value;\n    }\n\n    set normalizedAllowedLinearError(value: number) {\n        this.raw.normalizedAllowedLinearError = value;\n    }\n\n    set normalizedPredictionDistance(value: number) {\n        this.raw.normalizedPredictionDistance = value;\n    }\n\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    set numSolverIterations(value: number) {\n        this.raw.numSolverIterations = value;\n    }\n\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    set numAdditionalFrictionIterations(value: number) {\n        this.raw.numAdditionalFrictionIterations = value;\n    }\n\n    /**\n     * Sets the number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    set numInternalPgsIterations(value: number) {\n        this.raw.numInternalPgsIterations = value;\n    }\n\n    set minIslandSize(value: number) {\n        this.raw.minIslandSize = value;\n    }\n\n    set maxCcdSubsteps(value: number) {\n        this.raw.maxCcdSubsteps = value;\n    }\n\n    public switchToStandardPgsSolver() {\n        this.raw.switchToStandardPgsSolver();\n    }\n\n    public switchToSmallStepsPgsSolver() {\n        this.raw.switchToSmallStepsPgsSolver();\n    }\n\n    public switchToSmallStepsPgsSolverWithoutWarmstart() {\n        this.raw.switchToSmallStepsPgsSolverWithoutWarmstart();\n    }\n}\n", "import {Rotation, Vector, VectorOps, RotationOps} from \"../math\";\nimport {\n    RawGenericJoint,\n    RawImpulseJointSet,\n    RawRigidBodySet,\n    RawJointAxis,\n    RawJointType,\n    RawMotorModel,\n} from \"../raw\";\nimport {RigidBody, RigidBodyHandle} from \"./rigid_body\";\nimport {RigidBodySet} from \"./rigid_body_set\";\n// #if DIM3\nimport {Quaternion} from \"../math\";\n// #endif\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type ImpulseJointHandle = number;\n\n/**\n * An enum grouping all possible types of joints:\n *\n * - `Revolute`: A revolute joint that removes all degrees of freedom between the affected\n *               bodies except for the rotation along one axis.\n * - `Fixed`: A fixed joint that removes all relative degrees of freedom between the affected bodies.\n * - `Prismatic`: A prismatic joint that removes all degrees of freedom between the affected\n *                bodies except for the translation along one axis.\n * - `Spherical`: (3D only) A spherical joint that removes all relative linear degrees of freedom between the affected bodies.\n * - `Generic`: (3D only) A joint with customizable degrees of freedom, allowing any of the 6 axes to be locked.\n */\nexport enum JointType {\n    Revolute,\n    Fixed,\n    Prismatic,\n    Rope,\n    Spring,\n    // #if DIM3\n    Spherical,\n    Generic,\n    // #endif\n}\n\nexport enum MotorModel {\n    AccelerationBased,\n    ForceBased,\n}\n\n/**\n * An enum representing the possible joint axes of a generic joint.\n * They can be ORed together, like:\n * JointAxesMask.LinX || JointAxesMask.LinY\n * to get a joint that is only free in the X and Y translational (positional) axes.\n *\n * Possible free axes are:\n *\n * - `X`: X translation axis\n * - `Y`: Y translation axis\n * - `Z`: Z translation axis\n * - `AngX`: X angular rotation axis\n * - `AngY`: Y angular rotations axis\n * - `AngZ`: Z angular rotation axis\n */\nexport enum JointAxesMask {\n    LinX = 1 << 0,\n    LinY = 1 << 1,\n    LinZ = 1 << 2,\n    AngX = 1 << 3,\n    AngY = 1 << 4,\n    AngZ = 1 << 5,\n}\n\nexport class ImpulseJoint {\n    protected rawSet: RawImpulseJointSet; // The ImpulseJoint won't need to free this.\n    protected bodySet: RigidBodySet; // The ImpulseJoint wont need to free this.\n    handle: ImpulseJointHandle;\n\n    constructor(\n        rawSet: RawImpulseJointSet,\n        bodySet: RigidBodySet,\n        handle: ImpulseJointHandle,\n    ) {\n        this.rawSet = rawSet;\n        this.bodySet = bodySet;\n        this.handle = handle;\n    }\n\n    public static newTyped(\n        rawSet: RawImpulseJointSet,\n        bodySet: RigidBodySet,\n        handle: ImpulseJointHandle,\n    ): ImpulseJoint {\n        switch (rawSet.jointType(handle)) {\n            case RawJointType.Revolute:\n                return new RevoluteImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Prismatic:\n                return new PrismaticImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Fixed:\n                return new FixedImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Spring:\n                return new SpringImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Rope:\n                return new RopeImpulseJoint(rawSet, bodySet, handle);\n            // #if DIM3\n            case RawJointType.Spherical:\n                return new SphericalImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Generic:\n                return new GenericImpulseJoint(rawSet, bodySet, handle);\n            // #endif\n            default:\n                return new ImpulseJoint(rawSet, bodySet, handle);\n        }\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodySet: RigidBodySet) {\n        this.bodySet = bodySet;\n    }\n\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    /**\n     * The first rigid-body this joint it attached to.\n     */\n    public body1(): RigidBody {\n        return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));\n    }\n\n    /**\n     * The second rigid-body this joint is attached to.\n     */\n    public body2(): RigidBody {\n        return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));\n    }\n\n    /**\n     * The type of this joint given as a string.\n     */\n    public type(): JointType {\n        return this.rawSet.jointType(this.handle) as number as JointType;\n    }\n\n    // #if DIM3\n    /**\n     * The rotation quaternion that aligns this joint's first local axis to the `x` axis.\n     */\n    public frameX1(): Rotation {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));\n    }\n\n    // #endif\n\n    // #if DIM3\n    /**\n     * The rotation matrix that aligns this joint's second local axis to the `x` axis.\n     */\n    public frameX2(): Rotation {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));\n    }\n\n    // #endif\n\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    public anchor1(): Vector {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    }\n\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    public anchor2(): Vector {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    }\n\n    /**\n     * Sets the position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    public setAnchor1(newPos: Vector) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor1(this.handle, rawPoint);\n        rawPoint.free();\n    }\n\n    /**\n     * Sets the position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    public setAnchor2(newPos: Vector) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor2(this.handle, rawPoint);\n        rawPoint.free();\n    }\n\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public setContactsEnabled(enabled: boolean) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public contactsEnabled(): boolean {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\n\nexport class UnitImpulseJoint extends ImpulseJoint {\n    /**\n     * The axis left free by this joint.\n     */\n    protected rawAxis?(): RawJointAxis;\n\n    /**\n     * Are the limits enabled for this joint?\n     */\n    public limitsEnabled(): boolean {\n        return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    }\n\n    /**\n     * The min limit of this joint.\n     */\n    public limitsMin(): number {\n        return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    }\n\n    /**\n     * The max limit of this joint.\n     */\n    public limitsMax(): number {\n        return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    }\n\n    /**\n     * Sets the limits of this joint.\n     *\n     * @param min - The minimum bound of this joints free coordinate.\n     * @param max - The maximum bound of this joints free coordinate.\n     */\n    public setLimits(min: number, max: number) {\n        this.rawSet.jointSetLimits(this.handle, this.rawAxis(), min, max);\n    }\n\n    public configureMotorModel(model: MotorModel) {\n        this.rawSet.jointConfigureMotorModel(\n            this.handle,\n            this.rawAxis(),\n            model as number as RawMotorModel,\n        );\n    }\n\n    public configureMotorVelocity(targetVel: number, factor: number) {\n        this.rawSet.jointConfigureMotorVelocity(\n            this.handle,\n            this.rawAxis(),\n            targetVel,\n            factor,\n        );\n    }\n\n    public configureMotorPosition(\n        targetPos: number,\n        stiffness: number,\n        damping: number,\n    ) {\n        this.rawSet.jointConfigureMotorPosition(\n            this.handle,\n            this.rawAxis(),\n            targetPos,\n            stiffness,\n            damping,\n        );\n    }\n\n    public configureMotor(\n        targetPos: number,\n        targetVel: number,\n        stiffness: number,\n        damping: number,\n    ) {\n        this.rawSet.jointConfigureMotor(\n            this.handle,\n            this.rawAxis(),\n            targetPos,\n            targetVel,\n            stiffness,\n            damping,\n        );\n    }\n}\n\nexport class FixedImpulseJoint extends ImpulseJoint {}\n\nexport class RopeImpulseJoint extends ImpulseJoint {}\n\nexport class SpringImpulseJoint extends ImpulseJoint {}\n\nexport class PrismaticImpulseJoint extends UnitImpulseJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.LinX;\n    }\n}\n\nexport class RevoluteImpulseJoint extends UnitImpulseJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.AngX;\n    }\n}\n\n// #if DIM3\nexport class GenericImpulseJoint extends ImpulseJoint {}\n\nexport class SphericalImpulseJoint extends ImpulseJoint {\n    /* Unsupported by this alpha release.\n    public configureMotorModel(model: MotorModel) {\n        this.rawSet.jointConfigureMotorModel(this.handle, model);\n    }\n\n    public configureMotorVelocity(targetVel: Vector, factor: number) {\n        this.rawSet.jointConfigureBallMotorVelocity(this.handle, targetVel.x, targetVel.y, targetVel.z, factor);\n    }\n\n    public configureMotorPosition(targetPos: Quaternion, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotorPosition(this.handle, targetPos.w, targetPos.x, targetPos.y, targetPos.z, stiffness, damping);\n    }\n\n    public configureMotor(targetPos: Quaternion, targetVel: Vector, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotor(this.handle,\n            targetPos.w, targetPos.x, targetPos.y, targetPos.z,\n            targetVel.x, targetVel.y, targetVel.z,\n            stiffness, damping);\n    }\n     */\n}\n// #endif\n\nexport class JointData {\n    anchor1: Vector;\n    anchor2: Vector;\n    axis: Vector;\n    frame1: Rotation;\n    frame2: Rotation;\n    jointType: JointType;\n    limitsEnabled: boolean;\n    limits: Array<number>;\n    axesMask: JointAxesMask;\n    stiffness: number;\n    damping: number;\n    length: number;\n\n    private constructor() {}\n\n    /**\n     * Creates a new joint descriptor that builds a Fixed joint.\n     *\n     * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their\n     * anchor and local frames coincide in world-space.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.\n     */\n    public static fixed(\n        anchor1: Vector,\n        frame1: Rotation,\n        anchor2: Vector,\n        frame2: Rotation,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.frame1 = frame1;\n        res.frame2 = frame2;\n        res.jointType = JointType.Fixed;\n        return res;\n    }\n\n    public static spring(\n        rest_length: number,\n        stiffness: number,\n        damping: number,\n        anchor1: Vector,\n        anchor2: Vector,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.length = rest_length;\n        res.stiffness = stiffness;\n        res.damping = damping;\n        res.jointType = JointType.Spring;\n        return res;\n    }\n\n    public static rope(\n        length: number,\n        anchor1: Vector,\n        anchor2: Vector,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.length = length;\n        res.jointType = JointType.Rope;\n        return res;\n    }\n\n\n    // #if DIM3\n    /**\n     * Create a new joint descriptor that builds generic joints.\n     *\n     * A generic joint allows customizing its degrees of freedom\n     * by supplying a mask of the joint axes that should remain locked.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - The X axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     * @param axesMask - Mask representing the locked axes of the joint. You can use logical OR to select these from\n     *                   the JointAxesMask enum. For example, passing (JointAxesMask.AngX || JointAxesMask.AngY) will\n     *                   create a joint locked in the X and Y rotational axes.\n     */\n    public static generic(\n        anchor1: Vector,\n        anchor2: Vector,\n        axis: Vector,\n        axesMask: JointAxesMask,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.axesMask = axesMask;\n        res.jointType = JointType.Generic;\n        return res;\n    }\n\n    /**\n     * Create a new joint descriptor that builds spherical joints.\n     *\n     * A spherical joint allows three relative rotational degrees of freedom\n     * by preventing any relative translation between the anchors of the\n     * two attached rigid-bodies.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     */\n    public static spherical(anchor1: Vector, anchor2: Vector): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.jointType = JointType.Spherical;\n        return res;\n    }\n\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    public static prismatic(\n        anchor1: Vector,\n        anchor2: Vector,\n        axis: Vector,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Prismatic;\n        return res;\n    }\n\n    /**\n     * Create a new joint descriptor that builds Revolute joints.\n     *\n     * A revolute joint removes all degrees of freedom between the affected\n     * bodies except for the rotation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    public static revolute(\n        anchor1: Vector,\n        anchor2: Vector,\n        axis: Vector,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Revolute;\n        return res;\n    }\n    // #endif\n\n    public intoRaw(): RawGenericJoint {\n        let rawA1 = VectorOps.intoRaw(this.anchor1);\n        let rawA2 = VectorOps.intoRaw(this.anchor2);\n        let rawAx;\n        let result;\n        let limitsEnabled = false;\n        let limitsMin = 0.0;\n        let limitsMax = 0.0;\n\n        switch (this.jointType) {\n            case JointType.Fixed:\n                let rawFra1 = RotationOps.intoRaw(this.frame1);\n                let rawFra2 = RotationOps.intoRaw(this.frame2);\n                result = RawGenericJoint.fixed(rawA1, rawFra1, rawA2, rawFra2);\n                rawFra1.free();\n                rawFra2.free();\n                break;\n            case JointType.Spring:\n                result = RawGenericJoint.spring(\n                    this.length,\n                    this.stiffness,\n                    this.damping,\n                    rawA1,\n                    rawA2,\n                );\n                break;\n            case JointType.Rope:\n                result = RawGenericJoint.rope(this.length, rawA1, rawA2);\n                break;\n            case JointType.Prismatic:\n                rawAx = VectorOps.intoRaw(this.axis);\n\n                if (!!this.limitsEnabled) {\n                    limitsEnabled = true;\n                    limitsMin = this.limits[0];\n                    limitsMax = this.limits[1];\n                }\n\n\n                // #if DIM3\n                result = RawGenericJoint.prismatic(\n                    rawA1,\n                    rawA2,\n                    rawAx,\n                    limitsEnabled,\n                    limitsMin,\n                    limitsMax,\n                );\n                // #endif\n\n                rawAx.free();\n                break;\n            // #if DIM3\n            case JointType.Generic:\n                rawAx = VectorOps.intoRaw(this.axis);\n                // implicit type cast: axesMask is a JointAxesMask bitflag enum,\n                // we're treating it as a u8 on the Rust side\n                let rawAxesMask = this.axesMask;\n                result = RawGenericJoint.generic(\n                    rawA1,\n                    rawA2,\n                    rawAx,\n                    rawAxesMask,\n                );\n                break;\n            case JointType.Spherical:\n                result = RawGenericJoint.spherical(rawA1, rawA2);\n                break;\n            case JointType.Revolute:\n                rawAx = VectorOps.intoRaw(this.axis);\n                result = RawGenericJoint.revolute(rawA1, rawA2, rawAx);\n                rawAx.free();\n                break;\n            // #endif\n        }\n\n        rawA1.free();\n        rawA2.free();\n\n        return result;\n    }\n}\n", "import {RawImpulseJointSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RigidBodySet} from \"./rigid_body_set\";\nimport {\n    RevoluteImpulseJoint,\n    FixedImpulseJoint,\n    ImpulseJoint,\n    ImpulseJointHandle,\n    JointData,\n    JointType,\n    PrismaticImpulseJoint,\n    // #if DIM3\n    SphericalImpulseJoint,\n    // #endif\n} from \"./impulse_joint\";\nimport {IslandManager} from \"./island_manager\";\nimport {RigidBodyHandle} from \"./rigid_body\";\nimport {Collider, ColliderHandle} from \"../geometry\";\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class ImpulseJointSet {\n    raw: RawImpulseJointSet;\n    private map: Coarena<ImpulseJoint>;\n\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawImpulseJointSet) {\n        this.raw = raw || new RawImpulseJointSet();\n        this.map = new Coarena<ImpulseJoint>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle: ImpulseJointHandle) => {\n                this.map.set(handle, ImpulseJoint.newTyped(raw, null, handle));\n            });\n        }\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        this.map.forEach((joint) => joint.finalizeDeserialization(bodies));\n    }\n\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param bodies - The set of rigid-bodies containing the bodies the joint is attached to.\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createJoint(\n        bodies: RigidBodySet,\n        desc: JointData,\n        parent1: RigidBodyHandle,\n        parent2: RigidBodyHandle,\n        wakeUp: boolean,\n    ): ImpulseJoint {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(\n            rawParams,\n            parent1,\n            parent2,\n            wakeUp,\n        );\n        rawParams.free();\n        let joint = ImpulseJoint.newTyped(this.raw, bodies, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wakeUp - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    public remove(handle: ImpulseJointHandle, wakeUp: boolean) {\n        this.raw.remove(handle, wakeUp);\n        this.unmap(handle);\n    }\n\n    /**\n     * Calls the given closure with the integer handle of each impulse joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each impulse joint attached to the rigid-body.\n     */\n    public forEachJointHandleAttachedToRigidBody(\n        handle: RigidBodyHandle,\n        f: (handle: ImpulseJointHandle) => void,\n    ) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: ImpulseJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of joints on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    public contains(handle: ImpulseJointHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    public get(handle: ImpulseJointHandle): ImpulseJoint | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (joint: ImpulseJoint) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    public getAll(): ImpulseJoint[] {\n        return this.map.getAll();\n    }\n}\n", "import {\n    RawImpulseJointSet,\n    RawJointAxis,\n    RawJointType,\n    RawMultibodyJointSet,\n} from \"../raw\";\nimport {\n    FixedImpulseJoint,\n    ImpulseJointHandle,\n    JointType,\n    MotorModel,\n    PrismaticImpulseJoint,\n    RevoluteImpulseJoint,\n} from \"./impulse_joint\";\n\n// #if DIM3\nimport {Quaternion} from \"../math\";\nimport {SphericalImpulseJoint} from \"./impulse_joint\";\n// #endif\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type MultibodyJointHandle = number;\n\nexport class MultibodyJoint {\n    protected rawSet: RawMultibodyJointSet; // The MultibodyJoint won't need to free this.\n    handle: MultibodyJointHandle;\n\n    constructor(rawSet: RawMultibodyJointSet, handle: MultibodyJointHandle) {\n        this.rawSet = rawSet;\n        this.handle = handle;\n    }\n\n    public static newTyped(\n        rawSet: RawMultibodyJointSet,\n        handle: MultibodyJointHandle,\n    ): MultibodyJoint {\n        switch (rawSet.jointType(handle)) {\n            case RawJointType.Revolute:\n                return new RevoluteMultibodyJoint(rawSet, handle);\n            case RawJointType.Prismatic:\n                return new PrismaticMultibodyJoint(rawSet, handle);\n            case RawJointType.Fixed:\n                return new FixedMultibodyJoint(rawSet, handle);\n            // #if DIM3\n            case RawJointType.Spherical:\n                return new SphericalMultibodyJoint(rawSet, handle);\n            // #endif\n            default:\n                return new MultibodyJoint(rawSet, handle);\n        }\n    }\n\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    // /**\n    //  * The unique integer identifier of the first rigid-body this joint it attached to.\n    //  */\n    // public bodyHandle1(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle1(this.handle);\n    // }\n    //\n    // /**\n    //  * The unique integer identifier of the second rigid-body this joint is attached to.\n    //  */\n    // public bodyHandle2(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle2(this.handle);\n    // }\n    //\n    // /**\n    //  * The type of this joint given as a string.\n    //  */\n    // public type(): JointType {\n    //     return this.rawSet.jointType(this.handle);\n    // }\n    //\n    // // #if DIM3\n    // /**\n    //  * The rotation quaternion that aligns this joint's first local axis to the `x` axis.\n    //  */\n    // public frameX1(): Rotation {\n    //     return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));\n    // }\n    //\n    // // #endif\n    //\n    // // #if DIM3\n    // /**\n    //  * The rotation matrix that aligns this joint's second local axis to the `x` axis.\n    //  */\n    // public frameX2(): Rotation {\n    //     return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));\n    // }\n    //\n    // // #endif\n    //\n    // /**\n    //  * The position of the first anchor of this joint.\n    //  *\n    //  * The first anchor gives the position of the points application point on the\n    //  * local frame of the first rigid-body it is attached to.\n    //  */\n    // public anchor1(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    // }\n    //\n    // /**\n    //  * The position of the second anchor of this joint.\n    //  *\n    //  * The second anchor gives the position of the points application point on the\n    //  * local frame of the second rigid-body it is attached to.\n    //  */\n    // public anchor2(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    // }\n\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public setContactsEnabled(enabled: boolean) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public contactsEnabled(): boolean {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\n\nexport class UnitMultibodyJoint extends MultibodyJoint {\n    /**\n     * The axis left free by this joint.\n     */\n    protected rawAxis?(): RawJointAxis;\n\n    // /**\n    //  * Are the limits enabled for this joint?\n    //  */\n    // public limitsEnabled(): boolean {\n    //     return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    // }\n    //\n    // /**\n    //  * The min limit of this joint.\n    //  */\n    // public limitsMin(): number {\n    //     return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    // }\n    //\n    // /**\n    //  * The max limit of this joint.\n    //  */\n    // public limitsMax(): number {\n    //     return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    // }\n    //\n    // public configureMotorModel(model: MotorModel) {\n    //     this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), model);\n    // }\n    //\n    // public configureMotorVelocity(targetVel: number, factor: number) {\n    //     this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), targetVel, factor);\n    // }\n    //\n    // public configureMotorPosition(targetPos: number, stiffness: number, damping: number) {\n    //     this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), targetPos, stiffness, damping);\n    // }\n    //\n    // public configureMotor(targetPos: number, targetVel: number, stiffness: number, damping: number) {\n    //     this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), targetPos, targetVel, stiffness, damping);\n    // }\n}\n\nexport class FixedMultibodyJoint extends MultibodyJoint {}\n\nexport class PrismaticMultibodyJoint extends UnitMultibodyJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.LinX;\n    }\n}\n\nexport class RevoluteMultibodyJoint extends UnitMultibodyJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.AngX;\n    }\n}\n\n// #if DIM3\nexport class SphericalMultibodyJoint extends MultibodyJoint {\n    /* Unsupported by this alpha release.\n    public configureMotorModel(model: MotorModel) {\n        this.rawSet.jointConfigureMotorModel(this.handle, model);\n    }\n\n    public configureMotorVelocity(targetVel: Vector, factor: number) {\n        this.rawSet.jointConfigureBallMotorVelocity(this.handle, targetVel.x, targetVel.y, targetVel.z, factor);\n    }\n\n    public configureMotorPosition(targetPos: Quaternion, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotorPosition(this.handle, targetPos.w, targetPos.x, targetPos.y, targetPos.z, stiffness, damping);\n    }\n\n    public configureMotor(targetPos: Quaternion, targetVel: Vector, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotor(this.handle,\n            targetPos.w, targetPos.x, targetPos.y, targetPos.z,\n            targetVel.x, targetVel.y, targetVel.z,\n            stiffness, damping);\n    }\n     */\n}\n// #endif\n", "import {RawMultibodyJointSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RigidBodySet} from \"./rigid_body_set\";\nimport {\n    MultibodyJoint,\n    MultibodyJointHandle,\n    RevoluteMultibodyJoint,\n    FixedMultibodyJoint,\n    PrismaticMultibodyJoint,\n    // #if DIM3\n    SphericalMultibodyJoint,\n    // #endif\n} from \"./multibody_joint\";\nimport {ImpulseJointHandle, JointData, JointType} from \"./impulse_joint\";\nimport {IslandManager} from \"./island_manager\";\nimport {ColliderHandle} from \"../geometry\";\nimport {RigidBodyHandle} from \"./rigid_body\";\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class MultibodyJointSet {\n    raw: RawMultibodyJointSet;\n    private map: Coarena<MultibodyJoint>;\n\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawMultibodyJointSet) {\n        this.raw = raw || new RawMultibodyJointSet();\n        this.map = new Coarena<MultibodyJoint>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle: MultibodyJointHandle) => {\n                this.map.set(handle, MultibodyJoint.newTyped(this.raw, handle));\n            });\n        }\n    }\n\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createJoint(\n        desc: JointData,\n        parent1: RigidBodyHandle,\n        parent2: RigidBodyHandle,\n        wakeUp: boolean,\n    ): MultibodyJoint {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(\n            rawParams,\n            parent1,\n            parent2,\n            wakeUp,\n        );\n        rawParams.free();\n        let joint = MultibodyJoint.newTyped(this.raw, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wake_up - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    public remove(handle: MultibodyJointHandle, wake_up: boolean) {\n        this.raw.remove(handle, wake_up);\n        this.map.delete(handle);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: MultibodyJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of joints on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    public contains(handle: MultibodyJointHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    public get(handle: MultibodyJointHandle): MultibodyJoint | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (joint: MultibodyJoint) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Calls the given closure with the integer handle of each multibody joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each multibody joint attached to the rigid-body.\n     */\n    public forEachJointHandleAttachedToRigidBody(\n        handle: RigidBodyHandle,\n        f: (handle: MultibodyJointHandle) => void,\n    ) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    public getAll(): MultibodyJoint[] {\n        return this.map.getAll();\n    }\n}\n", "/**\n * A rule applied to combine coefficients.\n *\n * Use this when configuring the `ColliderDesc` to specify\n * how friction and restitution coefficient should be combined\n * in a contact.\n */\nexport enum CoefficientCombineRule {\n    Average = 0,\n    Min = 1,\n    Multiply = 2,\n    Max = 3,\n}\n", "import {RawCCDSolver} from \"../raw\";\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class CCDSolver {\n    raw: RawCCDSolver;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawCCDSolver) {\n        this.raw = raw || new RawCCDSolver();\n    }\n}\n", "import {RawIslandManager} from \"../raw\";\nimport {RigidBodyHandle} from \"./rigid_body\";\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class IslandManager {\n    raw: RawIslandManager;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawIslandManager) {\n        this.raw = raw || new RawIslandManager();\n    }\n\n    /**\n     * Applies the given closure to the handle of each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachActiveRigidBodyHandle(f: (handle: RigidBodyHandle) => void) {\n        this.raw.forEachActiveRigidBodyHandle(f);\n    }\n}\n", "import {RawBroadPhase} from \"../raw\";\n\n/**\n * The broad-phase used for coarse collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `broadPhase.free()`\n * once you are done using it.\n */\nexport class BroadPhase {\n    raw: RawBroadPhase;\n\n    /**\n     * Release the WASM memory occupied by this broad-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawBroadPhase) {\n        this.raw = raw || new RawBroadPhase();\n    }\n}\n", "import {RawNarrowPhase, RawContactManifold} from \"../raw\";\nimport {ColliderHandle} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\n\n/**\n * The narrow-phase used for precise collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `narrowPhase.free()`\n * once you are done using it.\n */\nexport class NarrowPhase {\n    raw: RawNarrowPhase;\n    tempManifold: TempContactManifold;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawNarrowPhase) {\n        this.raw = raw || new RawNarrowPhase();\n        this.tempManifold = new TempContactManifold(null);\n    }\n\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    public contactPairsWith(\n        collider1: ColliderHandle,\n        f: (collider2: ColliderHandle) => void,\n    ) {\n        this.raw.contact_pairs_with(collider1, f);\n    }\n\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    public intersectionPairsWith(\n        collider1: ColliderHandle,\n        f: (collider2: ColliderHandle) => void,\n    ) {\n        this.raw.intersection_pairs_with(collider1, f);\n    }\n\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    public contactPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        f: (manifold: TempContactManifold, flipped: boolean) => void,\n    ) {\n        const rawPair = this.raw.contact_pair(collider1, collider2);\n\n        if (!!rawPair) {\n            const flipped = rawPair.collider1() != collider1;\n\n            let i;\n            for (i = 0; i < rawPair.numContactManifolds(); ++i) {\n                this.tempManifold.raw = rawPair.contactManifold(i);\n                if (!!this.tempManifold.raw) {\n                    f(this.tempManifold, flipped);\n                }\n\n                // SAFETY: The RawContactManifold stores a raw pointer that will be invalidated\n                //         at the next timestep. So we must be sure to free the pair here\n                //         to avoid unsoundness in the Rust code.\n                this.tempManifold.free();\n            }\n            rawPair.free();\n        }\n    }\n\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1  The first collider involved in the intersection.\n     * @param collider2  The second collider involved in the intersection.\n     */\n    public intersectionPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n    ): boolean {\n        return this.raw.intersection_pair(collider1, collider2);\n    }\n}\n\nexport class TempContactManifold {\n    raw: RawContactManifold;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw: RawContactManifold) {\n        this.raw = raw;\n    }\n\n    public normal(): Vector {\n        return VectorOps.fromRaw(this.raw.normal());\n    }\n\n    public localNormal1(): Vector {\n        return VectorOps.fromRaw(this.raw.local_n1());\n    }\n\n    public localNormal2(): Vector {\n        return VectorOps.fromRaw(this.raw.local_n2());\n    }\n\n    public subshape1(): number {\n        return this.raw.subshape1();\n    }\n\n    public subshape2(): number {\n        return this.raw.subshape2();\n    }\n\n    public numContacts(): number {\n        return this.raw.num_contacts();\n    }\n\n    public localContactPoint1(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.contact_local_p1(i));\n    }\n\n    public localContactPoint2(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.contact_local_p2(i));\n    }\n\n    public contactDist(i: number): number {\n        return this.raw.contact_dist(i);\n    }\n\n    public contactFid1(i: number): number {\n        return this.raw.contact_fid1(i);\n    }\n\n    public contactFid2(i: number): number {\n        return this.raw.contact_fid2(i);\n    }\n\n    public contactImpulse(i: number): number {\n        return this.raw.contact_impulse(i);\n    }\n\n\n    // #if DIM3\n    public contactTangentImpulseX(i: number): number {\n        return this.raw.contact_tangent_impulse_x(i);\n    }\n\n    public contactTangentImpulseY(i: number): number {\n        return this.raw.contact_tangent_impulse_y(i);\n    }\n    // #endif\n\n    public numSolverContacts(): number {\n        return this.raw.num_solver_contacts();\n    }\n\n    public solverContactPoint(i: number): Vector {\n        return VectorOps.fromRaw(this.raw.solver_contact_point(i));\n    }\n\n    public solverContactDist(i: number): number {\n        return this.raw.solver_contact_dist(i);\n    }\n\n    public solverContactFriction(i: number): number {\n        return this.raw.solver_contact_friction(i);\n    }\n\n    public solverContactRestitution(i: number): number {\n        return this.raw.solver_contact_restitution(i);\n    }\n\n    public solverContactTangentVelocity(i: number): Vector {\n        return VectorOps.fromRaw(this.raw.solver_contact_tangent_velocity(i));\n    }\n}\n", "import {Vector, VectorOps} from \"../math\";\nimport {RawShapeContact} from \"../raw\";\n\n/**\n * The contact info between two shapes.\n */\nexport class ShapeContact {\n    /**\n     * Distance between the two contact points.\n     * If this is negative, this contact represents a penetration.\n     */\n    distance: number;\n\n    /**\n     * Position of the contact on the first shape.\n     */\n    point1: Vector;\n\n    /**\n     * Position of the contact on the second shape.\n     */\n    point2: Vector;\n\n    /**\n     * Contact normal, pointing towards the exterior of the first shape.\n     */\n    normal1: Vector;\n\n    /**\n     * Contact normal, pointing towards the exterior of the second shape.\n     * If these contact data are expressed in world-space, this normal is equal to -normal1.\n     */\n    normal2: Vector;\n\n    constructor(\n        dist: number,\n        point1: Vector,\n        point2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        this.distance = dist;\n        this.point1 = point1;\n        this.point2 = point2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n\n    public static fromRaw(raw: RawShapeContact): ShapeContact {\n        if (!raw) return null;\n\n        const result = new ShapeContact(\n            raw.distance(),\n            VectorOps.fromRaw(raw.point1()),\n            VectorOps.fromRaw(raw.point2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n", "\n// #if DIM3\nexport enum FeatureType {\n    Vertex,\n    Edge,\n    Face,\n    Unknown,\n}\n// #endif\n", "import {Collider, ColliderHandle} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    RawFeatureType,\n    RawPointColliderProjection,\n    RawPointProjection,\n} from \"../raw\";\nimport {FeatureType} from \"./feature\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * The projection of a point on a collider.\n */\nexport class PointProjection {\n    /**\n     * The projection of the point on the collider.\n     */\n    point: Vector;\n    /**\n     * Is the point inside of the collider?\n     */\n    isInside: boolean;\n\n    constructor(point: Vector, isInside: boolean) {\n        this.point = point;\n        this.isInside = isInside;\n    }\n\n    public static fromRaw(raw: RawPointProjection): PointProjection {\n        if (!raw) return null;\n\n        const result = new PointProjection(\n            VectorOps.fromRaw(raw.point()),\n            raw.isInside(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The projection of a point on a collider (includes the collider handle).\n */\nexport class PointColliderProjection {\n    /**\n     * The collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The projection of the point on the collider.\n     */\n    point: Vector;\n    /**\n     * Is the point inside of the collider?\n     */\n    isInside: boolean;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        collider: Collider,\n        point: Vector,\n        isInside: boolean,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.collider = collider;\n        this.point = point;\n        this.isInside = isInside;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawPointColliderProjection,\n    ): PointColliderProjection {\n        if (!raw) return null;\n\n        const result = new PointColliderProjection(\n            colliderSet.get(raw.colliderHandle()),\n            VectorOps.fromRaw(raw.point()),\n            raw.isInside(),\n            raw.featureType() as number as FeatureType,\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n", "import {Vector, VectorOps} from \"../math\";\nimport {\n    RawFeatureType,\n    RawRayColliderIntersection,\n    RawRayColliderHit,\n    RawRayIntersection,\n} from \"../raw\";\nimport {Collider} from \"./collider\";\nimport {FeatureType} from \"./feature\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * A ray. This is a directed half-line.\n */\nexport class Ray {\n    /**\n     * The starting point of the ray.\n     */\n    public origin: Vector;\n    /**\n     * The direction of propagation of the ray.\n     */\n    public dir: Vector;\n\n    /**\n     * Builds a ray from its origin and direction.\n     *\n     * @param origin - The ray's starting point.\n     * @param dir - The ray's direction of propagation.\n     */\n    constructor(origin: Vector, dir: Vector) {\n        this.origin = origin;\n        this.dir = dir;\n    }\n\n    public pointAt(t: number): Vector {\n        return {\n            x: this.origin.x + this.dir.x * t,\n            y: this.origin.y + this.dir.y * t,\n            // #if DIM3\n            z: this.origin.z + this.dir.z * t,\n            // #endif\n        };\n    }\n}\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class RayIntersection {\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * timeOfImpact`.\n     */\n    timeOfImpact: number;\n    /**\n     * The normal of the collider at the hit point.\n     */\n    normal: Vector;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        timeOfImpact: number,\n        normal: Vector,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.timeOfImpact = timeOfImpact;\n        this.normal = normal;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(raw: RawRayIntersection): RayIntersection {\n        if (!raw) return null;\n\n        const result = new RayIntersection(\n            raw.time_of_impact(),\n            VectorOps.fromRaw(raw.normal()),\n            raw.featureType() as number as FeatureType,\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The intersection between a ray and a collider (includes the collider handle).\n */\nexport class RayColliderIntersection {\n    /**\n     * The collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * timeOfImpact`.\n     */\n    timeOfImpact: number;\n    /**\n     * The normal of the collider at the hit point.\n     */\n    normal: Vector;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        collider: Collider,\n        timeOfImpact: number,\n        normal: Vector,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.collider = collider;\n        this.timeOfImpact = timeOfImpact;\n        this.normal = normal;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawRayColliderIntersection,\n    ): RayColliderIntersection {\n        if (!raw) return null;\n\n        const result = new RayColliderIntersection(\n            colliderSet.get(raw.colliderHandle()),\n            raw.time_of_impact(),\n            VectorOps.fromRaw(raw.normal()),\n            raw.featureType() as number as FeatureType,\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The time of impact between a ray and a collider.\n */\nexport class RayColliderHit {\n    /**\n     * The handle of the collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * timeOfImpact`.\n     */\n    timeOfImpact: number;\n\n    constructor(collider: Collider, timeOfImpact: number) {\n        this.collider = collider;\n        this.timeOfImpact = timeOfImpact;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawRayColliderHit,\n    ): RayColliderHit {\n        if (!raw) return null;\n\n        const result = new RayColliderHit(\n            colliderSet.get(raw.colliderHandle()),\n            raw.timeOfImpact(),\n        );\n        raw.free();\n        return result;\n    }\n}\n", "import {Collider} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\nimport {RawShapeCastHit, RawColliderShapeCastHit} from \"../raw\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeCastHit {\n    /**\n     * The time of impact of the two shapes.\n     */\n    time_of_impact: number;\n    /**\n     * The local-space contact point on the first shape, at\n     * the time of impact.\n     */\n    witness1: Vector;\n    /**\n     * The local-space contact point on the second shape, at\n     * the time of impact.\n     */\n    witness2: Vector;\n    /**\n     * The local-space normal on the first shape, at\n     * the time of impact.\n     */\n    normal1: Vector;\n    /**\n     * The local-space normal on the second shape, at\n     * the time of impact.\n     */\n    normal2: Vector;\n\n    constructor(\n        time_of_impact: number,\n        witness1: Vector,\n        witness2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        this.time_of_impact = time_of_impact;\n        this.witness1 = witness1;\n        this.witness2 = witness2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawShapeCastHit,\n    ): ShapeCastHit {\n        if (!raw) return null;\n\n        const result = new ShapeCastHit(\n            raw.time_of_impact(),\n            VectorOps.fromRaw(raw.witness1()),\n            VectorOps.fromRaw(raw.witness2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class ColliderShapeCastHit extends ShapeCastHit {\n    /**\n     * The handle of the collider hit by the ray.\n     */\n    collider: Collider;\n\n    constructor(\n        collider: Collider,\n        time_of_impact: number,\n        witness1: Vector,\n        witness2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        super(time_of_impact, witness1, witness2, normal1, normal2);\n        this.collider = collider;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawColliderShapeCastHit,\n    ): ColliderShapeCastHit {\n        if (!raw) return null;\n\n        const result = new ColliderShapeCastHit(\n            colliderSet.get(raw.colliderHandle()),\n            raw.time_of_impact(),\n            VectorOps.fromRaw(raw.witness1()),\n            VectorOps.fromRaw(raw.witness2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n", "import {Vector, VectorOps, Rotation, RotationOps} from \"../math\";\nimport {RawColliderSet, RawShape, RawShapeType} from \"../raw\";\nimport {ShapeContact} from \"./contact\";\nimport {PointProjection} from \"./point\";\nimport {Ray, RayIntersection} from \"./ray\";\nimport {ShapeCastHit} from \"./toi\";\nimport {ColliderHandle} from \"./collider\";\n\nexport abstract class Shape {\n    public abstract intoRaw(): RawShape;\n\n    /**\n     * The concrete type of this shape.\n     */\n    public abstract get type(): ShapeType;\n\n    /**\n     * instant mode without cache\n     */\n    public static fromRaw(\n        rawSet: RawColliderSet,\n        handle: ColliderHandle,\n    ): Shape {\n        const rawType = rawSet.coShapeType(handle);\n\n        let extents: Vector;\n        let borderRadius: number;\n        let vs: Float32Array;\n        let indices: Uint32Array;\n        let halfHeight: number;\n        let radius: number;\n        let normal: Vector;\n\n        switch (rawType) {\n            case RawShapeType.Ball:\n                return new Ball(rawSet.coRadius(handle));\n            case RawShapeType.Cuboid:\n                extents = rawSet.coHalfExtents(handle);\n\n                // #if DIM3\n                return new Cuboid(extents.x, extents.y, extents.z);\n            // #endif\n\n            case RawShapeType.RoundCuboid:\n                extents = rawSet.coHalfExtents(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n\n\n                // #if DIM3\n                return new RoundCuboid(\n                    extents.x,\n                    extents.y,\n                    extents.z,\n                    borderRadius,\n                );\n            // #endif\n\n            case RawShapeType.Capsule:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Capsule(halfHeight, radius);\n            case RawShapeType.Segment:\n                vs = rawSet.coVertices(handle);\n\n\n                // #if DIM3\n                return new Segment(\n                    VectorOps.new(vs[0], vs[1], vs[2]),\n                    VectorOps.new(vs[3], vs[4], vs[5]),\n                );\n            // #endif\n\n            case RawShapeType.Polyline:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new Polyline(vs, indices);\n            case RawShapeType.Triangle:\n                vs = rawSet.coVertices(handle);\n\n\n                // #if DIM3\n                return new Triangle(\n                    VectorOps.new(vs[0], vs[1], vs[2]),\n                    VectorOps.new(vs[3], vs[4], vs[5]),\n                    VectorOps.new(vs[6], vs[7], vs[8]),\n                );\n            // #endif\n\n            case RawShapeType.RoundTriangle:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n\n\n                // #if DIM3\n                return new RoundTriangle(\n                    VectorOps.new(vs[0], vs[1], vs[2]),\n                    VectorOps.new(vs[3], vs[4], vs[5]),\n                    VectorOps.new(vs[6], vs[7], vs[8]),\n                    borderRadius,\n                );\n            // #endif\n\n            case RawShapeType.HalfSpace:\n                normal = VectorOps.fromRaw(rawSet.coHalfspaceNormal(handle));\n                return new HalfSpace(normal);\n\n            case RawShapeType.TriMesh:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                const tri_flags = rawSet.coTriMeshFlags(handle);\n                return new TriMesh(vs, indices, tri_flags);\n\n            case RawShapeType.HeightField:\n                const scale = rawSet.coHeightfieldScale(handle);\n                const heights = rawSet.coHeightfieldHeights(handle);\n\n\n                // #if DIM3\n                const nrows = rawSet.coHeightfieldNRows(handle);\n                const ncols = rawSet.coHeightfieldNCols(handle);\n                const hf_flags = rawSet.coHeightFieldFlags(handle);\n                return new Heightfield(nrows, ncols, heights, scale, hf_flags);\n            // #endif\n\n\n            // #if DIM3\n            case RawShapeType.ConvexPolyhedron:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new ConvexPolyhedron(vs, indices);\n            case RawShapeType.RoundConvexPolyhedron:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundConvexPolyhedron(vs, indices, borderRadius);\n            case RawShapeType.Cylinder:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Cylinder(halfHeight, radius);\n            case RawShapeType.RoundCylinder:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundCylinder(halfHeight, radius, borderRadius);\n            case RawShapeType.Cone:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Cone(halfHeight, radius);\n            case RawShapeType.RoundCone:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundCone(halfHeight, radius, borderRadius);\n            // #endif\n\n            default:\n                throw new Error(\"unknown shape type: \" + rawType);\n        }\n    }\n\n    /**\n     * Computes the time of impact between two moving shapes.\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shapeVel1 - The velocity of this shape.\n     * @param shape2 - The second moving shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param shapeVel2 - The velocity of the second shape.\n     * @param targetDistance  If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time when the impact can happen.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exit that penetration state.\n     * @returns If the two moving shapes collider at some point along their trajectories, this returns the\n     *  time at which the two shape collider as well as the contact information during the impact. Returns\n     *  `null`if the two shapes never collide along their paths.\n     */\n    public castShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shapeVel1: Vector,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n        shapeVel2: Vector,\n        targetDistance: number,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ShapeCastHit | null {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawVel1 = VectorOps.intoRaw(shapeVel1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawVel2 = VectorOps.intoRaw(shapeVel2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeCastHit.fromRaw(\n            null,\n            rawShape1.castShape(\n                rawPos1,\n                rawRot1,\n                rawVel1,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                rawVel2,\n                targetDistance,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawVel1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawVel2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Tests if this shape intersects another shape.\n     *\n     * @param shapePos1 - The position of this shape.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2  - The second shape to test.\n     * @param shapePos2 - The position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @returns `true` if the two shapes intersect, `false` if they dont.\n     */\n    public intersectsShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n    ): boolean {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = rawShape1.intersectsShape(\n            rawPos1,\n            rawRot1,\n            rawShape2,\n            rawPos2,\n            rawRot2,\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between two shapes.\n     *\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2 - The second shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n        prediction: number,\n    ): ShapeContact | null {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeContact.fromRaw(\n            rawShape1.contactShape(\n                rawPos1,\n                rawRot1,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                prediction,\n            ),\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    containsPoint(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        point: Vector,\n    ): boolean {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.containsPoint(rawPos, rawRot, rawPoint);\n\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    projectPoint(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        point: Vector,\n        solid: boolean,\n    ): PointProjection {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n\n        let result = PointProjection.fromRaw(\n            rawShape.projectPoint(rawPos, rawRot, rawPoint, solid),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    intersectsRay(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n    ): boolean {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.intersectsRay(\n            rawPos,\n            rawRot,\n            rawRayOrig,\n            rawRayDir,\n            maxToi,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    castRay(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n        solid: boolean,\n    ): number {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.castRay(\n            rawPos,\n            rawRot,\n            rawRayOrig,\n            rawRayDir,\n            maxToi,\n            solid,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    castRayAndGetNormal(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n        solid: boolean,\n    ): RayIntersection {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = RayIntersection.fromRaw(\n            rawShape.castRayAndGetNormal(\n                rawPos,\n                rawRot,\n                rawRayOrig,\n                rawRayDir,\n                maxToi,\n                solid,\n            ),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n}\n\n\n// #if DIM3\n\n/**\n * An enumeration representing the type of a shape.\n */\nexport enum ShapeType {\n    Ball = 0,\n    Cuboid = 1,\n    Capsule = 2,\n    Segment = 3,\n    Polyline = 4,\n    Triangle = 5,\n    TriMesh = 6,\n    HeightField = 7,\n    // Compound = 8,\n    ConvexPolyhedron = 9,\n    Cylinder = 10,\n    Cone = 11,\n    RoundCuboid = 12,\n    RoundTriangle = 13,\n    RoundCylinder = 14,\n    RoundCone = 15,\n    RoundConvexPolyhedron = 16,\n    HalfSpace = 17,\n}\n\n// NOTE: this **must** match the bits in the HeightFieldFlags on the rust side.\n/**\n * Flags controlling the behavior of some operations involving heightfields.\n */\nexport enum HeightFieldFlags {\n    /**\n     * If set, a special treatment will be applied to contact manifold calculation to eliminate\n     * or fix contacts normals that could lead to incorrect bumps in physics simulation (especially\n     * on flat surfaces).\n     *\n     * This is achieved by taking into account adjacent triangle normals when computing contact\n     * points for a given triangle.\n     */\n    FIX_INTERNAL_EDGES = 0b0000_0001,\n}\n\n// #endif\n\n// NOTE: this **must** match the TriMeshFlags on the rust side.\n/**\n * Flags controlling the behavior of the triangle mesh creation and of some\n * operations involving triangle meshes.\n */\nexport enum TriMeshFlags {\n    // NOTE: these two flags are not really useful in JS.\n    //\n    // /**\n    //  * If set, the half-edge topology of the trimesh will be computed if possible.\n    //  */\n    // HALF_EDGE_TOPOLOGY = 0b0000_0001,\n    // /** If set, the half-edge topology and connected components of the trimesh will be computed if possible.\n    //  *\n    //  * Because of the way it is currently implemented, connected components can only be computed on\n    //  * a mesh where the half-edge topology computation succeeds. It will no longer be the case in the\n    //  * future once we decouple the computations.\n    //  */\n    // CONNECTED_COMPONENTS = 0b0000_0010,\n    /**\n     * If set, any triangle that results in a failing half-hedge topology computation will be deleted.\n     */\n    DELETE_BAD_TOPOLOGY_TRIANGLES = 0b0000_0100,\n    /**\n     * If set, the trimesh will be assumed to be oriented (with outward normals).\n     *\n     * The pseudo-normals of its vertices and edges will be computed.\n     */\n    ORIENTED = 0b0000_1000,\n    /**\n     * If set, the duplicate vertices of the trimesh will be merged.\n     *\n     * Two vertices with the exact same coordinates will share the same entry on the\n     * vertex buffer and the index buffer is adjusted accordingly.\n     */\n    MERGE_DUPLICATE_VERTICES = 0b0001_0000,\n    /**\n     * If set, the triangles sharing two vertices with identical index values will be removed.\n     *\n     * Because of the way it is currently implemented, this methods implies that duplicate\n     * vertices will be merged. It will no longer be the case in the future once we decouple\n     * the computations.\n     */\n    DELETE_DEGENERATE_TRIANGLES = 0b0010_0000,\n    /**\n     * If set, two triangles sharing three vertices with identical index values (in any order)\n     * will be removed.\n     *\n     * Because of the way it is currently implemented, this methods implies that duplicate\n     * vertices will be merged. It will no longer be the case in the future once we decouple\n     * the computations.\n     */\n    DELETE_DUPLICATE_TRIANGLES = 0b0100_0000,\n    /**\n     * If set, a special treatment will be applied to contact manifold calculation to eliminate\n     * or fix contacts normals that could lead to incorrect bumps in physics simulation\n     * (especially on flat surfaces).\n     *\n     * This is achieved by taking into account adjacent triangle normals when computing contact\n     * points for a given triangle.\n     *\n     * /!\\ NOT SUPPORTED IN THE 2D VERSION OF RAPIER.\n     */\n    FIX_INTERNAL_EDGES = 0b1000_0000 |\n        TriMeshFlags.ORIENTED |\n        TriMeshFlags.MERGE_DUPLICATE_VERTICES,\n}\n\n/**\n * A shape that is a sphere in 3D and a circle in 2D.\n */\nexport class Ball extends Shape {\n    readonly type = ShapeType.Ball;\n\n    /**\n     * The balls radius.\n     */\n    radius: number;\n\n    /**\n     * Creates a new ball with the given radius.\n     * @param radius - The balls radius.\n     */\n    constructor(radius: number) {\n        super();\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.ball(this.radius);\n    }\n}\n\nexport class HalfSpace extends Shape {\n    readonly type = ShapeType.HalfSpace;\n\n    /**\n     * The outward normal of the half-space.\n     */\n    normal: Vector;\n\n    /**\n     * Creates a new halfspace delimited by an infinite plane.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n    constructor(normal: Vector) {\n        super();\n        this.normal = normal;\n    }\n\n    public intoRaw(): RawShape {\n        let n = VectorOps.intoRaw(this.normal);\n        let result = RawShape.halfspace(n);\n        n.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a box in 3D and a rectangle in 2D.\n */\nexport class Cuboid extends Shape {\n    readonly type = ShapeType.Cuboid;\n\n    /**\n     * The half extent of the cuboid along each coordinate axis.\n     */\n    halfExtents: Vector;\n\n\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     */\n    constructor(hx: number, hy: number, hz: number) {\n        super();\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n    }\n\n    // #endif\n\n    public intoRaw(): RawShape {\n\n        // #if DIM3\n        return RawShape.cuboid(\n            this.halfExtents.x,\n            this.halfExtents.y,\n            this.halfExtents.z,\n        );\n        // #endif\n    }\n}\n\n/**\n * A shape that is a box in 3D and a rectangle in 2D, with round corners.\n */\nexport class RoundCuboid extends Shape {\n    readonly type = ShapeType.RoundCuboid;\n\n    /**\n     * The half extent of the cuboid along each coordinate axis.\n     */\n    halfExtents: Vector;\n\n    /**\n     * The radius of the cuboid's round border.\n     */\n    borderRadius: number;\n\n\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     * @param borderRadius - The radius of the borders of this cuboid. This will\n     *   effectively increase the half-extents of the cuboid by this radius.\n     */\n    constructor(hx: number, hy: number, hz: number, borderRadius: number) {\n        super();\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n        this.borderRadius = borderRadius;\n    }\n\n    // #endif\n\n    public intoRaw(): RawShape {\n\n        // #if DIM3\n        return RawShape.roundCuboid(\n            this.halfExtents.x,\n            this.halfExtents.y,\n            this.halfExtents.z,\n            this.borderRadius,\n        );\n        // #endif\n    }\n}\n\n/**\n * A shape that is a capsule.\n */\nexport class Capsule extends Shape {\n    readonly type = ShapeType.Capsule;\n\n    /**\n     * The radius of the capsule's basis.\n     */\n    radius: number;\n\n    /**\n     * The capsule's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * Creates a new capsule with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight: number, radius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.capsule(this.halfHeight, this.radius);\n    }\n}\n\n/**\n * A shape that is a segment.\n */\nexport class Segment extends Shape {\n    readonly type = ShapeType.Segment;\n\n    /**\n     * The first point of the segment.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the segment.\n     */\n    b: Vector;\n\n    /**\n     * Creates a new segment shape.\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    constructor(a: Vector, b: Vector) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let result = RawShape.segment(ra, rb);\n        ra.free();\n        rb.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a segment.\n */\nexport class Triangle extends Shape {\n    readonly type = ShapeType.Triangle;\n\n    /**\n     * The first point of the triangle.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    b: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    c: Vector;\n\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    constructor(a: Vector, b: Vector, c: Vector) {\n        super();\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.triangle(ra, rb, rc);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a triangle with round borders and a non-zero thickness.\n */\nexport class RoundTriangle extends Shape {\n    readonly type = ShapeType.RoundTriangle;\n\n    /**\n     * The first point of the triangle.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    b: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    c: Vector;\n\n    /**\n     * The radius of the triangles's rounded edges and vertices.\n     * In 3D, this is also equal to half the thickness of the round triangle.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    constructor(a: Vector, b: Vector, c: Vector, borderRadius: number) {\n        super();\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.borderRadius = borderRadius;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.roundTriangle(ra, rb, rc, this.borderRadius);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a triangle mesh.\n */\nexport class Polyline extends Shape {\n    readonly type = ShapeType.Polyline;\n\n    /**\n     * The vertices of the polyline.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the segments.\n     */\n    indices: Uint32Array;\n\n    /**\n     * Creates a new polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `null` or not provided, then\n     *    the vertices are assumed to form a line strip.\n     */\n    constructor(vertices: Float32Array, indices?: Uint32Array) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices ?? new Uint32Array(0);\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.polyline(this.vertices, this.indices);\n    }\n}\n\n/**\n * A shape that is a triangle mesh.\n */\nexport class TriMesh extends Shape {\n    readonly type = ShapeType.TriMesh;\n\n    /**\n     * The vertices of the triangle mesh.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the triangles.\n     */\n    indices: Uint32Array;\n\n    /**\n     * The triangle mesh flags.\n     */\n    flags: TriMeshFlags;\n\n    /**\n     * Creates a new triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    constructor(\n        vertices: Float32Array,\n        indices: Uint32Array,\n        flags?: TriMeshFlags,\n    ) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices;\n        this.flags = flags;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.trimesh(this.vertices, this.indices, this.flags);\n    }\n}\n\n\n// #if DIM3\n/**\n * A shape that is a convex polygon.\n */\nexport class ConvexPolyhedron extends Shape {\n    readonly type = ShapeType.ConvexPolyhedron;\n\n    /**\n     * The vertices of the convex polygon.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the convex polygon.\n     */\n    indices?: Uint32Array | null;\n\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     */\n    constructor(vertices: Float32Array, indices?: Uint32Array | null) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices;\n    }\n\n    public intoRaw(): RawShape {\n        if (!!this.indices) {\n            return RawShape.convexMesh(this.vertices, this.indices);\n        } else {\n            return RawShape.convexHull(this.vertices);\n        }\n    }\n}\n\n/**\n * A shape that is a convex polygon.\n */\nexport class RoundConvexPolyhedron extends Shape {\n    readonly type = ShapeType.RoundConvexPolyhedron;\n\n    /**\n     * The vertices of the convex polygon.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the convex polygon.\n     */\n    indices?: Uint32Array;\n\n    /**\n     * The radius of the convex polyhedron's rounded edges and vertices.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     * @param borderRadius - The radius of the borders of this convex polyhedron.\n     */\n    constructor(\n        vertices: Float32Array,\n        indices: Uint32Array | null | undefined,\n        borderRadius: number,\n    ) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices;\n        this.borderRadius = borderRadius;\n    }\n\n    public intoRaw(): RawShape {\n        if (!!this.indices) {\n            return RawShape.roundConvexMesh(\n                this.vertices,\n                this.indices,\n                this.borderRadius,\n            );\n        } else {\n            return RawShape.roundConvexHull(this.vertices, this.borderRadius);\n        }\n    }\n}\n\n/**\n * A shape that is a heightfield.\n */\nexport class Heightfield extends Shape {\n    readonly type = ShapeType.HeightField;\n\n    /**\n     * The number of rows in the heights matrix.\n     */\n    nrows: number;\n\n    /**\n     * The number of columns in the heights matrix.\n     */\n    ncols: number;\n\n    /**\n     * The heights of the heightfield along its local `y` axis,\n     * provided as a matrix stored in column-major order.\n     */\n    heights: Float32Array;\n\n    /**\n     * The dimensions of the heightfield's local `x,z` plane.\n     */\n    scale: Vector;\n\n    /**\n     * Flags applied to the heightfield.\n     */\n    flags: HeightFieldFlags;\n\n    /**\n     * Creates a new heightfield shape.\n     *\n     * @param nrows  The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The dimensions of the heightfield's local `x,z` plane.\n     */\n    constructor(\n        nrows: number,\n        ncols: number,\n        heights: Float32Array,\n        scale: Vector,\n        flags?: HeightFieldFlags,\n    ) {\n        super();\n        this.nrows = nrows;\n        this.ncols = ncols;\n        this.heights = heights;\n        this.scale = scale;\n        this.flags = flags;\n    }\n\n    public intoRaw(): RawShape {\n        let rawScale = VectorOps.intoRaw(this.scale);\n        let rawShape = RawShape.heightfield(\n            this.nrows,\n            this.ncols,\n            this.heights,\n            rawScale,\n            this.flags,\n        );\n        rawScale.free();\n        return rawShape;\n    }\n}\n\n/**\n * A shape that is a 3D cylinder.\n */\nexport class Cylinder extends Shape {\n    readonly type = ShapeType.Cylinder;\n\n    /**\n     * The radius of the cylinder's basis.\n     */\n    radius: number;\n\n    /**\n     * The cylinder's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight: number, radius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.cylinder(this.halfHeight, this.radius);\n    }\n}\n\n/**\n * A shape that is a 3D cylinder with round corners.\n */\nexport class RoundCylinder extends Shape {\n    readonly type = ShapeType.RoundCylinder;\n\n    /**\n     * The radius of the cylinder's basis.\n     */\n    radius: number;\n\n    /**\n     * The cylinder's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * The radius of the cylinder's rounded edges and vertices.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cylinder.\n     */\n    constructor(halfHeight: number, radius: number, borderRadius: number) {\n        super();\n        this.borderRadius = borderRadius;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.roundCylinder(\n            this.halfHeight,\n            this.radius,\n            this.borderRadius,\n        );\n    }\n}\n\n/**\n * A shape that is a 3D cone.\n */\nexport class Cone extends Shape {\n    readonly type = ShapeType.Cone;\n\n    /**\n     * The radius of the cone's basis.\n     */\n    radius: number;\n\n    /**\n     * The cone's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight: number, radius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.cone(this.halfHeight, this.radius);\n    }\n}\n\n/**\n * A shape that is a 3D cone with round corners.\n */\nexport class RoundCone extends Shape {\n    readonly type = ShapeType.RoundCone;\n\n    /**\n     * The radius of the cone's basis.\n     */\n    radius: number;\n\n    /**\n     * The cone's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * The radius of the cylinder's rounded edges and vertices.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cone.\n     */\n    constructor(halfHeight: number, radius: number, borderRadius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n        this.borderRadius = borderRadius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.roundCone(\n            this.halfHeight,\n            this.radius,\n            this.borderRadius,\n        );\n    }\n}\n\n// #endif\n", "import {RawPhysicsPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodyHandle,\n    RigidBodySet,\n    CCDSolver,\n    IslandManager,\n} from \"../dynamics\";\nimport {\n    BroadPhase,\n    ColliderHandle,\n    ColliderSet,\n    NarrowPhase,\n} from \"../geometry\";\nimport {EventQueue} from \"./event_queue\";\nimport {PhysicsHooks} from \"./physics_hooks\";\n\nexport class PhysicsPipeline {\n    raw: RawPhysicsPipeline;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawPhysicsPipeline) {\n        this.raw = raw || new RawPhysicsPipeline();\n    }\n\n    public step(\n        gravity: Vector,\n        integrationParameters: IntegrationParameters,\n        islands: IslandManager,\n        broadPhase: BroadPhase,\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n        ccdSolver: CCDSolver,\n        eventQueue?: EventQueue,\n        hooks?: PhysicsHooks,\n    ) {\n        let rawG = VectorOps.intoRaw(gravity);\n\n        if (!!eventQueue) {\n            this.raw.stepWithEvents(\n                rawG,\n                integrationParameters.raw,\n                islands.raw,\n                broadPhase.raw,\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                impulseJoints.raw,\n                multibodyJoints.raw,\n                ccdSolver.raw,\n                eventQueue.raw,\n                hooks,\n                !!hooks ? hooks.filterContactPair : null,\n                !!hooks ? hooks.filterIntersectionPair : null,\n            );\n        } else {\n            this.raw.step(\n                rawG,\n                integrationParameters.raw,\n                islands.raw,\n                broadPhase.raw,\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                impulseJoints.raw,\n                multibodyJoints.raw,\n                ccdSolver.raw,\n            );\n        }\n\n        rawG.free();\n    }\n}\n", "import {RawQueryPipeline, RawRayColliderIntersection} from \"../raw\";\nimport {\n    ColliderHandle,\n    ColliderSet,\n    InteractionGroups,\n    PointColliderProjection,\n    Ray,\n    RayColliderIntersection,\n    RayColliderHit,\n    Shape,\n    ColliderShapeCastHit,\n} from \"../geometry\";\nimport {IslandManager, RigidBodyHandle, RigidBodySet} from \"../dynamics\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\n\n// NOTE: must match the bits in the QueryFilterFlags on the Rust side.\n/**\n * Flags for excluding whole sets of colliders from a scene query.\n */\nexport enum QueryFilterFlags {\n    /**\n     * Exclude from the query any collider attached to a fixed rigid-body and colliders with no rigid-body attached.\n     */\n    EXCLUDE_FIXED = 0b0000_0001,\n    /**\n     * Exclude from the query any collider attached to a dynamic rigid-body.\n     */\n    EXCLUDE_KINEMATIC = 0b0000_0010,\n    /**\n     * Exclude from the query any collider attached to a kinematic rigid-body.\n     */\n    EXCLUDE_DYNAMIC = 0b0000_0100,\n    /**\n     * Exclude from the query any collider that is a sensor.\n     */\n    EXCLUDE_SENSORS = 0b0000_1000,\n    /**\n     * Exclude from the query any collider that is not a sensor.\n     */\n    EXCLUDE_SOLIDS = 0b0001_0000,\n    /**\n     * Excludes all colliders not attached to a dynamic rigid-body.\n     */\n    ONLY_DYNAMIC = QueryFilterFlags.EXCLUDE_FIXED |\n        QueryFilterFlags.EXCLUDE_KINEMATIC,\n    /**\n     * Excludes all colliders not attached to a kinematic rigid-body.\n     */\n    ONLY_KINEMATIC = QueryFilterFlags.EXCLUDE_DYNAMIC |\n        QueryFilterFlags.EXCLUDE_FIXED,\n    /**\n     * Exclude all colliders attached to a non-fixed rigid-body\n     * (this will not exclude colliders not attached to any rigid-body).\n     */\n    ONLY_FIXED = QueryFilterFlags.EXCLUDE_DYNAMIC |\n        QueryFilterFlags.EXCLUDE_KINEMATIC,\n}\n\n/**\n * A pipeline for performing queries on all the colliders of a scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class QueryPipeline {\n    raw: RawQueryPipeline;\n\n    /**\n     * Release the WASM memory occupied by this query pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawQueryPipeline) {\n        this.raw = raw || new RawQueryPipeline();\n    }\n\n    /**\n     * Updates the acceleration structure of the query pipeline.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     */\n    public update(colliders: ColliderSet) {\n        this.raw.update(colliders.raw);\n    }\n\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    public castRay(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): RayColliderHit | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderHit.fromRaw(\n            colliders,\n            this.raw.castRay(\n                bodies.raw,\n                colliders.raw,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    public castRayAndGetNormal(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): RayColliderIntersection | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderIntersection.fromRaw(\n            colliders,\n            this.raw.castRayAndGetNormal(\n                bodies.raw,\n                colliders.raw,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    public intersectionsWithRay(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        callback: (intersect: RayColliderIntersection) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let rawCallback = (rawInter: RawRayColliderIntersection) => {\n            return callback(\n                RayColliderIntersection.fromRaw(colliders, rawInter),\n            );\n        };\n\n        this.raw.intersectionsWithRay(\n            bodies.raw,\n            colliders.raw,\n            rawOrig,\n            rawDir,\n            maxToi,\n            solid,\n            rawCallback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n    }\n\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    public intersectionWithShape(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): ColliderHandle | null {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        let result = this.raw.intersectionWithShape(\n            bodies.raw,\n            colliders.raw,\n            rawPos,\n            rawRot,\n            rawShape,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPoint(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): PointColliderProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(\n            colliders,\n            this.raw.projectPoint(\n                bodies.raw,\n                colliders.raw,\n                rawPoint,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPointAndGetFeature(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): PointColliderProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(\n            colliders,\n            this.raw.projectPointAndGetFeature(\n                bodies.raw,\n                colliders.raw,\n                rawPoint,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    public intersectionsWithPoint(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        callback: (handle: ColliderHandle) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawPoint = VectorOps.intoRaw(point);\n\n        this.raw.intersectionsWithPoint(\n            bodies.raw,\n            colliders.raw,\n            rawPoint,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPoint.free();\n    }\n\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param targetDistance  If the shape moves closer to this distance from a collider, a hit\n     *                       will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exit that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    public castShape(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shapeVel: Vector,\n        shape: Shape,\n        targetDistance: number,\n        maxToi: number,\n        stopAtPenetration: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): ColliderShapeCastHit | null {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawVel = VectorOps.intoRaw(shapeVel);\n        let rawShape = shape.intoRaw();\n\n        let result = ColliderShapeCastHit.fromRaw(\n            colliders,\n            this.raw.castShape(\n                bodies.raw,\n                colliders.raw,\n                rawPos,\n                rawRot,\n                rawVel,\n                rawShape,\n                targetDistance,\n                maxToi,\n                stopAtPenetration,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawVel.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    public intersectionsWithShape(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        callback: (handle: ColliderHandle) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n\n        this.raw.intersectionsWithShape(\n            bodies.raw,\n            colliders.raw,\n            rawPos,\n            rawRot,\n            rawShape,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n    }\n\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    public collidersWithAabbIntersectingAabb(\n        aabbCenter: Vector,\n        aabbHalfExtents: Vector,\n        callback: (handle: ColliderHandle) => boolean,\n    ) {\n        let rawCenter = VectorOps.intoRaw(aabbCenter);\n        let rawHalfExtents = VectorOps.intoRaw(aabbHalfExtents);\n        this.raw.collidersWithAabbIntersectingAabb(\n            rawCenter,\n            rawHalfExtents,\n            callback,\n        );\n        rawCenter.free();\n        rawHalfExtents.free();\n    }\n}\n", "import {RawSerializationPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {BroadPhase, ColliderSet, NarrowPhase} from \"../geometry\";\nimport {World} from \"./world\";\n\n/**\n * A pipeline for serializing the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class SerializationPipeline {\n    raw: RawSerializationPipeline;\n\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawSerializationPipeline) {\n        this.raw = raw || new RawSerializationPipeline();\n    }\n\n    /**\n     * Serialize a complete physics state into a single byte array.\n     * @param gravity - The current gravity affecting the simulation.\n     * @param integrationParameters - The integration parameters of the simulation.\n     * @param broadPhase - The broad-phase of the simulation.\n     * @param narrowPhase - The narrow-phase of the simulation.\n     * @param bodies - The rigid-bodies taking part into the simulation.\n     * @param colliders - The colliders taking part into the simulation.\n     * @param impulseJoints - The impulse joints taking part into the simulation.\n     * @param multibodyJoints - The multibody joints taking part into the simulation.\n     */\n    public serializeAll(\n        gravity: Vector,\n        integrationParameters: IntegrationParameters,\n        islands: IslandManager,\n        broadPhase: BroadPhase,\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n    ): Uint8Array {\n        let rawGra = VectorOps.intoRaw(gravity);\n\n        const res = this.raw.serializeAll(\n            rawGra,\n            integrationParameters.raw,\n            islands.raw,\n            broadPhase.raw,\n            narrowPhase.raw,\n            bodies.raw,\n            colliders.raw,\n            impulseJoints.raw,\n            multibodyJoints.raw,\n        );\n        rawGra.free();\n\n        return res;\n    }\n\n    /**\n     * Deserialize the complete physics state from a single byte array.\n     *\n     * @param data - The byte array to deserialize.\n     */\n    public deserializeAll(data: Uint8Array): World {\n        return World.fromRaw(this.raw.deserializeAll(data));\n    }\n}\n", "import {RawDebugRenderPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {BroadPhase, ColliderSet, NarrowPhase} from \"../geometry\";\n\n/**\n * The vertex and color buffers for debug-redering the physics scene.\n */\nexport class DebugRenderBuffers {\n    /**\n     * The lines to render. This is a flat array containing all the lines\n     * to render. Each line is described as two consecutive point. Each\n     * point is described as two (in 2D) or three (in 3D) consecutive\n     * floats. For example, in 2D, the array: `[1, 2, 3, 4, 5, 6, 7, 8]`\n     * describes the two segments `[[1, 2], [3, 4]]` and `[[5, 6], [7, 8]]`.\n     */\n    public vertices: Float32Array;\n    /**\n     * The color buffer. There is one color per vertex, and each color\n     * has four consecutive components (in RGBA format).\n     */\n    public colors: Float32Array;\n\n    constructor(vertices: Float32Array, colors: Float32Array) {\n        this.vertices = vertices;\n        this.colors = colors;\n    }\n}\n\n/**\n * A pipeline for rendering the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `debugRenderPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class DebugRenderPipeline {\n    raw: RawDebugRenderPipeline;\n    public vertices: Float32Array;\n    public colors: Float32Array;\n\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        this.vertices = undefined;\n        this.colors = undefined;\n    }\n\n    constructor(raw?: RawDebugRenderPipeline) {\n        this.raw = raw || new RawDebugRenderPipeline();\n    }\n\n    public render(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulse_joints: ImpulseJointSet,\n        multibody_joints: MultibodyJointSet,\n        narrow_phase: NarrowPhase,\n    ) {\n        this.raw.render(\n            bodies.raw,\n            colliders.raw,\n            impulse_joints.raw,\n            multibody_joints.raw,\n            narrow_phase.raw,\n        );\n        this.vertices = this.raw.vertices();\n        this.colors = this.raw.colors();\n    }\n}\n", "import {RawKinematicCharacterController, RawCharacterCollision} from \"../raw\";\nimport {Rotation, Vector, VectorOps} from \"../math\";\nimport {Collider, ColliderSet, InteractionGroups, Shape} from \"../geometry\";\nimport {QueryFilterFlags, QueryPipeline, World} from \"../pipeline\";\nimport {IntegrationParameters, RigidBody, RigidBodySet} from \"../dynamics\";\n\n/**\n * A collision between the character and an obstacle hit on its path.\n */\nexport class CharacterCollision {\n    /** The collider involved in the collision. Null if the collider no longer exists in the physics world. */\n    public collider: Collider | null;\n    /** The translation delta applied to the character before this collision took place. */\n    public translationDeltaApplied: Vector;\n    /** The translation delta the character would move after this collision if there is no other obstacles. */\n    public translationDeltaRemaining: Vector;\n    /** The time-of-impact between the character and the obstacles. */\n    public toi: number;\n    /** The world-space contact point on the collider when the collision happens. */\n    public witness1: Vector;\n    /** The local-space contact point on the character when the collision happens. */\n    public witness2: Vector;\n    /** The world-space outward contact normal on the collider when the collision happens. */\n    public normal1: Vector;\n    /** The local-space outward contact normal on the character when the collision happens. */\n    public normal2: Vector;\n}\n\n/**\n * A character controller for controlling kinematic bodies and parentless colliders by hitting\n * and sliding against obstacles.\n */\nexport class KinematicCharacterController {\n    private raw: RawKinematicCharacterController;\n    private rawCharacterCollision: RawCharacterCollision;\n\n    private params: IntegrationParameters;\n    private bodies: RigidBodySet;\n    private colliders: ColliderSet;\n    private queries: QueryPipeline;\n    private _applyImpulsesToDynamicBodies: boolean;\n    private _characterMass: number | null;\n\n    constructor(\n        offset: number,\n        params: IntegrationParameters,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        queries: QueryPipeline,\n    ) {\n        this.params = params;\n        this.bodies = bodies;\n        this.colliders = colliders;\n        this.queries = queries;\n        this.raw = new RawKinematicCharacterController(offset);\n        this.rawCharacterCollision = new RawCharacterCollision();\n        this._applyImpulsesToDynamicBodies = false;\n        this._characterMass = null;\n    }\n\n    /** @internal */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n            this.rawCharacterCollision.free();\n        }\n\n        this.raw = undefined;\n        this.rawCharacterCollision = undefined;\n    }\n\n    /**\n     * The direction that goes \"up\". Used to determine where the floor is, and the floors angle.\n     */\n    public up(): Vector {\n        return this.raw.up();\n    }\n\n    /**\n     * Sets the direction that goes \"up\". Used to determine where the floor is, and the floors angle.\n     */\n    public setUp(vector: Vector) {\n        let rawVect = VectorOps.intoRaw(vector);\n        return this.raw.setUp(rawVect);\n        rawVect.free();\n    }\n\n    public applyImpulsesToDynamicBodies(): boolean {\n        return this._applyImpulsesToDynamicBodies;\n    }\n\n    public setApplyImpulsesToDynamicBodies(enabled: boolean) {\n        this._applyImpulsesToDynamicBodies = enabled;\n    }\n\n    /**\n     * Returns the custom value of the character mass, if it was set by `this.setCharacterMass`.\n     */\n    public characterMass(): number | null {\n        return this._characterMass;\n    }\n\n    /**\n     * Set the mass of the character to be used for impulse resolution if `self.applyImpulsesToDynamicBodies`\n     * is set to `true`.\n     *\n     * If no character mass is set explicitly (or if it is set to `null`) it is automatically assumed to be equal\n     * to the mass of the rigid-body the character collider is attached to; or equal to 0 if the character collider\n     * isnt attached to any rigid-body.\n     *\n     * @param mass - The mass to set.\n     */\n    public setCharacterMass(mass: number | null) {\n        this._characterMass = mass;\n    }\n\n    /**\n     * A small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldnt be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    public offset(): number {\n        return this.raw.offset();\n    }\n\n    /**\n     * Sets a small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldnt be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    public setOffset(value: number) {\n        this.raw.setOffset(value);\n    }\n\n    /// Increase this number if your character appears to get stuck when sliding against surfaces.\n    ///\n    /// This is a small distance applied to the movement toward the contact normals of shapes hit\n    /// by the character controller. This helps shape-casting not getting stuck in an always-penetrating\n    /// state during the sliding calculation.\n    ///\n    /// This value should remain fairly small since it can introduce artificial \"bumps\" when sliding\n    /// along a flat surface.\n    public normalNudgeFactor(): number {\n        return this.raw.normalNudgeFactor();\n    }\n\n    /// Increase this number if your character appears to get stuck when sliding against surfaces.\n    ///\n    /// This is a small distance applied to the movement toward the contact normals of shapes hit\n    /// by the character controller. This helps shape-casting not getting stuck in an always-penetrating\n    /// state during the sliding calculation.\n    ///\n    /// This value should remain fairly small since it can introduce artificial \"bumps\" when sliding\n    /// along a flat surface.\n    public setNormalNudgeFactor(value: number) {\n        this.raw.setNormalNudgeFactor(value);\n    }\n\n    /**\n     * Is sliding against obstacles enabled?\n     */\n    public slideEnabled(): boolean {\n        return this.raw.slideEnabled();\n    }\n\n    /**\n     * Enable or disable sliding against obstacles.\n     */\n    public setSlideEnabled(enabled: boolean) {\n        this.raw.setSlideEnabled(enabled);\n    }\n\n    /**\n     * The maximum step height a character can automatically step over.\n     */\n    public autostepMaxHeight(): number | null {\n        return this.raw.autostepMaxHeight();\n    }\n\n    /**\n     * The minimum width of free space that must be available after stepping on a stair.\n     */\n    public autostepMinWidth(): number | null {\n        return this.raw.autostepMinWidth();\n    }\n\n    /**\n     * Can the character automatically step over dynamic bodies too?\n     */\n    public autostepIncludesDynamicBodies(): boolean | null {\n        return this.raw.autostepIncludesDynamicBodies();\n    }\n\n    /**\n     * Is automatically stepping over small objects enabled?\n     */\n    public autostepEnabled(): boolean {\n        return this.raw.autostepEnabled();\n    }\n\n    /**\n     * Enabled automatically stepping over small objects.\n     *\n     * @param maxHeight - The maximum step height a character can automatically step over.\n     * @param minWidth - The minimum width of free space that must be available after stepping on a stair.\n     * @param includeDynamicBodies - Can the character automatically step over dynamic bodies too?\n     */\n    public enableAutostep(\n        maxHeight: number,\n        minWidth: number,\n        includeDynamicBodies: boolean,\n    ) {\n        this.raw.enableAutostep(maxHeight, minWidth, includeDynamicBodies);\n    }\n\n    /**\n     * Disable automatically stepping over small objects.\n     */\n    public disableAutostep() {\n        return this.raw.disableAutostep();\n    }\n\n    /**\n     * The maximum angle (radians) between the floors normal and the `up` vector that the\n     * character is able to climb.\n     */\n    public maxSlopeClimbAngle(): number {\n        return this.raw.maxSlopeClimbAngle();\n    }\n\n    /**\n     * Sets the maximum angle (radians) between the floors normal and the `up` vector that the\n     * character is able to climb.\n     */\n    public setMaxSlopeClimbAngle(angle: number) {\n        this.raw.setMaxSlopeClimbAngle(angle);\n    }\n\n    /**\n     * The minimum angle (radians) between the floors normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    public minSlopeSlideAngle(): number {\n        return this.raw.minSlopeSlideAngle();\n    }\n\n    /**\n     * Sets the minimum angle (radians) between the floors normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    public setMinSlopeSlideAngle(angle: number) {\n        this.raw.setMinSlopeSlideAngle(angle);\n    }\n\n    /**\n     * If snap-to-ground is enabled, should the character be automatically snapped to the ground if\n     * the distance between the ground and its feet are smaller than the specified threshold?\n     */\n    public snapToGroundDistance(): number | null {\n        return this.raw.snapToGroundDistance();\n    }\n\n    /**\n     * Enables automatically snapping the character to the ground if the distance between\n     * the ground and its feet are smaller than the specified threshold.\n     */\n    public enableSnapToGround(distance: number) {\n        this.raw.enableSnapToGround(distance);\n    }\n\n    /**\n     * Disables automatically snapping the character to the ground.\n     */\n    public disableSnapToGround() {\n        this.raw.disableSnapToGround();\n    }\n\n    /**\n     * Is automatically snapping the character to the ground enabled?\n     */\n    public snapToGroundEnabled(): boolean {\n        return this.raw.snapToGroundEnabled();\n    }\n\n    /**\n     * Computes the movement the given collider is able to execute after hitting and sliding on obstacles.\n     *\n     * @param collider - The collider to move.\n     * @param desiredTranslationDelta - The desired collider movement.\n     * @param filterFlags - Flags for excluding whole subsets of colliders from the obstacles taken into account.\n     * @param filterGroups - Groups for excluding colliders with incompatible collision groups from the obstacles\n     *                       taken into account.\n     * @param filterPredicate - Any collider for which this closure returns `false` will be excluded from the\n     *                          obstacles taken into account.\n     */\n    public computeColliderMovement(\n        collider: Collider,\n        desiredTranslationDelta: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        let rawTranslationDelta = VectorOps.intoRaw(desiredTranslationDelta);\n        this.raw.computeColliderMovement(\n            this.params.dt,\n            this.bodies.raw,\n            this.colliders.raw,\n            this.queries.raw,\n            collider.handle,\n            rawTranslationDelta,\n            this._applyImpulsesToDynamicBodies,\n            this._characterMass,\n            filterFlags,\n            filterGroups,\n            this.colliders.castClosure(filterPredicate),\n        );\n        rawTranslationDelta.free();\n    }\n\n    /**\n     * The movement computed by the last call to `this.computeColliderMovement`.\n     */\n    public computedMovement(): Vector {\n        return VectorOps.fromRaw(this.raw.computedMovement());\n    }\n\n    /**\n     * The result of ground detection computed by the last call to `this.computeColliderMovement`.\n     */\n    public computedGrounded(): boolean {\n        return this.raw.computedGrounded();\n    }\n\n    /**\n     * The number of collisions against obstacles detected along the path of the last call\n     * to `this.computeColliderMovement`.\n     */\n    public numComputedCollisions(): number {\n        return this.raw.numComputedCollisions();\n    }\n\n    /**\n     * Returns the collision against one of the obstacles detected along the path of the last\n     * call to `this.computeColliderMovement`.\n     *\n     * @param i - The i-th collision will be returned.\n     * @param out - If this argument is set, it will be filled with the collision information.\n     */\n    public computedCollision(\n        i: number,\n        out?: CharacterCollision,\n    ): CharacterCollision | null {\n        if (!this.raw.computedCollision(i, this.rawCharacterCollision)) {\n            return null;\n        } else {\n            let c = this.rawCharacterCollision;\n            out = out ?? new CharacterCollision();\n            out.translationDeltaApplied = VectorOps.fromRaw(\n                c.translationDeltaApplied(),\n            );\n            out.translationDeltaRemaining = VectorOps.fromRaw(\n                c.translationDeltaRemaining(),\n            );\n            out.toi = c.toi();\n            out.witness1 = VectorOps.fromRaw(c.worldWitness1());\n            out.witness2 = VectorOps.fromRaw(c.worldWitness2());\n            out.normal1 = VectorOps.fromRaw(c.worldNormal1());\n            out.normal2 = VectorOps.fromRaw(c.worldNormal2());\n            out.collider = this.colliders.get(c.handle());\n            return out;\n        }\n    }\n}\n", "import {RawPidController} from \"../raw\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\nimport {Collider, ColliderSet, InteractionGroups, Shape} from \"../geometry\";\nimport {QueryFilterFlags, QueryPipeline, World} from \"../pipeline\";\nimport {IntegrationParameters, RigidBody, RigidBodySet} from \"../dynamics\";\n\n// TODO: unify with the JointAxesMask\n/**\n * An enum representing the possible joint axes controlled by a PidController.\n * They can be ORed together, like:\n * PidAxesMask.LinX || PidAxesMask.LinY\n * to get a pid controller that only constraints the translational X and Y axes.\n *\n * Possible axes are:\n *\n * - `X`: X translation axis\n * - `Y`: Y translation axis\n * - `Z`: Z translation axis\n * - `AngX`: X angular rotation axis (3D only)\n * - `AngY`: Y angular rotation axis (3D only)\n * - `AngZ`: Z angular rotation axis\n */\nexport enum PidAxesMask {\n    None = 0,\n    LinX = 1 << 0,\n    LinY = 1 << 1,\n    LinZ = 1 << 2,\n    // #if DIM3\n    AngX = 1 << 3,\n    AngY = 1 << 4,\n    // #endif\n    AngZ = 1 << 5,\n    // #if DIM3\n    AllLin = PidAxesMask.LinX | PidAxesMask.LinY | PidAxesMask.LinZ,\n    AllAng = PidAxesMask.AngX | PidAxesMask.AngY | PidAxesMask.AngZ,\n    // #endif\n    All = PidAxesMask.AllLin | PidAxesMask.AllAng,\n}\n\n/**\n * A controller for controlling dynamic bodies using the\n * Proportional-Integral-Derivative correction model.\n */\nexport class PidController {\n    private raw: RawPidController;\n\n    private params: IntegrationParameters;\n    private bodies: RigidBodySet;\n\n    constructor(\n        params: IntegrationParameters,\n        bodies: RigidBodySet,\n        kp: number,\n        ki: number,\n        kd: number,\n        axes: PidAxesMask,\n    ) {\n        this.params = params;\n        this.bodies = bodies;\n        this.raw = new RawPidController(kp, ki, kd, axes);\n    }\n\n    /** @internal */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n\n        this.raw = undefined;\n    }\n\n    public setKp(kp: number, axes: PidAxesMask) {\n        this.raw.set_kp(kp, axes);\n    }\n\n    public setKi(ki: number, axes: PidAxesMask) {\n        this.raw.set_kp(ki, axes);\n    }\n\n    public setKd(kd: number, axes: PidAxesMask) {\n        this.raw.set_kp(kd, axes);\n    }\n\n    public setAxes(axes: PidAxesMask) {\n        this.raw.set_axes_mask(axes);\n    }\n\n    public resetIntegrals() {\n        this.raw.reset_integrals();\n    }\n\n    public applyLinearCorrection(\n        body: RigidBody,\n        targetPosition: Vector,\n        targetLinvel: Vector,\n    ) {\n        let rawPos = VectorOps.intoRaw(targetPosition);\n        let rawVel = VectorOps.intoRaw(targetLinvel);\n        this.raw.apply_linear_correction(\n            this.params.dt,\n            this.bodies.raw,\n            body.handle,\n            rawPos,\n            rawVel,\n        );\n        rawPos.free();\n        rawVel.free();\n    }\n\n\n    // #if DIM3\n    public applyAngularCorrection(\n        body: RigidBody,\n        targetRotation: Rotation,\n        targetAngVel: Vector,\n    ) {\n        let rawPos = RotationOps.intoRaw(targetRotation);\n        let rawVel = VectorOps.intoRaw(targetAngVel);\n        this.raw.apply_angular_correction(\n            this.params.dt,\n            this.bodies.raw,\n            body.handle,\n            rawPos,\n            rawVel,\n        );\n        rawPos.free();\n        rawVel.free();\n    }\n    // #endif\n\n    public linearCorrection(\n        body: RigidBody,\n        targetPosition: Vector,\n        targetLinvel: Vector,\n    ): Vector {\n        let rawPos = VectorOps.intoRaw(targetPosition);\n        let rawVel = VectorOps.intoRaw(targetLinvel);\n        let correction = this.raw.linear_correction(\n            this.params.dt,\n            this.bodies.raw,\n            body.handle,\n            rawPos,\n            rawVel,\n        );\n        rawPos.free();\n        rawVel.free();\n\n        return VectorOps.fromRaw(correction);\n    }\n\n\n    // #if DIM3\n    public angularCorrection(\n        body: RigidBody,\n        targetRotation: Rotation,\n        targetAngVel: Vector,\n    ): Vector {\n        let rawPos = RotationOps.intoRaw(targetRotation);\n        let rawVel = VectorOps.intoRaw(targetAngVel);\n        let correction = this.raw.angular_correction(\n            this.params.dt,\n            this.bodies.raw,\n            body.handle,\n            rawPos,\n            rawVel,\n        );\n        rawPos.free();\n        rawVel.free();\n\n        return VectorOps.fromRaw(correction);\n    }\n    // #endif\n}\n", "import {RawDynamicRayCastVehicleController} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {Collider, ColliderSet, InteractionGroups} from \"../geometry\";\nimport {QueryFilterFlags, QueryPipeline} from \"../pipeline\";\nimport {RigidBody, RigidBodyHandle, RigidBodySet} from \"../dynamics\";\n\n/**\n * A character controller to simulate vehicles using ray-casting for the wheels.\n */\nexport class DynamicRayCastVehicleController {\n    private raw: RawDynamicRayCastVehicleController;\n    private bodies: RigidBodySet;\n    private colliders: ColliderSet;\n    private queries: QueryPipeline;\n    private _chassis: RigidBody;\n\n    constructor(\n        chassis: RigidBody,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        queries: QueryPipeline,\n    ) {\n        this.raw = new RawDynamicRayCastVehicleController(chassis.handle);\n        this.bodies = bodies;\n        this.colliders = colliders;\n        this.queries = queries;\n        this._chassis = chassis;\n    }\n\n    /** @internal */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n\n        this.raw = undefined;\n    }\n\n    /**\n     * Updates the vehicles velocity based on its suspension, engine force, and brake.\n     *\n     * This directly updates the velocity of its chassis rigid-body.\n     *\n     * @param dt - Time increment used to integrate forces.\n     * @param filterFlags - Flag to exclude categories of objects from the wheels ray-cast.\n     * @param filterGroups - Only colliders compatible with these groups will be hit by the wheels ray-casts.\n     * @param filterPredicate - Callback to filter out which collider will be hit by the wheels ray-casts.\n     */\n    public updateVehicle(\n        dt: number,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.raw.update_vehicle(\n            dt,\n            this.bodies.raw,\n            this.colliders.raw,\n            this.queries.raw,\n            filterFlags,\n            filterGroups,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * The current forward speed of the vehicle.\n     */\n    public currentVehicleSpeed(): number {\n        return this.raw.current_vehicle_speed();\n    }\n\n    /**\n     * The rigid-body used as the chassis.\n     */\n    public chassis(): RigidBody {\n        return this._chassis;\n    }\n\n    /**\n     * The chassis local _up_ direction (`0 = x, 1 = y, 2 = z`).\n     */\n    get indexUpAxis(): number {\n        return this.raw.index_up_axis();\n    }\n\n    /**\n     * Sets the chassis local _up_ direction (`0 = x, 1 = y, 2 = z`).\n     */\n    set indexUpAxis(axis: number) {\n        this.raw.set_index_up_axis(axis);\n    }\n\n    /**\n     * The chassis local _forward_ direction (`0 = x, 1 = y, 2 = z`).\n     */\n    get indexForwardAxis(): number {\n        return this.raw.index_forward_axis();\n    }\n\n    /**\n     * Sets the chassis local _forward_ direction (`0 = x, 1 = y, 2 = z`).\n     */\n    set setIndexForwardAxis(axis: number) {\n        this.raw.set_index_forward_axis(axis);\n    }\n\n    /**\n     * Adds a new wheel attached to this vehicle.\n     * @param chassisConnectionCs  - The position of the wheel relative to the chassis.\n     * @param directionCs - The direction of the wheels suspension, relative to the chassis. The ray-casting will\n     *                      happen following this direction to detect the ground.\n     * @param axleCs - The wheels axle axis, relative to the chassis.\n     * @param suspensionRestLength - The rest length of the wheels suspension spring.\n     * @param radius - The wheels radius.\n     */\n    public addWheel(\n        chassisConnectionCs: Vector,\n        directionCs: Vector,\n        axleCs: Vector,\n        suspensionRestLength: number,\n        radius: number,\n    ) {\n        let rawChassisConnectionCs = VectorOps.intoRaw(chassisConnectionCs);\n        let rawDirectionCs = VectorOps.intoRaw(directionCs);\n        let rawAxleCs = VectorOps.intoRaw(axleCs);\n\n        this.raw.add_wheel(\n            rawChassisConnectionCs,\n            rawDirectionCs,\n            rawAxleCs,\n            suspensionRestLength,\n            radius,\n        );\n\n        rawChassisConnectionCs.free();\n        rawDirectionCs.free();\n        rawAxleCs.free();\n    }\n\n    /**\n     * The number of wheels attached to this vehicle.\n     */\n    public numWheels(): number {\n        return this.raw.num_wheels();\n    }\n\n    /*\n     *\n     * Access to wheel properties.\n     *\n     */\n    /*\n     * Getters + setters\n     */\n    /**\n     * The position of the i-th wheel, relative to the chassis.\n     */\n    public wheelChassisConnectionPointCs(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.wheel_chassis_connection_point_cs(i));\n    }\n\n    /**\n     * Sets the position of the i-th wheel, relative to the chassis.\n     */\n    public setWheelChassisConnectionPointCs(i: number, value: Vector) {\n        let rawValue = VectorOps.intoRaw(value);\n        this.raw.set_wheel_chassis_connection_point_cs(i, rawValue);\n        rawValue.free();\n    }\n\n    /**\n     * The rest length of the i-th wheels suspension spring.\n     */\n    public wheelSuspensionRestLength(i: number): number | null {\n        return this.raw.wheel_suspension_rest_length(i);\n    }\n\n    /**\n     * Sets the rest length of the i-th wheels suspension spring.\n     */\n    public setWheelSuspensionRestLength(i: number, value: number) {\n        this.raw.set_wheel_suspension_rest_length(i, value);\n    }\n\n    /**\n     * The maximum distance the i-th wheel suspension can travel before and after its resting length.\n     */\n    public wheelMaxSuspensionTravel(i: number): number | null {\n        return this.raw.wheel_max_suspension_travel(i);\n    }\n\n    /**\n     * Sets the maximum distance the i-th wheel suspension can travel before and after its resting length.\n     */\n    public setWheelMaxSuspensionTravel(i: number, value: number) {\n        this.raw.set_wheel_max_suspension_travel(i, value);\n    }\n\n    /**\n     * The i-th wheels radius.\n     */\n    public wheelRadius(i: number): number | null {\n        return this.raw.wheel_radius(i);\n    }\n\n    /**\n     * Sets the i-th wheels radius.\n     */\n    public setWheelRadius(i: number, value: number) {\n        this.raw.set_wheel_radius(i, value);\n    }\n\n    /**\n     * The i-th wheels suspension stiffness.\n     *\n     * Increase this value if the suspension appears to not push the vehicle strong enough.\n     */\n    public wheelSuspensionStiffness(i: number): number | null {\n        return this.raw.wheel_suspension_stiffness(i);\n    }\n\n    /**\n     * Sets the i-th wheels suspension stiffness.\n     *\n     * Increase this value if the suspension appears to not push the vehicle strong enough.\n     */\n    public setWheelSuspensionStiffness(i: number, value: number) {\n        this.raw.set_wheel_suspension_stiffness(i, value);\n    }\n\n    /**\n     * The i-th wheels suspensions damping when it is being compressed.\n     */\n    public wheelSuspensionCompression(i: number): number | null {\n        return this.raw.wheel_suspension_compression(i);\n    }\n\n    /**\n     * The i-th wheels suspensions damping when it is being compressed.\n     */\n    public setWheelSuspensionCompression(i: number, value: number) {\n        this.raw.set_wheel_suspension_compression(i, value);\n    }\n\n    /**\n     * The i-th wheels suspensions damping when it is being released.\n     *\n     * Increase this value if the suspension appears to overshoot.\n     */\n    public wheelSuspensionRelaxation(i: number): number | null {\n        return this.raw.wheel_suspension_relaxation(i);\n    }\n\n    /**\n     * Sets the i-th wheels suspensions damping when it is being released.\n     *\n     * Increase this value if the suspension appears to overshoot.\n     */\n    public setWheelSuspensionRelaxation(i: number, value: number) {\n        this.raw.set_wheel_suspension_relaxation(i, value);\n    }\n\n    /**\n     * The maximum force applied by the i-th wheels suspension.\n     */\n    public wheelMaxSuspensionForce(i: number): number | null {\n        return this.raw.wheel_max_suspension_force(i);\n    }\n\n    /**\n     * Sets the maximum force applied by the i-th wheels suspension.\n     */\n    public setWheelMaxSuspensionForce(i: number, value: number) {\n        this.raw.set_wheel_max_suspension_force(i, value);\n    }\n\n    /**\n     * The maximum amount of braking impulse applied on the i-th wheel to slow down the vehicle.\n     */\n    public wheelBrake(i: number): number | null {\n        return this.raw.wheel_brake(i);\n    }\n\n    /**\n     * Set the maximum amount of braking impulse applied on the i-th wheel to slow down the vehicle.\n     */\n    public setWheelBrake(i: number, value: number) {\n        this.raw.set_wheel_brake(i, value);\n    }\n\n    /**\n     * The steering angle (radians) for the i-th wheel.\n     */\n    public wheelSteering(i: number): number | null {\n        return this.raw.wheel_steering(i);\n    }\n\n    /**\n     * Sets the steering angle (radians) for the i-th wheel.\n     */\n    public setWheelSteering(i: number, value: number) {\n        this.raw.set_wheel_steering(i, value);\n    }\n\n    /**\n     * The forward force applied by the i-th wheel on the chassis.\n     */\n    public wheelEngineForce(i: number): number | null {\n        return this.raw.wheel_engine_force(i);\n    }\n\n    /**\n     * Sets the forward force applied by the i-th wheel on the chassis.\n     */\n    public setWheelEngineForce(i: number, value: number) {\n        this.raw.set_wheel_engine_force(i, value);\n    }\n\n    /**\n     * The direction of the i-th wheels suspension, relative to the chassis.\n     *\n     * The ray-casting will happen following this direction to detect the ground.\n     */\n    public wheelDirectionCs(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.wheel_direction_cs(i));\n    }\n\n    /**\n     * Sets the direction of the i-th wheels suspension, relative to the chassis.\n     *\n     * The ray-casting will happen following this direction to detect the ground.\n     */\n    public setWheelDirectionCs(i: number, value: Vector) {\n        let rawValue = VectorOps.intoRaw(value);\n        this.raw.set_wheel_direction_cs(i, rawValue);\n        rawValue.free();\n    }\n\n    /**\n     * The i-th wheels axle axis, relative to the chassis.\n     *\n     * The axis index defined as 0 = X, 1 = Y, 2 = Z.\n     */\n    public wheelAxleCs(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.wheel_axle_cs(i));\n    }\n\n    /**\n     * Sets the i-th wheels axle axis, relative to the chassis.\n     *\n     * The axis index defined as 0 = X, 1 = Y, 2 = Z.\n     */\n    public setWheelAxleCs(i: number, value: Vector) {\n        let rawValue = VectorOps.intoRaw(value);\n        this.raw.set_wheel_axle_cs(i, rawValue);\n        rawValue.free();\n    }\n\n    /**\n     * Parameter controlling how much traction the tire has.\n     *\n     * The larger the value, the more instantaneous braking will happen (with the risk of\n     * causing the vehicle to flip if its too strong).\n     */\n    public wheelFrictionSlip(i: number): number | null {\n        return this.raw.wheel_friction_slip(i);\n    }\n\n    /**\n     * Sets the parameter controlling how much traction the tire has.\n     *\n     * The larger the value, the more instantaneous braking will happen (with the risk of\n     * causing the vehicle to flip if its too strong).\n     */\n    public setWheelFrictionSlip(i: number, value: number) {\n        this.raw.set_wheel_friction_slip(i, value);\n    }\n\n    /**\n     * The multiplier of friction between a tire and the collider its on top of.\n     *\n     * The larger the value, the stronger side friction will be.\n     */\n    public wheelSideFrictionStiffness(i: number): number | null {\n        return this.raw.wheel_side_friction_stiffness(i);\n    }\n\n    /**\n     * The multiplier of friction between a tire and the collider its on top of.\n     *\n     * The larger the value, the stronger side friction will be.\n     */\n    public setWheelSideFrictionStiffness(i: number, value: number) {\n        this.raw.set_wheel_side_friction_stiffness(i, value);\n    }\n\n    /*\n     * Getters only.\n     */\n\n    /**\n     *  The i-th wheels current rotation angle (radians) on its axle.\n     */\n    public wheelRotation(i: number): number | null {\n        return this.raw.wheel_rotation(i);\n    }\n\n    /**\n     *  The forward impulses applied by the i-th wheel on the chassis.\n     */\n    public wheelForwardImpulse(i: number): number | null {\n        return this.raw.wheel_forward_impulse(i);\n    }\n\n    /**\n     *  The side impulses applied by the i-th wheel on the chassis.\n     */\n    public wheelSideImpulse(i: number): number | null {\n        return this.raw.wheel_side_impulse(i);\n    }\n\n    /**\n     *  The force applied by the i-th wheel suspension.\n     */\n    public wheelSuspensionForce(i: number): number | null {\n        return this.raw.wheel_suspension_force(i);\n    }\n\n    /**\n     *  The (world-space) contact normal between the i-th wheel and the floor.\n     */\n    public wheelContactNormal(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.wheel_contact_normal_ws(i));\n    }\n\n    /**\n     *  The (world-space) point hit by the wheels ray-cast for the i-th wheel.\n     */\n    public wheelContactPoint(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.wheel_contact_point_ws(i));\n    }\n\n    /**\n     *  The suspension length for the i-th wheel.\n     */\n    public wheelSuspensionLength(i: number): number | null {\n        return this.raw.wheel_suspension_length(i);\n    }\n\n    /**\n     *  The (world-space) starting point of the ray-cast for the i-th wheel.\n     */\n    public wheelHardPoint(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.wheel_hard_point_ws(i));\n    }\n\n    /**\n     *  Is the i-th wheel in contact with the ground?\n     */\n    public wheelIsInContact(i: number): boolean {\n        return this.raw.wheel_is_in_contact(i);\n    }\n\n    /**\n     *  The collider hit by the ray-cast for the i-th wheel.\n     */\n    public wheelGroundObject(i: number): Collider | null {\n        return this.colliders.get(this.raw.wheel_ground_object(i));\n    }\n}\n", "import {\n    RawBroadPhase,\n    RawCCDSolver,\n    RawColliderSet,\n    RawDeserializedWorld,\n    RawIntegrationParameters,\n    RawIslandManager,\n    RawImpulseJointSet,\n    RawMultibodyJointSet,\n    RawNarrowPhase,\n    RawPhysicsPipeline,\n    RawQueryPipeline,\n    RawRigidBodySet,\n    RawSerializationPipeline,\n    RawDebugRenderPipeline,\n} from \"../raw\";\n\nimport {\n    BroadPhase,\n    Collider,\n    ColliderDesc,\n    ColliderHandle,\n    ColliderSet,\n    InteractionGroups,\n    NarrowPhase,\n    PointColliderProjection,\n    Ray,\n    RayColliderIntersection,\n    RayColliderHit,\n    Shape,\n    ColliderShapeCastHit,\n    TempContactManifold,\n} from \"../geometry\";\nimport {\n    CCDSolver,\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJoint,\n    ImpulseJointHandle,\n    MultibodyJoint,\n    MultibodyJointHandle,\n    JointData,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBody,\n    RigidBodyDesc,\n    RigidBodyHandle,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {Rotation, Vector, VectorOps} from \"../math\";\nimport {PhysicsPipeline} from \"./physics_pipeline\";\nimport {QueryFilterFlags, QueryPipeline} from \"./query_pipeline\";\nimport {SerializationPipeline} from \"./serialization_pipeline\";\nimport {EventQueue} from \"./event_queue\";\nimport {PhysicsHooks} from \"./physics_hooks\";\nimport {DebugRenderBuffers, DebugRenderPipeline} from \"./debug_render_pipeline\";\nimport {\n    KinematicCharacterController,\n    PidAxesMask,\n    PidController,\n} from \"../control\";\nimport {Coarena} from \"../coarena\";\n\n// #if DIM3\nimport {DynamicRayCastVehicleController} from \"../control\";\n\n// #endif\n\n/**\n * The physics world.\n *\n * This contains all the data-structures necessary for creating and simulating\n * bodies with contacts, joints, and external forces.\n */\nexport class World {\n    public gravity: Vector;\n    integrationParameters: IntegrationParameters;\n    islands: IslandManager;\n    broadPhase: BroadPhase;\n    narrowPhase: NarrowPhase;\n    bodies: RigidBodySet;\n    colliders: ColliderSet;\n    impulseJoints: ImpulseJointSet;\n    multibodyJoints: MultibodyJointSet;\n    ccdSolver: CCDSolver;\n    queryPipeline: QueryPipeline;\n    physicsPipeline: PhysicsPipeline;\n    serializationPipeline: SerializationPipeline;\n    debugRenderPipeline: DebugRenderPipeline;\n    characterControllers: Set<KinematicCharacterController>;\n    pidControllers: Set<PidController>;\n\n    // #if DIM3\n    vehicleControllers: Set<DynamicRayCastVehicleController>;\n\n    // #endif\n\n    /**\n     * Release the WASM memory occupied by this physics world.\n     *\n     * All the fields of this physics world will be freed as well,\n     * so there is no need to call their `.free()` methods individually.\n     */\n    public free() {\n        this.integrationParameters.free();\n        this.islands.free();\n        this.broadPhase.free();\n        this.narrowPhase.free();\n        this.bodies.free();\n        this.colliders.free();\n        this.impulseJoints.free();\n        this.multibodyJoints.free();\n        this.ccdSolver.free();\n        this.queryPipeline.free();\n        this.physicsPipeline.free();\n        this.serializationPipeline.free();\n        this.debugRenderPipeline.free();\n        this.characterControllers.forEach((controller) => controller.free());\n        this.pidControllers.forEach((controller) => controller.free());\n\n        // #if DIM3\n        this.vehicleControllers.forEach((controller) => controller.free());\n        // #endif\n\n        this.integrationParameters = undefined;\n        this.islands = undefined;\n        this.broadPhase = undefined;\n        this.narrowPhase = undefined;\n        this.bodies = undefined;\n        this.colliders = undefined;\n        this.ccdSolver = undefined;\n        this.impulseJoints = undefined;\n        this.multibodyJoints = undefined;\n        this.queryPipeline = undefined;\n        this.physicsPipeline = undefined;\n        this.serializationPipeline = undefined;\n        this.debugRenderPipeline = undefined;\n        this.characterControllers = undefined;\n        this.pidControllers = undefined;\n\n        // #if DIM3\n        this.vehicleControllers = undefined;\n        // #endif\n    }\n\n    constructor(\n        gravity: Vector,\n        rawIntegrationParameters?: RawIntegrationParameters,\n        rawIslands?: RawIslandManager,\n        rawBroadPhase?: RawBroadPhase,\n        rawNarrowPhase?: RawNarrowPhase,\n        rawBodies?: RawRigidBodySet,\n        rawColliders?: RawColliderSet,\n        rawImpulseJoints?: RawImpulseJointSet,\n        rawMultibodyJoints?: RawMultibodyJointSet,\n        rawCCDSolver?: RawCCDSolver,\n        rawQueryPipeline?: RawQueryPipeline,\n        rawPhysicsPipeline?: RawPhysicsPipeline,\n        rawSerializationPipeline?: RawSerializationPipeline,\n        rawDebugRenderPipeline?: RawDebugRenderPipeline,\n    ) {\n        this.gravity = gravity;\n        this.integrationParameters = new IntegrationParameters(\n            rawIntegrationParameters,\n        );\n        this.islands = new IslandManager(rawIslands);\n        this.broadPhase = new BroadPhase(rawBroadPhase);\n        this.narrowPhase = new NarrowPhase(rawNarrowPhase);\n        this.bodies = new RigidBodySet(rawBodies);\n        this.colliders = new ColliderSet(rawColliders);\n        this.impulseJoints = new ImpulseJointSet(rawImpulseJoints);\n        this.multibodyJoints = new MultibodyJointSet(rawMultibodyJoints);\n        this.ccdSolver = new CCDSolver(rawCCDSolver);\n        this.queryPipeline = new QueryPipeline(rawQueryPipeline);\n        this.physicsPipeline = new PhysicsPipeline(rawPhysicsPipeline);\n        this.serializationPipeline = new SerializationPipeline(\n            rawSerializationPipeline,\n        );\n        this.debugRenderPipeline = new DebugRenderPipeline(\n            rawDebugRenderPipeline,\n        );\n        this.characterControllers = new Set<KinematicCharacterController>();\n        this.pidControllers = new Set<PidController>();\n\n        // #if DIM3\n        this.vehicleControllers = new Set<DynamicRayCastVehicleController>();\n        // #endif\n\n        this.impulseJoints.finalizeDeserialization(this.bodies);\n        this.bodies.finalizeDeserialization(this.colliders);\n        this.colliders.finalizeDeserialization(this.bodies);\n    }\n\n    public static fromRaw(raw: RawDeserializedWorld): World {\n        if (!raw) return null;\n\n        return new World(\n            VectorOps.fromRaw(raw.takeGravity()),\n            raw.takeIntegrationParameters(),\n            raw.takeIslandManager(),\n            raw.takeBroadPhase(),\n            raw.takeNarrowPhase(),\n            raw.takeBodies(),\n            raw.takeColliders(),\n            raw.takeImpulseJoints(),\n            raw.takeMultibodyJoints(),\n        );\n    }\n\n    /**\n     * Takes a snapshot of this world.\n     *\n     * Use `World.restoreSnapshot` to create a new physics world with a state identical to\n     * the state when `.takeSnapshot()` is called.\n     */\n    public takeSnapshot(): Uint8Array {\n        return this.serializationPipeline.serializeAll(\n            this.gravity,\n            this.integrationParameters,\n            this.islands,\n            this.broadPhase,\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n        );\n    }\n\n    /**\n     * Creates a new physics world from a snapshot.\n     *\n     * This new physics world will be an identical copy of the snapshoted physics world.\n     */\n    public static restoreSnapshot(data: Uint8Array): World {\n        let deser = new SerializationPipeline();\n        return deser.deserializeAll(data);\n    }\n\n    /**\n     * Computes all the lines (and their colors) needed to render the scene.\n     */\n    public debugRender(): DebugRenderBuffers {\n        this.debugRenderPipeline.render(\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n            this.narrowPhase,\n        );\n        return new DebugRenderBuffers(\n            this.debugRenderPipeline.vertices,\n            this.debugRenderPipeline.colors,\n        );\n    }\n\n    /**\n     * Advance the simulation by one time step.\n     *\n     * All events generated by the physics engine are ignored.\n     *\n     * @param EventQueue - (optional) structure responsible for collecting\n     *   events generated by the physics engine.\n     */\n    public step(eventQueue?: EventQueue, hooks?: PhysicsHooks) {\n        this.physicsPipeline.step(\n            this.gravity,\n            this.integrationParameters,\n            this.islands,\n            this.broadPhase,\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n            this.ccdSolver,\n            eventQueue,\n            hooks,\n        );\n        this.queryPipeline.update(this.colliders);\n    }\n\n    /**\n     * Update colliders positions after rigid-bodies moved.\n     *\n     * When a rigid-body moves, the positions of the colliders attached to it need to be updated. This update is\n     * generally automatically done at the beginning and the end of each simulation step with World.step.\n     * If the positions need to be updated without running a simulation step this method can be called manually.\n     */\n    public propagateModifiedBodyPositionsToColliders() {\n        this.bodies.raw.propagateModifiedBodyPositionsToColliders(\n            this.colliders.raw,\n        );\n    }\n\n    /**\n     * Ensure subsequent scene queries take into account the collider positions set before this method is called.\n     *\n     * This does not step the physics simulation forward.\n     */\n    public updateSceneQueries() {\n        this.propagateModifiedBodyPositionsToColliders();\n        this.queryPipeline.update(this.colliders);\n    }\n\n    /**\n     * The current simulation timestep.\n     */\n    get timestep(): number {\n        return this.integrationParameters.dt;\n    }\n\n    /**\n     * Sets the new simulation timestep.\n     *\n     * The simulation timestep governs by how much the physics state of the world will\n     * be integrated. A simulation timestep should:\n     * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,\n     * corresponds to the time between two frames of a game running at 60FPS).\n     * - not vary too much during the course of the simulation. A timestep with large variations may\n     * cause instabilities in the simulation.\n     *\n     * @param dt - The timestep length, in seconds.\n     */\n    set timestep(dt: number) {\n        this.integrationParameters.dt = dt;\n    }\n\n    /**\n     * The approximate size of most dynamic objects in the scene.\n     *\n     * See the documentation of the `World.lengthUnit` setter for further details.\n     */\n    get lengthUnit(): number {\n        return this.integrationParameters.lengthUnit;\n    }\n\n    /**\n     * The approximate size of most dynamic objects in the scene.\n     *\n     * This value is used internally to estimate some length-based tolerance. In particular, the\n     * values `IntegrationParameters.allowedLinearError`,\n     * `IntegrationParameters.maxPenetrationCorrection`,\n     * `IntegrationParameters.predictionDistance`, `RigidBodyActivation.linearThreshold`\n     * are scaled by this value implicitly.\n     *\n     * This value can be understood as the number of units-per-meter in your physical world compared\n     * to a human-sized world in meter. For example, in a 2d game, if your typical object size is 100\n     * pixels, set the `[`Self::length_unit`]` parameter to 100.0. The physics engine will interpret\n     * it as if 100 pixels is equivalent to 1 meter in its various internal threshold.\n     * (default `1.0`).\n     */\n    set lengthUnit(unitsPerMeter: number) {\n        this.integrationParameters.lengthUnit = unitsPerMeter;\n    }\n\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    get numSolverIterations(): number {\n        return this.integrationParameters.numSolverIterations;\n    }\n\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     *\n     * The greater this value is, the most rigid and realistic the physics simulation will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of solver iterations.\n     */\n    set numSolverIterations(niter: number) {\n        this.integrationParameters.numSolverIterations = niter;\n    }\n\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    get numAdditionalFrictionIterations(): number {\n        return this.integrationParameters.numAdditionalFrictionIterations;\n    }\n\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     *\n     * The greater this value is, the most realistic friction will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of additional friction iterations.\n     */\n    set numAdditionalFrictionIterations(niter: number) {\n        this.integrationParameters.numAdditionalFrictionIterations = niter;\n    }\n\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    get numInternalPgsIterations(): number {\n        return this.integrationParameters.numInternalPgsIterations;\n    }\n\n    /**\n     * Sets the Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     *\n     * Increasing this parameter will improve stability of the simulation. It will have a lesser effect than\n     * increasing `numSolverIterations` but is also less computationally expensive.\n     *\n     * @param niter - The new number of internal PGS iterations.\n     */\n    set numInternalPgsIterations(niter: number) {\n        this.integrationParameters.numInternalPgsIterations = niter;\n    }\n\n    /// Configures the integration parameters to match the old PGS solver\n    /// from Rapier JS version <= 0.11.\n    ///\n    /// This solver was slightly faster than the new one but resulted\n    /// in less stable joints and worse convergence rates.\n    ///\n    /// This should only be used for comparison purpose or if you are\n    /// experiencing problems with the new solver.\n    ///\n    /// NOTE: this does not affect any `RigidBody.additional_solver_iterations` that will\n    ///       still create solver iterations based on the new \"small-steps\" PGS solver.\n    public switchToStandardPgsSolver() {\n        this.integrationParameters.switchToStandardPgsSolver();\n    }\n\n    /// Configures the integration parameters to match the new \"small-steps\" PGS solver\n    /// from Rapier version >= 0.12.\n    ///\n    /// The \"small-steps\" PGS solver is the default one when creating the physics world. So\n    /// calling this function is generally not needed unless `World.switch_to_standard_pgs_solver`\n    /// was called.\n    ///\n    /// This solver results in more stable joints and significantly better convergence\n    /// rates but is slightly slower in its default settings.\n    public switchToSmallStepsPgsSolver() {\n        this.integrationParameters.switchToSmallStepsPgsSolver();\n    }\n\n    /// Configures the integration parameters to match the new \"small-steps\" PGS solver\n    /// from Rapier version >= 0.12. Warmstarting is disabled.\n    ///\n    /// The \"small-steps\" PGS solver is the default one when creating the physics world. So\n    /// calling this function is generally not needed unless `World.switch_to_standard_pgs_solver`\n    /// was called.\n    ///\n    /// This solver results in more stable joints and significantly better convergence\n    /// rates but is slightly slower in its default settings.\n    public switchToSmallStepsPgsSolverWithoutWarmstart() {\n        this.integrationParameters.switchToSmallStepsPgsSolverWithoutWarmstart();\n    }\n\n    /**\n     * Creates a new rigid-body from the given rigid-body descriptor.\n     *\n     * @param body - The description of the rigid-body to create.\n     */\n    public createRigidBody(body: RigidBodyDesc): RigidBody {\n        return this.bodies.createRigidBody(this.colliders, body);\n    }\n\n    /**\n     * Creates a new character controller.\n     *\n     * @param offset - The artificial gap added between the characters chape and its environment.\n     */\n    public createCharacterController(\n        offset: number,\n    ): KinematicCharacterController {\n        let controller = new KinematicCharacterController(\n            offset,\n            this.integrationParameters,\n            this.bodies,\n            this.colliders,\n            this.queryPipeline,\n        );\n        this.characterControllers.add(controller);\n        return controller;\n    }\n\n    /**\n     * Removes a character controller from this world.\n     *\n     * @param controller - The character controller to remove.\n     */\n    public removeCharacterController(controller: KinematicCharacterController) {\n        this.characterControllers.delete(controller);\n        controller.free();\n    }\n\n    /**\n     * Creates a new PID (Proportional-Integral-Derivative) controller.\n     *\n     * @param kp - The Proportional gain applied to the instantaneous linear position errors.\n     *             This is usually set to a multiple of the inverse of simulation step time\n     *             (e.g. `60` if the delta-time is `1.0 / 60.0`).\n     * @param ki - The linear gain applied to the Integral part of the PID controller.\n     * @param kd - The Derivative gain applied to the instantaneous linear velocity errors.\n     *             This is usually set to a value in `[0.0, 1.0]` where `0.0` implies no damping\n     *             (no correction of velocity errors) and `1.0` implies complete damping (velocity errors\n     *             are corrected in a single simulation step).\n     * @param axes - The axes affected by this controller.\n     *               Only coordinate axes with a bit flags set to `true` will be taken into\n     *               account when calculating the errors and corrections.\n     */\n    public createPidController(\n        kp: number,\n        ki: number,\n        kd: number,\n        axes: PidAxesMask,\n    ): PidController {\n        let controller = new PidController(\n            this.integrationParameters,\n            this.bodies,\n            kp,\n            ki,\n            kd,\n            axes,\n        );\n        this.pidControllers.add(controller);\n        return controller;\n    }\n\n    /**\n     * Removes a PID controller from this world.\n     *\n     * @param controller - The PID controller to remove.\n     */\n    public removePidController(controller: PidController) {\n        this.pidControllers.delete(controller);\n        controller.free();\n    }\n\n    // #if DIM3\n    /**\n     * Creates a new vehicle controller.\n     *\n     * @param chassis - The rigid-body used as the chassis of the vehicle controller. When the vehicle\n     *                  controller is updated, it will change directly the rigid-bodys velocity. This\n     *                  rigid-body must be a dynamic or kinematic-velocity-based rigid-body.\n     */\n    public createVehicleController(\n        chassis: RigidBody,\n    ): DynamicRayCastVehicleController {\n        let controller = new DynamicRayCastVehicleController(\n            chassis,\n            this.bodies,\n            this.colliders,\n            this.queryPipeline,\n        );\n        this.vehicleControllers.add(controller);\n        return controller;\n    }\n\n    /**\n     * Removes a vehicle controller from this world.\n     *\n     * @param controller - The vehicle controller to remove.\n     */\n    public removeVehicleController(\n        controller: DynamicRayCastVehicleController,\n    ) {\n        this.vehicleControllers.delete(controller);\n        controller.free();\n    }\n\n    // #endif\n\n    /**\n     * Creates a new collider.\n     *\n     * @param desc - The description of the collider.\n     * @param parent - The rigid-body this collider is attached to.\n     */\n    public createCollider(desc: ColliderDesc, parent?: RigidBody): Collider {\n        let parentHandle = parent ? parent.handle : undefined;\n        return this.colliders.createCollider(this.bodies, desc, parentHandle);\n    }\n\n    /**\n     * Creates a new impulse joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createImpulseJoint(\n        params: JointData,\n        parent1: RigidBody,\n        parent2: RigidBody,\n        wakeUp: boolean,\n    ): ImpulseJoint {\n        return this.impulseJoints.createJoint(\n            this.bodies,\n            params,\n            parent1.handle,\n            parent2.handle,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Creates a new multibody joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createMultibodyJoint(\n        params: JointData,\n        parent1: RigidBody,\n        parent2: RigidBody,\n        wakeUp: boolean,\n    ): MultibodyJoint {\n        return this.multibodyJoints.createJoint(\n            params,\n            parent1.handle,\n            parent2.handle,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Retrieves a rigid-body from its handle.\n     *\n     * @param handle - The integer handle of the rigid-body to retrieve.\n     */\n    public getRigidBody(handle: RigidBodyHandle): RigidBody {\n        return this.bodies.get(handle);\n    }\n\n    /**\n     * Retrieves a collider from its handle.\n     *\n     * @param handle - The integer handle of the collider to retrieve.\n     */\n    public getCollider(handle: ColliderHandle): Collider {\n        return this.colliders.get(handle);\n    }\n\n    /**\n     * Retrieves an impulse joint from its handle.\n     *\n     * @param handle - The integer handle of the impulse joint to retrieve.\n     */\n    public getImpulseJoint(handle: ImpulseJointHandle): ImpulseJoint {\n        return this.impulseJoints.get(handle);\n    }\n\n    /**\n     * Retrieves an multibody joint from its handle.\n     *\n     * @param handle - The integer handle of the multibody joint to retrieve.\n     */\n    public getMultibodyJoint(handle: MultibodyJointHandle): MultibodyJoint {\n        return this.multibodyJoints.get(handle);\n    }\n\n    /**\n     * Removes the given rigid-body from this physics world.\n     *\n     * This will remove this rigid-body as well as all its attached colliders and joints.\n     * Every other bodies touching or attached by joints to this rigid-body will be woken-up.\n     *\n     * @param body - The rigid-body to remove.\n     */\n    public removeRigidBody(body: RigidBody) {\n        if (this.bodies) {\n            this.bodies.remove(\n                body.handle,\n                this.islands,\n                this.colliders,\n                this.impulseJoints,\n                this.multibodyJoints,\n            );\n        }\n    }\n\n    /**\n     * Removes the given collider from this physics world.\n     *\n     * @param collider - The collider to remove.\n     * @param wakeUp - If set to `true`, the rigid-body this collider is attached to will be awaken.\n     */\n    public removeCollider(collider: Collider, wakeUp: boolean) {\n        if (this.colliders) {\n            this.colliders.remove(\n                collider.handle,\n                this.islands,\n                this.bodies,\n                wakeUp,\n            );\n        }\n    }\n\n    /**\n     * Removes the given impulse joint from this physics world.\n     *\n     * @param joint - The impulse joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    public removeImpulseJoint(joint: ImpulseJoint, wakeUp: boolean) {\n        if (this.impulseJoints) {\n            this.impulseJoints.remove(joint.handle, wakeUp);\n        }\n    }\n\n    /**\n     * Removes the given multibody joint from this physics world.\n     *\n     * @param joint - The multibody joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    public removeMultibodyJoint(joint: MultibodyJoint, wakeUp: boolean) {\n        if (this.impulseJoints) {\n            this.multibodyJoints.remove(joint.handle, wakeUp);\n        }\n    }\n\n    /**\n     * Applies the given closure to each collider managed by this physics world.\n     *\n     * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachCollider(f: (collider: Collider) => void) {\n        this.colliders.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each rigid-body managed by this physics world.\n     *\n     * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachRigidBody(f: (body: RigidBody) => void) {\n        this.bodies.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each active rigid-body managed by this physics world.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachActiveRigidBody(f: (body: RigidBody) => void) {\n        this.bodies.forEachActiveRigidBody(this.islands, f);\n    }\n\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    public castRay(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): RayColliderHit | null {\n        return this.queryPipeline.castRay(\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    public castRayAndGetNormal(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): RayColliderIntersection | null {\n        return this.queryPipeline.castRayAndGetNormal(\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    public intersectionsWithRay(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        callback: (intersect: RayColliderIntersection) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithRay(\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    public intersectionWithShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): Collider | null {\n        let handle = this.queryPipeline.intersectionWithShape(\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shape,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n        return handle != null ? this.colliders.get(handle) : null;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPoint(\n        point: Vector,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): PointColliderProjection | null {\n        return this.queryPipeline.projectPoint(\n            this.bodies,\n            this.colliders,\n            point,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPointAndGetFeature(\n        point: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): PointColliderProjection | null {\n        return this.queryPipeline.projectPointAndGetFeature(\n            this.bodies,\n            this.colliders,\n            point,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    public intersectionsWithPoint(\n        point: Vector,\n        callback: (handle: Collider) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithPoint(\n            this.bodies,\n            this.colliders,\n            point,\n            this.colliders.castClosure(callback),\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param targetDistance  If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exit that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    public castShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shapeVel: Vector,\n        shape: Shape,\n        targetDistance: number,\n        maxToi: number,\n        stopAtPenetration: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): ColliderShapeCastHit | null {\n        return this.queryPipeline.castShape(\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shapeVel,\n            shape,\n            targetDistance,\n            maxToi,\n            stopAtPenetration,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    public intersectionsWithShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        callback: (collider: Collider) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithShape(\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shape,\n            this.colliders.castClosure(callback),\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    public collidersWithAabbIntersectingAabb(\n        aabbCenter: Vector,\n        aabbHalfExtents: Vector,\n        callback: (handle: Collider) => boolean,\n    ) {\n        this.queryPipeline.collidersWithAabbIntersectingAabb(\n            aabbCenter,\n            aabbHalfExtents,\n            this.colliders.castClosure(callback),\n        );\n    }\n\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    public contactPairsWith(\n        collider1: Collider,\n        f: (collider2: Collider) => void,\n    ) {\n        this.narrowPhase.contactPairsWith(\n            collider1.handle,\n            this.colliders.castClosure(f),\n        );\n    }\n\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    public intersectionPairsWith(\n        collider1: Collider,\n        f: (collider2: Collider) => void,\n    ) {\n        this.narrowPhase.intersectionPairsWith(\n            collider1.handle,\n            this.colliders.castClosure(f),\n        );\n    }\n\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    public contactPair(\n        collider1: Collider,\n        collider2: Collider,\n        f: (manifold: TempContactManifold, flipped: boolean) => void,\n    ) {\n        this.narrowPhase.contactPair(collider1.handle, collider2.handle, f);\n    }\n\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1  The first collider involved in the intersection.\n     * @param collider2  The second collider involved in the intersection.\n     */\n    public intersectionPair(collider1: Collider, collider2: Collider): boolean {\n        return this.narrowPhase.intersectionPair(\n            collider1.handle,\n            collider2.handle,\n        );\n    }\n}\n", "import {RawContactForceEvent, RawEventQueue} from \"../raw\";\nimport {RigidBodyHandle} from \"../dynamics\";\nimport {Collider, ColliderHandle} from \"../geometry\";\nimport {Vector, VectorOps} from \"../math\";\n\n/**\n * Flags indicating what events are enabled for colliders.\n */\nexport enum ActiveEvents {\n    NONE = 0,\n    /**\n     * Enable collision events.\n     */\n    COLLISION_EVENTS = 0b0001,\n    /**\n     * Enable contact force events.\n     */\n    CONTACT_FORCE_EVENTS = 0b0010,\n}\n\n/**\n * Event occurring when the sum of the magnitudes of the\n * contact forces between two colliders exceed a threshold.\n *\n * This object should **not** be stored anywhere. Its properties can only be\n * read from within the closure given to `EventHandler.drainContactForceEvents`.\n */\nexport class TempContactForceEvent {\n    raw: RawContactForceEvent;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * The first collider involved in the contact.\n     */\n    public collider1(): ColliderHandle {\n        return this.raw.collider1();\n    }\n\n    /**\n     * The second collider involved in the contact.\n     */\n    public collider2(): ColliderHandle {\n        return this.raw.collider2();\n    }\n\n    /**\n     * The sum of all the forces between the two colliders.\n     */\n    public totalForce(): Vector {\n        return VectorOps.fromRaw(this.raw.total_force());\n    }\n\n    /**\n     * The sum of the magnitudes of each force between the two colliders.\n     *\n     * Note that this is **not** the same as the magnitude of `self.total_force`.\n     * Here we are summing the magnitude of all the forces, instead of taking\n     * the magnitude of their sum.\n     */\n    public totalForceMagnitude(): number {\n        return this.raw.total_force_magnitude();\n    }\n\n    /**\n     * The world-space (unit) direction of the force with strongest magnitude.\n     */\n    public maxForceDirection(): Vector {\n        return VectorOps.fromRaw(this.raw.max_force_direction());\n    }\n\n    /**\n     * The magnitude of the largest force at a contact point of this contact pair.\n     */\n    public maxForceMagnitude(): number {\n        return this.raw.max_force_magnitude();\n    }\n}\n\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `eventQueue.free()`\n * once you are done using it.\n */\nexport class EventQueue {\n    raw: RawEventQueue;\n\n    /**\n     * Creates a new event collector.\n     *\n     * @param autoDrain -setting this to `true` is strongly recommended. If true, the collector will\n     * be automatically drained before each `world.step(collector)`. If false, the collector will\n     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n     * RAM if no drain is performed.\n     */\n    constructor(autoDrain: boolean, raw?: RawEventQueue) {\n        this.raw = raw || new RawEventQueue(autoDrain);\n    }\n\n    /**\n     * Release the WASM memory occupied by this event-queue.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * Applies the given javascript closure on each collision event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     * closure must take three arguments: two integers representing the handles of the colliders\n     * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n     * (false).\n     */\n    public drainCollisionEvents(\n        f: (\n            handle1: ColliderHandle,\n            handle2: ColliderHandle,\n            started: boolean,\n        ) => void,\n    ) {\n        this.raw.drainCollisionEvents(f);\n    }\n\n    /**\n     * Applies the given javascript closure on each contact force event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     *            closure must take one `TempContactForceEvent` argument.\n     */\n    public drainContactForceEvents(f: (event: TempContactForceEvent) => void) {\n        let event = new TempContactForceEvent();\n        this.raw.drainContactForceEvents((raw: RawContactForceEvent) => {\n            event.raw = raw;\n            f(event);\n            event.free();\n        });\n    }\n\n    /**\n     * Removes all events contained by this collector\n     */\n    public clear() {\n        this.raw.clear();\n    }\n}\n", "import {RigidBodyHandle} from \"../dynamics\";\nimport {ColliderHandle} from \"../geometry\";\n\nexport enum ActiveHooks {\n    NONE = 0,\n    FILTER_CONTACT_PAIRS = 0b0001,\n    FILTER_INTERSECTION_PAIRS = 0b0010,\n    // MODIFY_SOLVER_CONTACTS = 0b0100, /* Not supported yet in JS. */\n}\n\nexport enum SolverFlags {\n    EMPTY = 0b000,\n    COMPUTE_IMPULSE = 0b001,\n}\n\nexport interface PhysicsHooks {\n    /**\n     * Function that determines if contacts computation should happen between two colliders, and how the\n     * constraints solver should behave for these contacts.\n     *\n     * This will only be executed and taken into account if at least one of the involved colliders contains the\n     * `ActiveHooks.FILTER_CONTACT_PAIR` flag in its active hooks.\n     *\n     * @param collider1  Handle of the first collider involved in the potential contact.\n     * @param collider2  Handle of the second collider involved in the potential contact.\n     * @param body1  Handle of the first body involved in the potential contact.\n     * @param body2  Handle of the second body involved in the potential contact.\n     */\n    filterContactPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        body1: RigidBodyHandle,\n        body2: RigidBodyHandle,\n    ): SolverFlags | null;\n\n    /**\n     * Function that determines if intersection computation should happen between two colliders (where at least\n     * one is a sensor).\n     *\n     * This will only be executed and taken into account if `one of the involved colliders contains the\n     * `ActiveHooks.FILTER_INTERSECTION_PAIR` flag in its active hooks.\n     *\n     * @param collider1  Handle of the first collider involved in the potential contact.\n     * @param collider2  Handle of the second collider involved in the potential contact.\n     * @param body1  Handle of the first body involved in the potential contact.\n     * @param body2  Handle of the second body involved in the potential contact.\n     */\n    filterIntersectionPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        body1: RigidBodyHandle,\n        body2: RigidBodyHandle,\n    ): boolean;\n}\n", "import {RawColliderSet} from \"../raw\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\nimport {\n    CoefficientCombineRule,\n    RigidBody,\n    RigidBodyHandle,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {ActiveHooks, ActiveEvents} from \"../pipeline\";\nimport {InteractionGroups} from \"./interaction_groups\";\nimport {\n    Shape,\n    Cuboid,\n    Ball,\n    ShapeType,\n    Capsule,\n    TriMesh,\n    Polyline,\n    Heightfield,\n    Segment,\n    Triangle,\n    RoundTriangle,\n    RoundCuboid,\n    HalfSpace,\n    TriMeshFlags,\n    // #if DIM3\n    Cylinder,\n    RoundCylinder,\n    Cone,\n    RoundCone,\n    ConvexPolyhedron,\n    RoundConvexPolyhedron,\n    HeightFieldFlags,\n    // #endif\n} from \"./shape\";\nimport {Ray, RayIntersection} from \"./ray\";\nimport {PointProjection} from \"./point\";\nimport {ColliderShapeCastHit, ShapeCastHit} from \"./toi\";\nimport {ShapeContact} from \"./contact\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * Flags affecting whether collision-detection happens between two colliders\n * depending on the type of rigid-bodies they are attached to.\n */\nexport enum ActiveCollisionTypes {\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a dynamic body.\n     */\n    DYNAMIC_DYNAMIC = 0b0000_0000_0000_0001,\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a kinematic body.\n     */\n    DYNAMIC_KINEMATIC = 0b0000_0000_0000_1100,\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    DYNAMIC_FIXED = 0b0000_0000_0000_0010,\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a kinematic body.\n     */\n    KINEMATIC_KINEMATIC = 0b1100_1100_0000_0000,\n\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    KINEMATIC_FIXED = 0b0010_0010_0000_0000,\n\n    /**\n     * Enable collision-detection between a collider attached to a fixed body (or\n     * not attached to any body) and another collider attached to a fixed body (or\n     * not attached to any body).\n     */\n    FIXED_FIXED = 0b0000_0000_0010_0000,\n    /**\n     * The default active collision types, enabling collisions between a dynamic body\n     * and another body of any type, but not enabling collisions between two non-dynamic bodies.\n     */\n    DEFAULT = DYNAMIC_KINEMATIC | DYNAMIC_DYNAMIC | DYNAMIC_FIXED,\n    /**\n     * Enable collisions between any kind of rigid-bodies (including between two non-dynamic bodies).\n     */\n    ALL = DYNAMIC_KINEMATIC |\n        DYNAMIC_DYNAMIC |\n        DYNAMIC_FIXED |\n        KINEMATIC_KINEMATIC |\n        KINEMATIC_FIXED |\n        KINEMATIC_KINEMATIC,\n}\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type ColliderHandle = number;\n\n/**\n * A geometric entity that can be attached to a body so it can be affected\n * by contacts and proximity queries.\n */\nexport class Collider {\n    private colliderSet: ColliderSet; // The Collider won't need to free this.\n    readonly handle: ColliderHandle;\n    private _shape: Shape;\n    private _parent: RigidBody | null;\n\n    constructor(\n        colliderSet: ColliderSet,\n        handle: ColliderHandle,\n        parent: RigidBody | null,\n        shape?: Shape,\n    ) {\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n        this._parent = parent;\n        this._shape = shape;\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        if (this.handle != null) {\n            this._parent = bodies.get(\n                this.colliderSet.raw.coParent(this.handle),\n            );\n        }\n    }\n\n    private ensureShapeIsCached() {\n        if (!this._shape)\n            this._shape = Shape.fromRaw(this.colliderSet.raw, this.handle);\n    }\n\n    /**\n     * The shape of this collider.\n     */\n    public get shape(): Shape {\n        this.ensureShapeIsCached();\n        return this._shape;\n    }\n\n    /**\n     * Checks if this collider is still valid (i.e. that it has\n     * not been deleted from the collider set yet).\n     */\n    public isValid(): boolean {\n        return this.colliderSet.raw.contains(this.handle);\n    }\n\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    public translation(): Vector {\n        return VectorOps.fromRaw(\n            this.colliderSet.raw.coTranslation(this.handle),\n        );\n    }\n\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    public rotation(): Rotation {\n        return RotationOps.fromRaw(\n            this.colliderSet.raw.coRotation(this.handle),\n        );\n    }\n\n    /**\n     * Is this collider a sensor?\n     */\n    public isSensor(): boolean {\n        return this.colliderSet.raw.coIsSensor(this.handle);\n    }\n\n    /**\n     * Sets whether or not this collider is a sensor.\n     * @param isSensor - If `true`, the collider will be a sensor.\n     */\n    public setSensor(isSensor: boolean) {\n        this.colliderSet.raw.coSetSensor(this.handle, isSensor);\n    }\n\n    /**\n     * Sets the new shape of the collider.\n     * @param shape - The colliders new shape.\n     */\n    public setShape(shape: Shape) {\n        let rawShape = shape.intoRaw();\n        this.colliderSet.raw.coSetShape(this.handle, rawShape);\n        rawShape.free();\n        this._shape = shape;\n    }\n\n    /**\n     * Sets whether this collider is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this collider (its parent rigid-body wont be disabled automatically by this).\n     */\n    public setEnabled(enabled: boolean) {\n        this.colliderSet.raw.coSetEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Is this collider enabled?\n     */\n    public isEnabled(): boolean {\n        return this.colliderSet.raw.coIsEnabled(this.handle);\n    }\n\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    public setRestitution(restitution: number) {\n        this.colliderSet.raw.coSetRestitution(this.handle, restitution);\n    }\n\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    public setFriction(friction: number) {\n        this.colliderSet.raw.coSetFriction(this.handle, friction);\n    }\n\n    /**\n     * Gets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    public frictionCombineRule(): CoefficientCombineRule {\n        return this.colliderSet.raw.coFrictionCombineRule(this.handle);\n    }\n\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    public setFrictionCombineRule(rule: CoefficientCombineRule) {\n        this.colliderSet.raw.coSetFrictionCombineRule(this.handle, rule);\n    }\n\n    /**\n     * Gets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    public restitutionCombineRule(): CoefficientCombineRule {\n        return this.colliderSet.raw.coRestitutionCombineRule(this.handle);\n    }\n\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    public setRestitutionCombineRule(rule: CoefficientCombineRule) {\n        this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, rule);\n    }\n\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    public setCollisionGroups(groups: InteractionGroups) {\n        this.colliderSet.raw.coSetCollisionGroups(this.handle, groups);\n    }\n\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    public setSolverGroups(groups: InteractionGroups) {\n        this.colliderSet.raw.coSetSolverGroups(this.handle, groups);\n    }\n\n    /**\n     * Sets the contact skin for this collider.\n     *\n     * See the documentation of `ColliderDesc.setContactSkin` for additional details.\n     */\n    public contactSkin(): number {\n        return this.colliderSet.raw.coContactSkin(this.handle);\n    }\n\n    /**\n     * Sets the contact skin for this collider.\n     *\n     * See the documentation of `ColliderDesc.setContactSkin` for additional details.\n     *\n     * @param thickness - The contact skin thickness.\n     */\n    public setContactSkin(thickness: number) {\n        return this.colliderSet.raw.coSetContactSkin(this.handle, thickness);\n    }\n\n    /**\n     * Get the physics hooks active for this collider.\n     */\n    public activeHooks(): ActiveHooks {\n        return this.colliderSet.raw.coActiveHooks(this.handle);\n    }\n\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveHooks(activeHooks: ActiveHooks) {\n        this.colliderSet.raw.coSetActiveHooks(this.handle, activeHooks);\n    }\n\n    /**\n     * The events active for this collider.\n     */\n    public activeEvents(): ActiveEvents {\n        return this.colliderSet.raw.coActiveEvents(this.handle);\n    }\n\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    public setActiveEvents(activeEvents: ActiveEvents) {\n        this.colliderSet.raw.coSetActiveEvents(this.handle, activeEvents);\n    }\n\n    /**\n     * Gets the collision types active for this collider.\n     */\n    public activeCollisionTypes(): ActiveCollisionTypes {\n        return this.colliderSet.raw.coActiveCollisionTypes(this.handle);\n    }\n\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The new force threshold.\n     */\n    public setContactForceEventThreshold(threshold: number) {\n        return this.colliderSet.raw.coSetContactForceEventThreshold(\n            this.handle,\n            threshold,\n        );\n    }\n\n    /**\n     * The total force magnitude beyond which a contact force event can be emitted.\n     */\n    public contactForceEventThreshold(): number {\n        return this.colliderSet.raw.coContactForceEventThreshold(this.handle);\n    }\n\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveCollisionTypes(activeCollisionTypes: ActiveCollisionTypes) {\n        this.colliderSet.raw.coSetActiveCollisionTypes(\n            this.handle,\n            activeCollisionTypes,\n        );\n    }\n\n    /**\n     * Sets the uniform density of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The mass and angular inertia of this collider will be computed automatically based on its\n     * shape.\n     */\n    public setDensity(density: number) {\n        this.colliderSet.raw.coSetDensity(this.handle, density);\n    }\n\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The angular inertia of this collider will be computed automatically based on its shape\n     * and this mass value.\n     */\n    public setMass(mass: number) {\n        this.colliderSet.raw.coSetMass(this.handle, mass);\n    }\n\n    // #if DIM3\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     */\n    public setMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: Vector,\n        angularInertiaLocalFrame: Rotation,\n    ) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        let rawPrincipalInertia = VectorOps.intoRaw(principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(angularInertiaLocalFrame);\n\n        this.colliderSet.raw.coSetMassProperties(\n            this.handle,\n            mass,\n            rawCom,\n            rawPrincipalInertia,\n            rawInertiaFrame,\n        );\n\n        rawCom.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n    }\n\n    // #endif\n\n\n    /**\n     * Sets the translation of this collider.\n     *\n     * @param tra - The world-space position of the collider.\n     */\n    public setTranslation(tra: Vector) {\n        // #if DIM3\n        this.colliderSet.raw.coSetTranslation(this.handle, tra.x, tra.y, tra.z);\n        // #endif\n    }\n\n    /**\n     * Sets the translation of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param tra - The new translation of the collider relative to its parent.\n     */\n    public setTranslationWrtParent(tra: Vector) {\n        // #if DIM3\n        this.colliderSet.raw.coSetTranslationWrtParent(\n            this.handle,\n            tra.x,\n            tra.y,\n            tra.z,\n        );\n        // #endif\n    }\n\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this collider.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     */\n    public setRotation(rot: Rotation) {\n        this.colliderSet.raw.coSetRotation(\n            this.handle,\n            rot.x,\n            rot.y,\n            rot.z,\n            rot.w,\n        );\n    }\n\n    /**\n     * Sets the rotation quaternion of this collider relative to its parent rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided or if this collider isn't\n     * attached to a rigid-body.\n     *\n     * @param rotation - The rotation to set.\n     */\n    public setRotationWrtParent(rot: Rotation) {\n        this.colliderSet.raw.coSetRotationWrtParent(\n            this.handle,\n            rot.x,\n            rot.y,\n            rot.z,\n            rot.w,\n        );\n    }\n\n    // #endif\n\n    /**\n     * The type of the shape of this collider.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public shapeType(): ShapeType {\n        return this.colliderSet.raw.coShapeType(\n            this.handle,\n        ) as number as ShapeType;\n    }\n\n    /**\n     * The half-extents of this collider if it is a cuboid shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public halfExtents(): Vector {\n        return VectorOps.fromRaw(\n            this.colliderSet.raw.coHalfExtents(this.handle),\n        );\n    }\n\n    /**\n     * Sets the half-extents of this collider if it is a cuboid shape.\n     *\n     * @param newHalfExtents - desired half extents.\n     */\n    public setHalfExtents(newHalfExtents: Vector) {\n        const rawPoint = VectorOps.intoRaw(newHalfExtents);\n        this.colliderSet.raw.coSetHalfExtents(this.handle, rawPoint);\n    }\n\n    /**\n     * The radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public radius(): number {\n        return this.colliderSet.raw.coRadius(this.handle);\n    }\n\n    /**\n     * Sets the radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     *\n     * @param newRadius - desired radius.\n     */\n    public setRadius(newRadius: number): void {\n        this.colliderSet.raw.coSetRadius(this.handle, newRadius);\n    }\n\n    /**\n     * The radius of the round edges of this collider if it is a round cylinder.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public roundRadius(): number {\n        return this.colliderSet.raw.coRoundRadius(this.handle);\n    }\n\n    /**\n     * Sets the radius of the round edges of this collider if it has round edges.\n     *\n     * @param newBorderRadius - desired round edge radius.\n     */\n    public setRoundRadius(newBorderRadius: number) {\n        this.colliderSet.raw.coSetRoundRadius(this.handle, newBorderRadius);\n    }\n\n    /**\n     * The half height of this collider if it is a cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public halfHeight(): number {\n        return this.colliderSet.raw.coHalfHeight(this.handle);\n    }\n\n    /**\n     * Sets the half height of this collider if it is a cylinder, capsule, or cone shape.\n     *\n     * @param newHalfheight - desired half height.\n     */\n    public setHalfHeight(newHalfheight: number) {\n        this.colliderSet.raw.coSetHalfHeight(this.handle, newHalfheight);\n    }\n\n    /**\n     * If this collider has a triangle mesh, polyline, convex polygon, or convex polyhedron shape,\n     * this returns the vertex buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public vertices(): Float32Array {\n        return this.colliderSet.raw.coVertices(this.handle);\n    }\n\n    /**\n     * If this collider has a triangle mesh, polyline, or convex polyhedron shape,\n     * this returns the index buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public indices(): Uint32Array | undefined {\n        return this.colliderSet.raw.coIndices(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the heights buffer of\n     * the heightfield.\n     * In 3D, the returned height matrix is provided in column-major order.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldHeights(): Float32Array {\n        return this.colliderSet.raw.coHeightfieldHeights(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the scale\n     * applied to it.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldScale(): Vector {\n        let scale = this.colliderSet.raw.coHeightfieldScale(this.handle);\n        return VectorOps.fromRaw(scale);\n    }\n\n    // #if DIM3\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * rows of its height matrix.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldNRows(): number {\n        return this.colliderSet.raw.coHeightfieldNRows(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * columns of its height matrix.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldNCols(): number {\n        return this.colliderSet.raw.coHeightfieldNCols(this.handle);\n    }\n\n    // #endif\n\n    /**\n     * The rigid-body this collider is attached to.\n     */\n    public parent(): RigidBody | null {\n        return this._parent;\n    }\n\n    /**\n     * The friction coefficient of this collider.\n     */\n    public friction(): number {\n        return this.colliderSet.raw.coFriction(this.handle);\n    }\n\n    /**\n     * The restitution coefficient of this collider.\n     */\n    public restitution(): number {\n        return this.colliderSet.raw.coRestitution(this.handle);\n    }\n\n    /**\n     * The density of this collider.\n     */\n    public density(): number {\n        return this.colliderSet.raw.coDensity(this.handle);\n    }\n\n    /**\n     * The mass of this collider.\n     */\n    public mass(): number {\n        return this.colliderSet.raw.coMass(this.handle);\n    }\n\n    /**\n     * The volume of this collider.\n     */\n    public volume(): number {\n        return this.colliderSet.raw.coVolume(this.handle);\n    }\n\n    /**\n     * The collision groups of this collider.\n     */\n    public collisionGroups(): InteractionGroups {\n        return this.colliderSet.raw.coCollisionGroups(this.handle);\n    }\n\n    /**\n     * The solver groups of this collider.\n     */\n    public solverGroups(): InteractionGroups {\n        return this.colliderSet.raw.coSolverGroups(this.handle);\n    }\n\n    /**\n     * Tests if this collider contains a point.\n     *\n     * @param point - The point to test.\n     */\n    public containsPoint(point: Vector): boolean {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = this.colliderSet.raw.coContainsPoint(\n            this.handle,\n            rawPoint,\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on this collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     */\n    public projectPoint(point: Vector, solid: boolean): PointProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointProjection.fromRaw(\n            this.colliderSet.raw.coProjectPoint(this.handle, rawPoint, solid),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Tests if this collider intersects the given ray.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     */\n    public intersectsRay(ray: Ray, maxToi: number): boolean {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coIntersectsRay(\n            this.handle,\n            rawOrig,\n            rawDir,\n            maxToi,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /*\n     * Computes the smallest time between this and the given shape under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current shape to cast (i.e. the cast direction).\n     * @param shape2 - The shape to cast against.\n     * @param shape2Pos - The position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param shape2Vel - The constant velocity of the second shape.\n     * @param targetDistance  If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `collider1Vel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exit that penetration state.\n     */\n    public castShape(\n        collider1Vel: Vector,\n        shape2: Shape,\n        shape2Pos: Vector,\n        shape2Rot: Rotation,\n        shape2Vel: Vector,\n        targetDistance: number,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ShapeCastHit | null {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawShape2Pos = VectorOps.intoRaw(shape2Pos);\n        let rawShape2Rot = RotationOps.intoRaw(shape2Rot);\n        let rawShape2Vel = VectorOps.intoRaw(shape2Vel);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeCastHit.fromRaw(\n            this.colliderSet,\n            this.colliderSet.raw.coCastShape(\n                this.handle,\n                rawCollider1Vel,\n                rawShape2,\n                rawShape2Pos,\n                rawShape2Rot,\n                rawShape2Vel,\n                targetDistance,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawCollider1Vel.free();\n        rawShape2Pos.free();\n        rawShape2Rot.free();\n        rawShape2Vel.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /*\n     * Computes the smallest time between this and the given collider under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current collider to cast (i.e. the cast direction).\n     * @param collider2 - The collider to cast against.\n     * @param collider2Vel - The constant velocity of the second collider.\n     * @param targetDistance  If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exit that penetration state.\n     */\n    public castCollider(\n        collider1Vel: Vector,\n        collider2: Collider,\n        collider2Vel: Vector,\n        targetDistance: number,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ColliderShapeCastHit | null {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawCollider2Vel = VectorOps.intoRaw(collider2Vel);\n\n        let result = ColliderShapeCastHit.fromRaw(\n            this.colliderSet,\n            this.colliderSet.raw.coCastCollider(\n                this.handle,\n                rawCollider1Vel,\n                collider2.handle,\n                rawCollider2Vel,\n                targetDistance,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawCollider1Vel.free();\n        rawCollider2Vel.free();\n\n        return result;\n    }\n\n    public intersectsShape(\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n    ): boolean {\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = this.colliderSet.raw.coIntersectsShape(\n            this.handle,\n            rawShape2,\n            rawPos2,\n            rawRot2,\n        );\n\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between the shape owned by this collider and the given shape.\n     *\n     * @param shape2 - The second shape.\n     * @param shape2Pos - The initial position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(\n        shape2: Shape,\n        shape2Pos: Vector,\n        shape2Rot: Rotation,\n        prediction: number,\n    ): ShapeContact | null {\n        let rawPos2 = VectorOps.intoRaw(shape2Pos);\n        let rawRot2 = RotationOps.intoRaw(shape2Rot);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeContact.fromRaw(\n            this.colliderSet.raw.coContactShape(\n                this.handle,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                prediction,\n            ),\n        );\n\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between the collider and the given collider.\n     *\n     * @param collider2 - The second collider.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactCollider(\n        collider2: Collider,\n        prediction: number,\n    ): ShapeContact | null {\n        let result = ShapeContact.fromRaw(\n            this.colliderSet.raw.coContactCollider(\n                this.handle,\n                collider2.handle,\n                prediction,\n            ),\n        );\n\n        return result;\n    }\n\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @returns The time-of-impact between this collider and the ray, or `-1` if there is no intersection.\n     */\n    public castRay(ray: Ray, maxToi: number, solid: boolean): number {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coCastRay(\n            this.handle,\n            rawOrig,\n            rawDir,\n            maxToi,\n            solid,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     */\n    public castRayAndGetNormal(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n    ): RayIntersection | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayIntersection.fromRaw(\n            this.colliderSet.raw.coCastRayAndGetNormal(\n                this.handle,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n}\n\nexport enum MassPropsMode {\n    Density,\n    Mass,\n    MassProps,\n}\n\nexport class ColliderDesc {\n    enabled: boolean;\n    shape: Shape;\n    massPropsMode: MassPropsMode;\n    mass: number;\n    centerOfMass: Vector;\n    // #if DIM3\n    principalAngularInertia: Vector;\n    angularInertiaLocalFrame: Rotation;\n    // #endif\n    density: number;\n    friction: number;\n    restitution: number;\n    rotation: Rotation;\n    translation: Vector;\n    isSensor: boolean;\n    collisionGroups: InteractionGroups;\n    solverGroups: InteractionGroups;\n    frictionCombineRule: CoefficientCombineRule;\n    restitutionCombineRule: CoefficientCombineRule;\n    activeEvents: ActiveEvents;\n    activeHooks: ActiveHooks;\n    activeCollisionTypes: ActiveCollisionTypes;\n    contactForceEventThreshold: number;\n    contactSkin: number;\n\n    /**\n     * Initializes a collider descriptor from the collision shape.\n     *\n     * @param shape - The shape of the collider being built.\n     */\n    constructor(shape: Shape) {\n        this.enabled = true;\n        this.shape = shape;\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = 1.0;\n        this.friction = 0.5;\n        this.restitution = 0.0;\n        this.rotation = RotationOps.identity();\n        this.translation = VectorOps.zeros();\n        this.isSensor = false;\n        this.collisionGroups = 0xffff_ffff;\n        this.solverGroups = 0xffff_ffff;\n        this.frictionCombineRule = CoefficientCombineRule.Average;\n        this.restitutionCombineRule = CoefficientCombineRule.Average;\n        this.activeCollisionTypes = ActiveCollisionTypes.DEFAULT;\n        this.activeEvents = ActiveEvents.NONE;\n        this.activeHooks = ActiveHooks.NONE;\n        this.mass = 0.0;\n        this.centerOfMass = VectorOps.zeros();\n        this.contactForceEventThreshold = 0.0;\n        this.contactSkin = 0.0;\n\n        // #if DIM3\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        // #endif\n    }\n\n    /**\n     * Create a new collider descriptor with a ball shape.\n     *\n     * @param radius - The radius of the ball.\n     */\n    public static ball(radius: number): ColliderDesc {\n        const shape = new Ball(radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a capsule shape.\n     *\n     * @param halfHeight - The half-height of the capsule, along the `y` axis.\n     * @param radius - The radius of the capsule basis.\n     */\n    public static capsule(halfHeight: number, radius: number): ColliderDesc {\n        const shape = new Capsule(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new segment shape.\n     *\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    public static segment(a: Vector, b: Vector): ColliderDesc {\n        const shape = new Segment(a, b);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    public static triangle(a: Vector, b: Vector, c: Vector): ColliderDesc {\n        const shape = new Triangle(a, b, c);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    public static roundTriangle(\n        a: Vector,\n        b: Vector,\n        c: Vector,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundTriangle(a, b, c, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `undefined` or `null`,\n     *    the vertices are assumed to describe a line strip.\n     */\n    public static polyline(\n        vertices: Float32Array,\n        indices?: Uint32Array | null,\n    ): ColliderDesc {\n        const shape = new Polyline(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    public static trimesh(\n        vertices: Float32Array,\n        indices: Uint32Array,\n        flags?: TriMeshFlags,\n    ): ColliderDesc {\n        const shape = new TriMesh(vertices, indices, flags);\n        return new ColliderDesc(shape);\n    }\n\n\n    // #if DIM3\n    /**\n     * Creates a new collider descriptor with a cuboid shape.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     */\n    public static cuboid(hx: number, hy: number, hz: number): ColliderDesc {\n        const shape = new Cuboid(hx, hy, hz);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a rectangular shape with round borders.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     * @param borderRadius - The radius of the cuboid's borders.\n     */\n    public static roundCuboid(\n        hx: number,\n        hy: number,\n        hz: number,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundCuboid(hx, hy, hz, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a heightfield shape.\n     *\n     * @param nrows  The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    public static heightfield(\n        nrows: number,\n        ncols: number,\n        heights: Float32Array,\n        scale: Vector,\n        flags?: HeightFieldFlags,\n    ): ColliderDesc {\n        const shape = new Heightfield(nrows, ncols, heights, scale, flags);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cylinder shape.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     */\n    public static cylinder(halfHeight: number, radius: number): ColliderDesc {\n        const shape = new Cylinder(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cylinder shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     * @param borderRadius - The radius of the cylinder's rounded edges and vertices.\n     */\n    public static roundCylinder(\n        halfHeight: number,\n        radius: number,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundCylinder(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cone shape.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     */\n    public static cone(halfHeight: number, radius: number): ColliderDesc {\n        const shape = new Cone(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cone shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     * @param borderRadius - The radius of the cone's rounded edges and vertices.\n     */\n    public static roundCone(\n        halfHeight: number,\n        radius: number,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundCone(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     */\n    public static convexHull(points: Float32Array): ColliderDesc | null {\n        const shape = new ConvexPolyhedron(points, null);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     */\n    public static convexMesh(\n        vertices: Float32Array,\n        indices?: Uint32Array | null,\n    ): ColliderDesc | null {\n        const shape = new ConvexPolyhedron(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor. A\n     * border is added to that convex polyhedron to give it round corners.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     * @param borderRadius - The radius of the round border added to the convex polyhedron.\n     */\n    public static roundConvexHull(\n        points: Float32Array,\n        borderRadius: number,\n    ): ColliderDesc | null {\n        const shape = new RoundConvexPolyhedron(points, null, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a round convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     * @param borderRadius - The radius of the round border added to the convex polyline.\n     */\n    public static roundConvexMesh(\n        vertices: Float32Array,\n        indices: Uint32Array | null,\n        borderRadius: number,\n    ): ColliderDesc | null {\n        const shape = new RoundConvexPolyhedron(\n            vertices,\n            indices,\n            borderRadius,\n        );\n        return new ColliderDesc(shape);\n    }\n\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * Sets the position of the collider to be created relative to the rigid-body it is attached to.\n     */\n    public setTranslation(x: number, y: number, z: number): ColliderDesc {\n        if (\n            typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\"\n        )\n            throw TypeError(\"The translation components must be numbers.\");\n\n        this.translation = {x: x, y: y, z: z};\n        return this;\n    }\n\n    // #endif\n\n    /**\n     * Sets the rotation of the collider to be created relative to the rigid-body it is attached to.\n     *\n     * @param rot - The rotation of the collider to be created relative to the rigid-body it is attached to.\n     */\n    public setRotation(rot: Rotation): ColliderDesc {\n        // #if DIM3\n        RotationOps.copy(this.rotation, rot);\n        // #endif\n        return this;\n    }\n\n    /**\n     * Sets whether or not the collider being created is a sensor.\n     *\n     * A sensor collider does not take part of the physics simulation, but generates\n     * proximity events.\n     *\n     * @param sensor - Set to `true` of the collider built is to be a sensor.\n     */\n    public setSensor(sensor: boolean): ColliderDesc {\n        this.isSensor = sensor;\n        return this;\n    }\n\n    /**\n     * Sets whether the created collider will be enabled or disabled.\n     * @param enabled  If set to `false` the collider will be disabled at creation.\n     */\n    public setEnabled(enabled: boolean): ColliderDesc {\n        this.enabled = enabled;\n        return this;\n    }\n\n    /**\n     * Sets the contact skin of the collider.\n     *\n     * The contact skin acts as if the collider was enlarged with a skin of width `skin_thickness`\n     * around it, keeping objects further apart when colliding.\n     *\n     * A non-zero contact skin can increase performance, and in some cases, stability. However\n     * it creates a small gap between colliding object (equal to the sum of their skin). If the\n     * skin is sufficiently small, this might not be visually significant or can be hidden by the\n     * rendering assets.\n     */\n    public setContactSkin(thickness: number): ColliderDesc {\n        this.contactSkin = thickness;\n        return this;\n    }\n\n    /**\n     * Sets the density of the collider being built.\n     *\n     * The mass and angular inertia tensor will be computed automatically based on this density and the colliders shape.\n     *\n     * @param density - The density to set, must be greater or equal to 0. A density of 0 means that this collider\n     *                  will not affect the mass or angular inertia of the rigid-body it is attached to.\n     */\n    public setDensity(density: number): ColliderDesc {\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = density;\n        return this;\n    }\n\n    /**\n     * Sets the mass of the collider being built.\n     *\n     * The angular inertia tensor will be computed automatically based on this mass and the colliders shape.\n     *\n     * @param mass - The mass to set, must be greater or equal to 0.\n     */\n    public setMass(mass: number): ColliderDesc {\n        this.massPropsMode = MassPropsMode.Mass;\n        this.mass = mass;\n        return this;\n    }\n\n\n    // #if DIM3\n    /**\n     * Sets the mass properties of the collider being built.\n     *\n     * This replaces the mass-properties automatically computed from the collider's density and shape.\n     * These mass-properties will be added to the mass-properties of the rigid-body this collider will be attached to.\n     *\n     * @param mass  The mass of the collider to create.\n     * @param centerOfMass  The center-of-mass of the collider to create.\n     * @param principalAngularInertia  The initial principal angular inertia of the collider to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame  The initial local angular inertia frame of the collider to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    public setMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: Vector,\n        angularInertiaLocalFrame: Rotation,\n    ): ColliderDesc {\n        this.massPropsMode = MassPropsMode.MassProps;\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        VectorOps.copy(this.principalAngularInertia, principalAngularInertia);\n        RotationOps.copy(\n            this.angularInertiaLocalFrame,\n            angularInertiaLocalFrame,\n        );\n        return this;\n    }\n\n    // #endif\n\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    public setRestitution(restitution: number): ColliderDesc {\n        this.restitution = restitution;\n        return this;\n    }\n\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    public setFriction(friction: number): ColliderDesc {\n        this.friction = friction;\n        return this;\n    }\n\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    public setFrictionCombineRule(rule: CoefficientCombineRule): ColliderDesc {\n        this.frictionCombineRule = rule;\n        return this;\n    }\n\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    public setRestitutionCombineRule(\n        rule: CoefficientCombineRule,\n    ): ColliderDesc {\n        this.restitutionCombineRule = rule;\n        return this;\n    }\n\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    public setCollisionGroups(groups: InteractionGroups): ColliderDesc {\n        this.collisionGroups = groups;\n        return this;\n    }\n\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    public setSolverGroups(groups: InteractionGroups): ColliderDesc {\n        this.solverGroups = groups;\n        return this;\n    }\n\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveHooks(activeHooks: ActiveHooks): ColliderDesc {\n        this.activeHooks = activeHooks;\n        return this;\n    }\n\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    public setActiveEvents(activeEvents: ActiveEvents): ColliderDesc {\n        this.activeEvents = activeEvents;\n        return this;\n    }\n\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveCollisionTypes(\n        activeCollisionTypes: ActiveCollisionTypes,\n    ): ColliderDesc {\n        this.activeCollisionTypes = activeCollisionTypes;\n        return this;\n    }\n\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The force threshold to set.\n     */\n    public setContactForceEventThreshold(threshold: number): ColliderDesc {\n        this.contactForceEventThreshold = threshold;\n        return this;\n    }\n}\n", "import {RawColliderSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RotationOps, VectorOps} from \"../math\";\nimport {Collider, ColliderDesc, ColliderHandle} from \"./collider\";\nimport {ImpulseJointHandle, IslandManager, RigidBodyHandle} from \"../dynamics\";\nimport {RigidBodySet} from \"../dynamics\";\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `colliderSet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class ColliderSet {\n    raw: RawColliderSet;\n    private map: Coarena<Collider>;\n\n    /**\n     * Release the WASM memory occupied by this collider set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawColliderSet) {\n        this.raw = raw || new RawColliderSet();\n        this.map = new Coarena<Collider>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachColliderHandle((handle: ColliderHandle) => {\n                this.map.set(handle, new Collider(this, handle, null));\n            });\n        }\n    }\n\n    /** @internal */\n    public castClosure<Res>(\n        f?: (collider: Collider) => Res,\n    ): (handle: ColliderHandle) => Res | undefined {\n        return (handle) => {\n            if (!!f) {\n                return f(this.get(handle));\n            } else {\n                return undefined;\n            }\n        };\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        this.map.forEach((collider) =>\n            collider.finalizeDeserialization(bodies),\n        );\n    }\n\n    /**\n     * Creates a new collider and return its integer handle.\n     *\n     * @param bodies - The set of bodies where the collider's parent can be found.\n     * @param desc - The collider's description.\n     * @param parentHandle - The integer handle of the rigid-body this collider is attached to.\n     */\n    public createCollider(\n        bodies: RigidBodySet,\n        desc: ColliderDesc,\n        parentHandle: RigidBodyHandle,\n    ): Collider {\n        let hasParent = parentHandle != undefined && parentHandle != null;\n\n        if (hasParent && isNaN(parentHandle))\n            throw Error(\n                \"Cannot create a collider with a parent rigid-body handle that is not a number.\",\n            );\n\n        let rawShape = desc.shape.intoRaw();\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n\n        // #if DIM3\n        let rawPrincipalInertia = VectorOps.intoRaw(\n            desc.principalAngularInertia,\n        );\n        let rawInertiaFrame = RotationOps.intoRaw(\n            desc.angularInertiaLocalFrame,\n        );\n        // #endif\n\n        let handle = this.raw.createCollider(\n            desc.enabled,\n            rawShape,\n            rawTra,\n            rawRot,\n            desc.massPropsMode,\n            desc.mass,\n            rawCom,\n            // #if DIM3\n            rawPrincipalInertia,\n            rawInertiaFrame,\n            // #endif\n            desc.density,\n            desc.friction,\n            desc.restitution,\n            desc.frictionCombineRule,\n            desc.restitutionCombineRule,\n            desc.isSensor,\n            desc.collisionGroups,\n            desc.solverGroups,\n            desc.activeCollisionTypes,\n            desc.activeHooks,\n            desc.activeEvents,\n            desc.contactForceEventThreshold,\n            desc.contactSkin,\n            hasParent,\n            hasParent ? parentHandle : 0,\n            bodies.raw,\n        );\n\n        rawShape.free();\n        rawTra.free();\n        rawRot.free();\n        rawCom.free();\n\n        // #if DIM3\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n\n        let parent = hasParent ? bodies.get(parentHandle) : null;\n        let collider = new Collider(this, handle, parent, desc.shape);\n        this.map.set(handle, collider);\n        return collider;\n    }\n\n    /**\n     * Remove a collider from this set.\n     *\n     * @param handle - The integer handle of the collider to remove.\n     * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.\n     * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.\n     */\n    public remove(\n        handle: ColliderHandle,\n        islands: IslandManager,\n        bodies: RigidBodySet,\n        wakeUp: boolean,\n    ) {\n        this.raw.remove(handle, islands.raw, bodies.raw, wakeUp);\n        this.unmap(handle);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: ImpulseJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    public get(handle: ColliderHandle): Collider | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * The number of colliders on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a collider with the given handle?\n     *\n     * @param handle - The collider handle to check.\n     */\n    public contains(handle: ColliderHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Applies the given closure to each collider contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (collider: Collider) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Gets all colliders in the list.\n     *\n     * @returns collider list.\n     */\n    public getAll(): Collider[] {\n        return this.map.getAll();\n    }\n}\n", "import * as RAPIER from \"./exports\";\nexport * from \"./exports\";\nexport default RAPIER;\n"],
  "mappings": "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",
  "names": ["version", "wasm", "wasm", "RigidBodyType", "handle", "JointType", "MotorModel", "JointAxesMask", "CoefficientCombineRule", "FeatureType", "ShapeType", "HeightFieldFlags", "TriMeshFlags", "QueryFilterFlags", "PidAxesMask", "ActiveEvents", "ActiveHooks", "SolverFlags", "ActiveCollisionTypes", "MassPropsMode", "version"]
}
